
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model AIProcessingResult
 * 
 */
export type AIProcessingResult = $Result.DefaultSelection<Prisma.$AIProcessingResultPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model CacheEntry
 * 
 */
export type CacheEntry = $Result.DefaultSelection<Prisma.$CacheEntryPayload>
/**
 * Model SpedContribuicoesItem
 * 
 */
export type SpedContribuicoesItem = $Result.DefaultSelection<Prisma.$SpedContribuicoesItemPayload>
/**
 * Model SpedContribuicoesApuracao
 * 
 */
export type SpedContribuicoesApuracao = $Result.DefaultSelection<Prisma.$SpedContribuicoesApuracaoPayload>
/**
 * Model SpedFiscalItem
 * 
 */
export type SpedFiscalItem = $Result.DefaultSelection<Prisma.$SpedFiscalItemPayload>
/**
 * Model SpedFiscalApuracao
 * 
 */
export type SpedFiscalApuracao = $Result.DefaultSelection<Prisma.$SpedFiscalApuracaoPayload>
/**
 * Model XMLDocument
 * 
 */
export type XMLDocument = $Result.DefaultSelection<Prisma.$XMLDocumentPayload>
/**
 * Model XMLItem
 * 
 */
export type XMLItem = $Result.DefaultSelection<Prisma.$XMLItemPayload>
/**
 * Model Processamento
 * 
 */
export type Processamento = $Result.DefaultSelection<Prisma.$ProcessamentoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  AUDITOR: 'AUDITOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DocumentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const LogLevel: {
  ERROR: 'ERROR',
  WARN: 'WARN',
  INFO: 'INFO',
  DEBUG: 'DEBUG'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const ProcessamentoStatus: {
  PENDENTE: 'PENDENTE',
  PROCESSANDO: 'PROCESSANDO',
  CONCLUIDO: 'CONCLUIDO',
  ERRO: 'ERRO'
};

export type ProcessamentoStatus = (typeof ProcessamentoStatus)[keyof typeof ProcessamentoStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type ProcessamentoStatus = $Enums.ProcessamentoStatus

export const ProcessamentoStatus: typeof $Enums.ProcessamentoStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.aIProcessingResult`: Exposes CRUD operations for the **AIProcessingResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIProcessingResults
    * const aIProcessingResults = await prisma.aIProcessingResult.findMany()
    * ```
    */
  get aIProcessingResult(): Prisma.AIProcessingResultDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.cacheEntry`: Exposes CRUD operations for the **CacheEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CacheEntries
    * const cacheEntries = await prisma.cacheEntry.findMany()
    * ```
    */
  get cacheEntry(): Prisma.CacheEntryDelegate<ExtArgs>;

  /**
   * `prisma.spedContribuicoesItem`: Exposes CRUD operations for the **SpedContribuicoesItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpedContribuicoesItems
    * const spedContribuicoesItems = await prisma.spedContribuicoesItem.findMany()
    * ```
    */
  get spedContribuicoesItem(): Prisma.SpedContribuicoesItemDelegate<ExtArgs>;

  /**
   * `prisma.spedContribuicoesApuracao`: Exposes CRUD operations for the **SpedContribuicoesApuracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpedContribuicoesApuracaos
    * const spedContribuicoesApuracaos = await prisma.spedContribuicoesApuracao.findMany()
    * ```
    */
  get spedContribuicoesApuracao(): Prisma.SpedContribuicoesApuracaoDelegate<ExtArgs>;

  /**
   * `prisma.spedFiscalItem`: Exposes CRUD operations for the **SpedFiscalItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpedFiscalItems
    * const spedFiscalItems = await prisma.spedFiscalItem.findMany()
    * ```
    */
  get spedFiscalItem(): Prisma.SpedFiscalItemDelegate<ExtArgs>;

  /**
   * `prisma.spedFiscalApuracao`: Exposes CRUD operations for the **SpedFiscalApuracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpedFiscalApuracaos
    * const spedFiscalApuracaos = await prisma.spedFiscalApuracao.findMany()
    * ```
    */
  get spedFiscalApuracao(): Prisma.SpedFiscalApuracaoDelegate<ExtArgs>;

  /**
   * `prisma.xMLDocument`: Exposes CRUD operations for the **XMLDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XMLDocuments
    * const xMLDocuments = await prisma.xMLDocument.findMany()
    * ```
    */
  get xMLDocument(): Prisma.XMLDocumentDelegate<ExtArgs>;

  /**
   * `prisma.xMLItem`: Exposes CRUD operations for the **XMLItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XMLItems
    * const xMLItems = await prisma.xMLItem.findMany()
    * ```
    */
  get xMLItem(): Prisma.XMLItemDelegate<ExtArgs>;

  /**
   * `prisma.processamento`: Exposes CRUD operations for the **Processamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processamentos
    * const processamentos = await prisma.processamento.findMany()
    * ```
    */
  get processamento(): Prisma.ProcessamentoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Empresa: 'Empresa',
    Document: 'Document',
    AIProcessingResult: 'AIProcessingResult',
    Log: 'Log',
    CacheEntry: 'CacheEntry',
    SpedContribuicoesItem: 'SpedContribuicoesItem',
    SpedContribuicoesApuracao: 'SpedContribuicoesApuracao',
    SpedFiscalItem: 'SpedFiscalItem',
    SpedFiscalApuracao: 'SpedFiscalApuracao',
    XMLDocument: 'XMLDocument',
    XMLItem: 'XMLItem',
    Processamento: 'Processamento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "empresa" | "document" | "aIProcessingResult" | "log" | "cacheEntry" | "spedContribuicoesItem" | "spedContribuicoesApuracao" | "spedFiscalItem" | "spedFiscalApuracao" | "xMLDocument" | "xMLItem" | "processamento"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      AIProcessingResult: {
        payload: Prisma.$AIProcessingResultPayload<ExtArgs>
        fields: Prisma.AIProcessingResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIProcessingResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIProcessingResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          findFirst: {
            args: Prisma.AIProcessingResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIProcessingResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          findMany: {
            args: Prisma.AIProcessingResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>[]
          }
          create: {
            args: Prisma.AIProcessingResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          createMany: {
            args: Prisma.AIProcessingResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIProcessingResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>[]
          }
          delete: {
            args: Prisma.AIProcessingResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          update: {
            args: Prisma.AIProcessingResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          deleteMany: {
            args: Prisma.AIProcessingResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIProcessingResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIProcessingResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProcessingResultPayload>
          }
          aggregate: {
            args: Prisma.AIProcessingResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIProcessingResult>
          }
          groupBy: {
            args: Prisma.AIProcessingResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIProcessingResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIProcessingResultCountArgs<ExtArgs>
            result: $Utils.Optional<AIProcessingResultCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      CacheEntry: {
        payload: Prisma.$CacheEntryPayload<ExtArgs>
        fields: Prisma.CacheEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CacheEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CacheEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findFirst: {
            args: Prisma.CacheEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CacheEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findMany: {
            args: Prisma.CacheEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          create: {
            args: Prisma.CacheEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          createMany: {
            args: Prisma.CacheEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CacheEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          delete: {
            args: Prisma.CacheEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          update: {
            args: Prisma.CacheEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          deleteMany: {
            args: Prisma.CacheEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CacheEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CacheEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          aggregate: {
            args: Prisma.CacheEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCacheEntry>
          }
          groupBy: {
            args: Prisma.CacheEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CacheEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryCountAggregateOutputType> | number
          }
        }
      }
      SpedContribuicoesItem: {
        payload: Prisma.$SpedContribuicoesItemPayload<ExtArgs>
        fields: Prisma.SpedContribuicoesItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpedContribuicoesItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpedContribuicoesItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          findFirst: {
            args: Prisma.SpedContribuicoesItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpedContribuicoesItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          findMany: {
            args: Prisma.SpedContribuicoesItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>[]
          }
          create: {
            args: Prisma.SpedContribuicoesItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          createMany: {
            args: Prisma.SpedContribuicoesItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpedContribuicoesItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>[]
          }
          delete: {
            args: Prisma.SpedContribuicoesItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          update: {
            args: Prisma.SpedContribuicoesItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          deleteMany: {
            args: Prisma.SpedContribuicoesItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpedContribuicoesItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpedContribuicoesItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesItemPayload>
          }
          aggregate: {
            args: Prisma.SpedContribuicoesItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpedContribuicoesItem>
          }
          groupBy: {
            args: Prisma.SpedContribuicoesItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpedContribuicoesItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpedContribuicoesItemCountArgs<ExtArgs>
            result: $Utils.Optional<SpedContribuicoesItemCountAggregateOutputType> | number
          }
        }
      }
      SpedContribuicoesApuracao: {
        payload: Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>
        fields: Prisma.SpedContribuicoesApuracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpedContribuicoesApuracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpedContribuicoesApuracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          findFirst: {
            args: Prisma.SpedContribuicoesApuracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpedContribuicoesApuracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          findMany: {
            args: Prisma.SpedContribuicoesApuracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>[]
          }
          create: {
            args: Prisma.SpedContribuicoesApuracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          createMany: {
            args: Prisma.SpedContribuicoesApuracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpedContribuicoesApuracaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>[]
          }
          delete: {
            args: Prisma.SpedContribuicoesApuracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          update: {
            args: Prisma.SpedContribuicoesApuracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          deleteMany: {
            args: Prisma.SpedContribuicoesApuracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpedContribuicoesApuracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpedContribuicoesApuracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedContribuicoesApuracaoPayload>
          }
          aggregate: {
            args: Prisma.SpedContribuicoesApuracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpedContribuicoesApuracao>
          }
          groupBy: {
            args: Prisma.SpedContribuicoesApuracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpedContribuicoesApuracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpedContribuicoesApuracaoCountArgs<ExtArgs>
            result: $Utils.Optional<SpedContribuicoesApuracaoCountAggregateOutputType> | number
          }
        }
      }
      SpedFiscalItem: {
        payload: Prisma.$SpedFiscalItemPayload<ExtArgs>
        fields: Prisma.SpedFiscalItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpedFiscalItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpedFiscalItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          findFirst: {
            args: Prisma.SpedFiscalItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpedFiscalItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          findMany: {
            args: Prisma.SpedFiscalItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>[]
          }
          create: {
            args: Prisma.SpedFiscalItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          createMany: {
            args: Prisma.SpedFiscalItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpedFiscalItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>[]
          }
          delete: {
            args: Prisma.SpedFiscalItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          update: {
            args: Prisma.SpedFiscalItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          deleteMany: {
            args: Prisma.SpedFiscalItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpedFiscalItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpedFiscalItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalItemPayload>
          }
          aggregate: {
            args: Prisma.SpedFiscalItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpedFiscalItem>
          }
          groupBy: {
            args: Prisma.SpedFiscalItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpedFiscalItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpedFiscalItemCountArgs<ExtArgs>
            result: $Utils.Optional<SpedFiscalItemCountAggregateOutputType> | number
          }
        }
      }
      SpedFiscalApuracao: {
        payload: Prisma.$SpedFiscalApuracaoPayload<ExtArgs>
        fields: Prisma.SpedFiscalApuracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpedFiscalApuracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpedFiscalApuracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          findFirst: {
            args: Prisma.SpedFiscalApuracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpedFiscalApuracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          findMany: {
            args: Prisma.SpedFiscalApuracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>[]
          }
          create: {
            args: Prisma.SpedFiscalApuracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          createMany: {
            args: Prisma.SpedFiscalApuracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpedFiscalApuracaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>[]
          }
          delete: {
            args: Prisma.SpedFiscalApuracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          update: {
            args: Prisma.SpedFiscalApuracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          deleteMany: {
            args: Prisma.SpedFiscalApuracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpedFiscalApuracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpedFiscalApuracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpedFiscalApuracaoPayload>
          }
          aggregate: {
            args: Prisma.SpedFiscalApuracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpedFiscalApuracao>
          }
          groupBy: {
            args: Prisma.SpedFiscalApuracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpedFiscalApuracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpedFiscalApuracaoCountArgs<ExtArgs>
            result: $Utils.Optional<SpedFiscalApuracaoCountAggregateOutputType> | number
          }
        }
      }
      XMLDocument: {
        payload: Prisma.$XMLDocumentPayload<ExtArgs>
        fields: Prisma.XMLDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XMLDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XMLDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          findFirst: {
            args: Prisma.XMLDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XMLDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          findMany: {
            args: Prisma.XMLDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>[]
          }
          create: {
            args: Prisma.XMLDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          createMany: {
            args: Prisma.XMLDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XMLDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>[]
          }
          delete: {
            args: Prisma.XMLDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          update: {
            args: Prisma.XMLDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          deleteMany: {
            args: Prisma.XMLDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XMLDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XMLDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLDocumentPayload>
          }
          aggregate: {
            args: Prisma.XMLDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXMLDocument>
          }
          groupBy: {
            args: Prisma.XMLDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<XMLDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.XMLDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<XMLDocumentCountAggregateOutputType> | number
          }
        }
      }
      XMLItem: {
        payload: Prisma.$XMLItemPayload<ExtArgs>
        fields: Prisma.XMLItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XMLItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XMLItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          findFirst: {
            args: Prisma.XMLItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XMLItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          findMany: {
            args: Prisma.XMLItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>[]
          }
          create: {
            args: Prisma.XMLItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          createMany: {
            args: Prisma.XMLItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XMLItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>[]
          }
          delete: {
            args: Prisma.XMLItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          update: {
            args: Prisma.XMLItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          deleteMany: {
            args: Prisma.XMLItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XMLItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.XMLItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XMLItemPayload>
          }
          aggregate: {
            args: Prisma.XMLItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXMLItem>
          }
          groupBy: {
            args: Prisma.XMLItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<XMLItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.XMLItemCountArgs<ExtArgs>
            result: $Utils.Optional<XMLItemCountAggregateOutputType> | number
          }
        }
      }
      Processamento: {
        payload: Prisma.$ProcessamentoPayload<ExtArgs>
        fields: Prisma.ProcessamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          findFirst: {
            args: Prisma.ProcessamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          findMany: {
            args: Prisma.ProcessamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>[]
          }
          create: {
            args: Prisma.ProcessamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          createMany: {
            args: Prisma.ProcessamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>[]
          }
          delete: {
            args: Prisma.ProcessamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          update: {
            args: Prisma.ProcessamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          deleteMany: {
            args: Prisma.ProcessamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcessamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessamentoPayload>
          }
          aggregate: {
            args: Prisma.ProcessamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessamento>
          }
          groupBy: {
            args: Prisma.ProcessamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessamentoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessamentoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    documents: number
    processamentos: number
    sessions: number
    logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    processamentos?: boolean | UserCountOutputTypeCountProcessamentosArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessamentoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }


  /**
   * Count Type EmpresaCountOutputType
   */

  export type EmpresaCountOutputType = {
    documentos: number
    spedContribuicoesItems: number
    spedContribuicoesApuracao: number
    spedFiscalItems: number
    spedFiscalApuracao: number
    xmlDocuments: number
  }

  export type EmpresaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | EmpresaCountOutputTypeCountDocumentosArgs
    spedContribuicoesItems?: boolean | EmpresaCountOutputTypeCountSpedContribuicoesItemsArgs
    spedContribuicoesApuracao?: boolean | EmpresaCountOutputTypeCountSpedContribuicoesApuracaoArgs
    spedFiscalItems?: boolean | EmpresaCountOutputTypeCountSpedFiscalItemsArgs
    spedFiscalApuracao?: boolean | EmpresaCountOutputTypeCountSpedFiscalApuracaoArgs
    xmlDocuments?: boolean | EmpresaCountOutputTypeCountXmlDocumentsArgs
  }

  // Custom InputTypes
  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpresaCountOutputType
     */
    select?: EmpresaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountSpedContribuicoesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesItemWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountSpedContribuicoesApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesApuracaoWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountSpedFiscalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalItemWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountSpedFiscalApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalApuracaoWhereInput
  }

  /**
   * EmpresaCountOutputType without action
   */
  export type EmpresaCountOutputTypeCountXmlDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XMLDocumentWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    processamentos: number
    aiResults: number
    xmlDocuments: number
    spedContribuicoesItems: number
    spedContribuicoesApuracoes: number
    spedFiscalItems: number
    spedFiscalApuracoes: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    processamentos?: boolean | DocumentCountOutputTypeCountProcessamentosArgs
    aiResults?: boolean | DocumentCountOutputTypeCountAiResultsArgs
    xmlDocuments?: boolean | DocumentCountOutputTypeCountXmlDocumentsArgs
    spedContribuicoesItems?: boolean | DocumentCountOutputTypeCountSpedContribuicoesItemsArgs
    spedContribuicoesApuracoes?: boolean | DocumentCountOutputTypeCountSpedContribuicoesApuracoesArgs
    spedFiscalItems?: boolean | DocumentCountOutputTypeCountSpedFiscalItemsArgs
    spedFiscalApuracoes?: boolean | DocumentCountOutputTypeCountSpedFiscalApuracoesArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountProcessamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessamentoWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountAiResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProcessingResultWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountXmlDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XMLDocumentWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSpedContribuicoesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesItemWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSpedContribuicoesApuracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesApuracaoWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSpedFiscalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalItemWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSpedFiscalApuracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalApuracaoWhereInput
  }


  /**
   * Count Type XMLDocumentCountOutputType
   */

  export type XMLDocumentCountOutputType = {
    itens: number
  }

  export type XMLDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itens?: boolean | XMLDocumentCountOutputTypeCountItensArgs
  }

  // Custom InputTypes
  /**
   * XMLDocumentCountOutputType without action
   */
  export type XMLDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocumentCountOutputType
     */
    select?: XMLDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * XMLDocumentCountOutputType without action
   */
  export type XMLDocumentCountOutputTypeCountItensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XMLItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | User$documentsArgs<ExtArgs>
    processamentos?: boolean | User$processamentosArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | User$documentsArgs<ExtArgs>
    processamentos?: boolean | User$processamentosArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      processamentos: Prisma.$ProcessamentoPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    processamentos<T extends User$processamentosArgs<ExtArgs> = {}>(args?: Subset<T, User$processamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.processamentos
   */
  export type User$processamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    where?: ProcessamentoWhereInput
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    cursor?: ProcessamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessamentoScalarFieldEnum | ProcessamentoScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaMinAggregateOutputType = {
    id: string | null
    cnpj: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    ie: string | null
    im: string | null
    cnae: string | null
    endereco: string | null
    regimeTributario: string | null
    dataCadastro: Date | null
    updatedAt: Date | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id: string | null
    cnpj: string | null
    razaoSocial: string | null
    nomeFantasia: string | null
    ie: string | null
    im: string | null
    cnae: string | null
    endereco: string | null
    regimeTributario: string | null
    dataCadastro: Date | null
    updatedAt: Date | null
  }

  export type EmpresaCountAggregateOutputType = {
    id: number
    cnpj: number
    razaoSocial: number
    nomeFantasia: number
    ie: number
    im: number
    cnae: number
    endereco: number
    regimeTributario: number
    dataCadastro: number
    updatedAt: number
    _all: number
  }


  export type EmpresaMinAggregateInputType = {
    id?: true
    cnpj?: true
    razaoSocial?: true
    nomeFantasia?: true
    ie?: true
    im?: true
    cnae?: true
    endereco?: true
    regimeTributario?: true
    dataCadastro?: true
    updatedAt?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id?: true
    cnpj?: true
    razaoSocial?: true
    nomeFantasia?: true
    ie?: true
    im?: true
    cnae?: true
    endereco?: true
    regimeTributario?: true
    dataCadastro?: true
    updatedAt?: true
  }

  export type EmpresaCountAggregateInputType = {
    id?: true
    cnpj?: true
    razaoSocial?: true
    nomeFantasia?: true
    ie?: true
    im?: true
    cnae?: true
    endereco?: true
    regimeTributario?: true
    dataCadastro?: true
    updatedAt?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id: string
    cnpj: string
    razaoSocial: string
    nomeFantasia: string | null
    ie: string | null
    im: string | null
    cnae: string | null
    endereco: string | null
    regimeTributario: string | null
    dataCadastro: Date
    updatedAt: Date
    _count: EmpresaCountAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cnpj?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    ie?: boolean
    im?: boolean
    cnae?: boolean
    endereco?: boolean
    regimeTributario?: boolean
    dataCadastro?: boolean
    updatedAt?: boolean
    documentos?: boolean | Empresa$documentosArgs<ExtArgs>
    spedContribuicoesItems?: boolean | Empresa$spedContribuicoesItemsArgs<ExtArgs>
    spedContribuicoesApuracao?: boolean | Empresa$spedContribuicoesApuracaoArgs<ExtArgs>
    spedFiscalItems?: boolean | Empresa$spedFiscalItemsArgs<ExtArgs>
    spedFiscalApuracao?: boolean | Empresa$spedFiscalApuracaoArgs<ExtArgs>
    xmlDocuments?: boolean | Empresa$xmlDocumentsArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cnpj?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    ie?: boolean
    im?: boolean
    cnae?: boolean
    endereco?: boolean
    regimeTributario?: boolean
    dataCadastro?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectScalar = {
    id?: boolean
    cnpj?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    ie?: boolean
    im?: boolean
    cnae?: boolean
    endereco?: boolean
    regimeTributario?: boolean
    dataCadastro?: boolean
    updatedAt?: boolean
  }

  export type EmpresaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | Empresa$documentosArgs<ExtArgs>
    spedContribuicoesItems?: boolean | Empresa$spedContribuicoesItemsArgs<ExtArgs>
    spedContribuicoesApuracao?: boolean | Empresa$spedContribuicoesApuracaoArgs<ExtArgs>
    spedFiscalItems?: boolean | Empresa$spedFiscalItemsArgs<ExtArgs>
    spedFiscalApuracao?: boolean | Empresa$spedFiscalApuracaoArgs<ExtArgs>
    xmlDocuments?: boolean | Empresa$xmlDocumentsArgs<ExtArgs>
    _count?: boolean | EmpresaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmpresaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {
      documentos: Prisma.$DocumentPayload<ExtArgs>[]
      spedContribuicoesItems: Prisma.$SpedContribuicoesItemPayload<ExtArgs>[]
      spedContribuicoesApuracao: Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>[]
      spedFiscalItems: Prisma.$SpedFiscalItemPayload<ExtArgs>[]
      spedFiscalApuracao: Prisma.$SpedFiscalApuracaoPayload<ExtArgs>[]
      xmlDocuments: Prisma.$XMLDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cnpj: string
      razaoSocial: string
      nomeFantasia: string | null
      ie: string | null
      im: string | null
      cnae: string | null
      endereco: string | null
      regimeTributario: string | null
      dataCadastro: Date
      updatedAt: Date
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaWithIdOnly = await prisma.empresa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {EmpresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empresas and only return the `id`
     * const empresaWithIdOnly = await prisma.empresa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentos<T extends Empresa$documentosArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    spedContribuicoesItems<T extends Empresa$spedContribuicoesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$spedContribuicoesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findMany"> | Null>
    spedContribuicoesApuracao<T extends Empresa$spedContribuicoesApuracaoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$spedContribuicoesApuracaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findMany"> | Null>
    spedFiscalItems<T extends Empresa$spedFiscalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$spedFiscalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findMany"> | Null>
    spedFiscalApuracao<T extends Empresa$spedFiscalApuracaoArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$spedFiscalApuracaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findMany"> | Null>
    xmlDocuments<T extends Empresa$xmlDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Empresa$xmlDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id: FieldRef<"Empresa", 'String'>
    readonly cnpj: FieldRef<"Empresa", 'String'>
    readonly razaoSocial: FieldRef<"Empresa", 'String'>
    readonly nomeFantasia: FieldRef<"Empresa", 'String'>
    readonly ie: FieldRef<"Empresa", 'String'>
    readonly im: FieldRef<"Empresa", 'String'>
    readonly cnae: FieldRef<"Empresa", 'String'>
    readonly endereco: FieldRef<"Empresa", 'String'>
    readonly regimeTributario: FieldRef<"Empresa", 'String'>
    readonly dataCadastro: FieldRef<"Empresa", 'DateTime'>
    readonly updatedAt: FieldRef<"Empresa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa createManyAndReturn
   */
  export type EmpresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa.documentos
   */
  export type Empresa$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Empresa.spedContribuicoesItems
   */
  export type Empresa$spedContribuicoesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    where?: SpedContribuicoesItemWhereInput
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    cursor?: SpedContribuicoesItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedContribuicoesItemScalarFieldEnum | SpedContribuicoesItemScalarFieldEnum[]
  }

  /**
   * Empresa.spedContribuicoesApuracao
   */
  export type Empresa$spedContribuicoesApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    where?: SpedContribuicoesApuracaoWhereInput
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedContribuicoesApuracaoScalarFieldEnum | SpedContribuicoesApuracaoScalarFieldEnum[]
  }

  /**
   * Empresa.spedFiscalItems
   */
  export type Empresa$spedFiscalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    where?: SpedFiscalItemWhereInput
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    cursor?: SpedFiscalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedFiscalItemScalarFieldEnum | SpedFiscalItemScalarFieldEnum[]
  }

  /**
   * Empresa.spedFiscalApuracao
   */
  export type Empresa$spedFiscalApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    where?: SpedFiscalApuracaoWhereInput
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedFiscalApuracaoScalarFieldEnum | SpedFiscalApuracaoScalarFieldEnum[]
  }

  /**
   * Empresa.xmlDocuments
   */
  export type Empresa$xmlDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    where?: XMLDocumentWhereInput
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    cursor?: XMLDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XMLDocumentScalarFieldEnum | XMLDocumentScalarFieldEnum[]
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalName: string | null
    path: string | null
    size: number | null
    mimeType: string | null
    status: $Enums.DocumentStatus | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalName: string | null
    path: string | null
    size: number | null
    mimeType: string | null
    status: $Enums.DocumentStatus | null
    empresaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    filename: number
    originalName: number
    path: number
    size: number
    mimeType: number
    status: number
    metadata: number
    empresaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    path?: true
    size?: true
    mimeType?: true
    status?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    path?: true
    size?: true
    mimeType?: true
    status?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    path?: true
    size?: true
    mimeType?: true
    status?: true
    metadata?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata: JsonValue | null
    empresaId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    status?: boolean
    metadata?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    empresa?: boolean | Document$empresaArgs<ExtArgs>
    processamentos?: boolean | Document$processamentosArgs<ExtArgs>
    aiResults?: boolean | Document$aiResultsArgs<ExtArgs>
    xmlDocuments?: boolean | Document$xmlDocumentsArgs<ExtArgs>
    spedContribuicoesItems?: boolean | Document$spedContribuicoesItemsArgs<ExtArgs>
    spedContribuicoesApuracoes?: boolean | Document$spedContribuicoesApuracoesArgs<ExtArgs>
    spedFiscalItems?: boolean | Document$spedFiscalItemsArgs<ExtArgs>
    spedFiscalApuracoes?: boolean | Document$spedFiscalApuracoesArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    status?: boolean
    metadata?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    empresa?: boolean | Document$empresaArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    path?: boolean
    size?: boolean
    mimeType?: boolean
    status?: boolean
    metadata?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    empresa?: boolean | Document$empresaArgs<ExtArgs>
    processamentos?: boolean | Document$processamentosArgs<ExtArgs>
    aiResults?: boolean | Document$aiResultsArgs<ExtArgs>
    xmlDocuments?: boolean | Document$xmlDocumentsArgs<ExtArgs>
    spedContribuicoesItems?: boolean | Document$spedContribuicoesItemsArgs<ExtArgs>
    spedContribuicoesApuracoes?: boolean | Document$spedContribuicoesApuracoesArgs<ExtArgs>
    spedFiscalItems?: boolean | Document$spedFiscalItemsArgs<ExtArgs>
    spedFiscalApuracoes?: boolean | Document$spedFiscalApuracoesArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    empresa?: boolean | Document$empresaArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs> | null
      processamentos: Prisma.$ProcessamentoPayload<ExtArgs>[]
      aiResults: Prisma.$AIProcessingResultPayload<ExtArgs>[]
      xmlDocuments: Prisma.$XMLDocumentPayload<ExtArgs>[]
      spedContribuicoesItems: Prisma.$SpedContribuicoesItemPayload<ExtArgs>[]
      spedContribuicoesApuracoes: Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>[]
      spedFiscalItems: Prisma.$SpedFiscalItemPayload<ExtArgs>[]
      spedFiscalApuracoes: Prisma.$SpedFiscalApuracaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      filename: string
      originalName: string
      path: string
      size: number
      mimeType: string
      status: $Enums.DocumentStatus
      metadata: Prisma.JsonValue | null
      empresaId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends Document$empresaArgs<ExtArgs> = {}>(args?: Subset<T, Document$empresaArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    processamentos<T extends Document$processamentosArgs<ExtArgs> = {}>(args?: Subset<T, Document$processamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findMany"> | Null>
    aiResults<T extends Document$aiResultsArgs<ExtArgs> = {}>(args?: Subset<T, Document$aiResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findMany"> | Null>
    xmlDocuments<T extends Document$xmlDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Document$xmlDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    spedContribuicoesItems<T extends Document$spedContribuicoesItemsArgs<ExtArgs> = {}>(args?: Subset<T, Document$spedContribuicoesItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findMany"> | Null>
    spedContribuicoesApuracoes<T extends Document$spedContribuicoesApuracoesArgs<ExtArgs> = {}>(args?: Subset<T, Document$spedContribuicoesApuracoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findMany"> | Null>
    spedFiscalItems<T extends Document$spedFiscalItemsArgs<ExtArgs> = {}>(args?: Subset<T, Document$spedFiscalItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findMany"> | Null>
    spedFiscalApuracoes<T extends Document$spedFiscalApuracoesArgs<ExtArgs> = {}>(args?: Subset<T, Document$spedFiscalApuracoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly originalName: FieldRef<"Document", 'String'>
    readonly path: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly empresaId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document.empresa
   */
  export type Document$empresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpresaInclude<ExtArgs> | null
    where?: EmpresaWhereInput
  }

  /**
   * Document.processamentos
   */
  export type Document$processamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    where?: ProcessamentoWhereInput
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    cursor?: ProcessamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessamentoScalarFieldEnum | ProcessamentoScalarFieldEnum[]
  }

  /**
   * Document.aiResults
   */
  export type Document$aiResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    where?: AIProcessingResultWhereInput
    orderBy?: AIProcessingResultOrderByWithRelationInput | AIProcessingResultOrderByWithRelationInput[]
    cursor?: AIProcessingResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIProcessingResultScalarFieldEnum | AIProcessingResultScalarFieldEnum[]
  }

  /**
   * Document.xmlDocuments
   */
  export type Document$xmlDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    where?: XMLDocumentWhereInput
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    cursor?: XMLDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XMLDocumentScalarFieldEnum | XMLDocumentScalarFieldEnum[]
  }

  /**
   * Document.spedContribuicoesItems
   */
  export type Document$spedContribuicoesItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    where?: SpedContribuicoesItemWhereInput
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    cursor?: SpedContribuicoesItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedContribuicoesItemScalarFieldEnum | SpedContribuicoesItemScalarFieldEnum[]
  }

  /**
   * Document.spedContribuicoesApuracoes
   */
  export type Document$spedContribuicoesApuracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    where?: SpedContribuicoesApuracaoWhereInput
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedContribuicoesApuracaoScalarFieldEnum | SpedContribuicoesApuracaoScalarFieldEnum[]
  }

  /**
   * Document.spedFiscalItems
   */
  export type Document$spedFiscalItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    where?: SpedFiscalItemWhereInput
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    cursor?: SpedFiscalItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedFiscalItemScalarFieldEnum | SpedFiscalItemScalarFieldEnum[]
  }

  /**
   * Document.spedFiscalApuracoes
   */
  export type Document$spedFiscalApuracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    where?: SpedFiscalApuracaoWhereInput
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpedFiscalApuracaoScalarFieldEnum | SpedFiscalApuracaoScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model AIProcessingResult
   */

  export type AggregateAIProcessingResult = {
    _count: AIProcessingResultCountAggregateOutputType | null
    _avg: AIProcessingResultAvgAggregateOutputType | null
    _sum: AIProcessingResultSumAggregateOutputType | null
    _min: AIProcessingResultMinAggregateOutputType | null
    _max: AIProcessingResultMaxAggregateOutputType | null
  }

  export type AIProcessingResultAvgAggregateOutputType = {
    tokens: number | null
    processingTime: number | null
  }

  export type AIProcessingResultSumAggregateOutputType = {
    tokens: number | null
    processingTime: number | null
  }

  export type AIProcessingResultMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    tokens: number | null
    processingTime: number | null
    error: string | null
    createdAt: Date | null
  }

  export type AIProcessingResultMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    model: string | null
    tokens: number | null
    processingTime: number | null
    error: string | null
    createdAt: Date | null
  }

  export type AIProcessingResultCountAggregateOutputType = {
    id: number
    documentId: number
    model: number
    tokens: number
    processingTime: number
    result: number
    error: number
    createdAt: number
    _all: number
  }


  export type AIProcessingResultAvgAggregateInputType = {
    tokens?: true
    processingTime?: true
  }

  export type AIProcessingResultSumAggregateInputType = {
    tokens?: true
    processingTime?: true
  }

  export type AIProcessingResultMinAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    tokens?: true
    processingTime?: true
    error?: true
    createdAt?: true
  }

  export type AIProcessingResultMaxAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    tokens?: true
    processingTime?: true
    error?: true
    createdAt?: true
  }

  export type AIProcessingResultCountAggregateInputType = {
    id?: true
    documentId?: true
    model?: true
    tokens?: true
    processingTime?: true
    result?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type AIProcessingResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProcessingResult to aggregate.
     */
    where?: AIProcessingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProcessingResults to fetch.
     */
    orderBy?: AIProcessingResultOrderByWithRelationInput | AIProcessingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIProcessingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProcessingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProcessingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIProcessingResults
    **/
    _count?: true | AIProcessingResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIProcessingResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIProcessingResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIProcessingResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIProcessingResultMaxAggregateInputType
  }

  export type GetAIProcessingResultAggregateType<T extends AIProcessingResultAggregateArgs> = {
        [P in keyof T & keyof AggregateAIProcessingResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIProcessingResult[P]>
      : GetScalarType<T[P], AggregateAIProcessingResult[P]>
  }




  export type AIProcessingResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProcessingResultWhereInput
    orderBy?: AIProcessingResultOrderByWithAggregationInput | AIProcessingResultOrderByWithAggregationInput[]
    by: AIProcessingResultScalarFieldEnum[] | AIProcessingResultScalarFieldEnum
    having?: AIProcessingResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIProcessingResultCountAggregateInputType | true
    _avg?: AIProcessingResultAvgAggregateInputType
    _sum?: AIProcessingResultSumAggregateInputType
    _min?: AIProcessingResultMinAggregateInputType
    _max?: AIProcessingResultMaxAggregateInputType
  }

  export type AIProcessingResultGroupByOutputType = {
    id: string
    documentId: string
    model: string
    tokens: number
    processingTime: number
    result: JsonValue
    error: string | null
    createdAt: Date
    _count: AIProcessingResultCountAggregateOutputType | null
    _avg: AIProcessingResultAvgAggregateOutputType | null
    _sum: AIProcessingResultSumAggregateOutputType | null
    _min: AIProcessingResultMinAggregateOutputType | null
    _max: AIProcessingResultMaxAggregateOutputType | null
  }

  type GetAIProcessingResultGroupByPayload<T extends AIProcessingResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIProcessingResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIProcessingResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIProcessingResultGroupByOutputType[P]>
            : GetScalarType<T[P], AIProcessingResultGroupByOutputType[P]>
        }
      >
    >


  export type AIProcessingResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    tokens?: boolean
    processingTime?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIProcessingResult"]>

  export type AIProcessingResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    model?: boolean
    tokens?: boolean
    processingTime?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIProcessingResult"]>

  export type AIProcessingResultSelectScalar = {
    id?: boolean
    documentId?: boolean
    model?: boolean
    tokens?: boolean
    processingTime?: boolean
    result?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type AIProcessingResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type AIProcessingResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $AIProcessingResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIProcessingResult"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      model: string
      tokens: number
      processingTime: number
      result: Prisma.JsonValue
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIProcessingResult"]>
    composites: {}
  }

  type AIProcessingResultGetPayload<S extends boolean | null | undefined | AIProcessingResultDefaultArgs> = $Result.GetResult<Prisma.$AIProcessingResultPayload, S>

  type AIProcessingResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIProcessingResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIProcessingResultCountAggregateInputType | true
    }

  export interface AIProcessingResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIProcessingResult'], meta: { name: 'AIProcessingResult' } }
    /**
     * Find zero or one AIProcessingResult that matches the filter.
     * @param {AIProcessingResultFindUniqueArgs} args - Arguments to find a AIProcessingResult
     * @example
     * // Get one AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIProcessingResultFindUniqueArgs>(args: SelectSubset<T, AIProcessingResultFindUniqueArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIProcessingResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIProcessingResultFindUniqueOrThrowArgs} args - Arguments to find a AIProcessingResult
     * @example
     * // Get one AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIProcessingResultFindUniqueOrThrowArgs>(args: SelectSubset<T, AIProcessingResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIProcessingResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultFindFirstArgs} args - Arguments to find a AIProcessingResult
     * @example
     * // Get one AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIProcessingResultFindFirstArgs>(args?: SelectSubset<T, AIProcessingResultFindFirstArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIProcessingResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultFindFirstOrThrowArgs} args - Arguments to find a AIProcessingResult
     * @example
     * // Get one AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIProcessingResultFindFirstOrThrowArgs>(args?: SelectSubset<T, AIProcessingResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIProcessingResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIProcessingResults
     * const aIProcessingResults = await prisma.aIProcessingResult.findMany()
     * 
     * // Get first 10 AIProcessingResults
     * const aIProcessingResults = await prisma.aIProcessingResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIProcessingResultWithIdOnly = await prisma.aIProcessingResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIProcessingResultFindManyArgs>(args?: SelectSubset<T, AIProcessingResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIProcessingResult.
     * @param {AIProcessingResultCreateArgs} args - Arguments to create a AIProcessingResult.
     * @example
     * // Create one AIProcessingResult
     * const AIProcessingResult = await prisma.aIProcessingResult.create({
     *   data: {
     *     // ... data to create a AIProcessingResult
     *   }
     * })
     * 
     */
    create<T extends AIProcessingResultCreateArgs>(args: SelectSubset<T, AIProcessingResultCreateArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIProcessingResults.
     * @param {AIProcessingResultCreateManyArgs} args - Arguments to create many AIProcessingResults.
     * @example
     * // Create many AIProcessingResults
     * const aIProcessingResult = await prisma.aIProcessingResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIProcessingResultCreateManyArgs>(args?: SelectSubset<T, AIProcessingResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIProcessingResults and returns the data saved in the database.
     * @param {AIProcessingResultCreateManyAndReturnArgs} args - Arguments to create many AIProcessingResults.
     * @example
     * // Create many AIProcessingResults
     * const aIProcessingResult = await prisma.aIProcessingResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIProcessingResults and only return the `id`
     * const aIProcessingResultWithIdOnly = await prisma.aIProcessingResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIProcessingResultCreateManyAndReturnArgs>(args?: SelectSubset<T, AIProcessingResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AIProcessingResult.
     * @param {AIProcessingResultDeleteArgs} args - Arguments to delete one AIProcessingResult.
     * @example
     * // Delete one AIProcessingResult
     * const AIProcessingResult = await prisma.aIProcessingResult.delete({
     *   where: {
     *     // ... filter to delete one AIProcessingResult
     *   }
     * })
     * 
     */
    delete<T extends AIProcessingResultDeleteArgs>(args: SelectSubset<T, AIProcessingResultDeleteArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIProcessingResult.
     * @param {AIProcessingResultUpdateArgs} args - Arguments to update one AIProcessingResult.
     * @example
     * // Update one AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIProcessingResultUpdateArgs>(args: SelectSubset<T, AIProcessingResultUpdateArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIProcessingResults.
     * @param {AIProcessingResultDeleteManyArgs} args - Arguments to filter AIProcessingResults to delete.
     * @example
     * // Delete a few AIProcessingResults
     * const { count } = await prisma.aIProcessingResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIProcessingResultDeleteManyArgs>(args?: SelectSubset<T, AIProcessingResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProcessingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIProcessingResults
     * const aIProcessingResult = await prisma.aIProcessingResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIProcessingResultUpdateManyArgs>(args: SelectSubset<T, AIProcessingResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIProcessingResult.
     * @param {AIProcessingResultUpsertArgs} args - Arguments to update or create a AIProcessingResult.
     * @example
     * // Update or create a AIProcessingResult
     * const aIProcessingResult = await prisma.aIProcessingResult.upsert({
     *   create: {
     *     // ... data to create a AIProcessingResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIProcessingResult we want to update
     *   }
     * })
     */
    upsert<T extends AIProcessingResultUpsertArgs>(args: SelectSubset<T, AIProcessingResultUpsertArgs<ExtArgs>>): Prisma__AIProcessingResultClient<$Result.GetResult<Prisma.$AIProcessingResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIProcessingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultCountArgs} args - Arguments to filter AIProcessingResults to count.
     * @example
     * // Count the number of AIProcessingResults
     * const count = await prisma.aIProcessingResult.count({
     *   where: {
     *     // ... the filter for the AIProcessingResults we want to count
     *   }
     * })
    **/
    count<T extends AIProcessingResultCountArgs>(
      args?: Subset<T, AIProcessingResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIProcessingResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIProcessingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIProcessingResultAggregateArgs>(args: Subset<T, AIProcessingResultAggregateArgs>): Prisma.PrismaPromise<GetAIProcessingResultAggregateType<T>>

    /**
     * Group by AIProcessingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProcessingResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIProcessingResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIProcessingResultGroupByArgs['orderBy'] }
        : { orderBy?: AIProcessingResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIProcessingResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIProcessingResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIProcessingResult model
   */
  readonly fields: AIProcessingResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIProcessingResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIProcessingResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIProcessingResult model
   */ 
  interface AIProcessingResultFieldRefs {
    readonly id: FieldRef<"AIProcessingResult", 'String'>
    readonly documentId: FieldRef<"AIProcessingResult", 'String'>
    readonly model: FieldRef<"AIProcessingResult", 'String'>
    readonly tokens: FieldRef<"AIProcessingResult", 'Int'>
    readonly processingTime: FieldRef<"AIProcessingResult", 'Int'>
    readonly result: FieldRef<"AIProcessingResult", 'Json'>
    readonly error: FieldRef<"AIProcessingResult", 'String'>
    readonly createdAt: FieldRef<"AIProcessingResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIProcessingResult findUnique
   */
  export type AIProcessingResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter, which AIProcessingResult to fetch.
     */
    where: AIProcessingResultWhereUniqueInput
  }

  /**
   * AIProcessingResult findUniqueOrThrow
   */
  export type AIProcessingResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter, which AIProcessingResult to fetch.
     */
    where: AIProcessingResultWhereUniqueInput
  }

  /**
   * AIProcessingResult findFirst
   */
  export type AIProcessingResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter, which AIProcessingResult to fetch.
     */
    where?: AIProcessingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProcessingResults to fetch.
     */
    orderBy?: AIProcessingResultOrderByWithRelationInput | AIProcessingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProcessingResults.
     */
    cursor?: AIProcessingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProcessingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProcessingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProcessingResults.
     */
    distinct?: AIProcessingResultScalarFieldEnum | AIProcessingResultScalarFieldEnum[]
  }

  /**
   * AIProcessingResult findFirstOrThrow
   */
  export type AIProcessingResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter, which AIProcessingResult to fetch.
     */
    where?: AIProcessingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProcessingResults to fetch.
     */
    orderBy?: AIProcessingResultOrderByWithRelationInput | AIProcessingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProcessingResults.
     */
    cursor?: AIProcessingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProcessingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProcessingResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProcessingResults.
     */
    distinct?: AIProcessingResultScalarFieldEnum | AIProcessingResultScalarFieldEnum[]
  }

  /**
   * AIProcessingResult findMany
   */
  export type AIProcessingResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter, which AIProcessingResults to fetch.
     */
    where?: AIProcessingResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProcessingResults to fetch.
     */
    orderBy?: AIProcessingResultOrderByWithRelationInput | AIProcessingResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIProcessingResults.
     */
    cursor?: AIProcessingResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProcessingResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProcessingResults.
     */
    skip?: number
    distinct?: AIProcessingResultScalarFieldEnum | AIProcessingResultScalarFieldEnum[]
  }

  /**
   * AIProcessingResult create
   */
  export type AIProcessingResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * The data needed to create a AIProcessingResult.
     */
    data: XOR<AIProcessingResultCreateInput, AIProcessingResultUncheckedCreateInput>
  }

  /**
   * AIProcessingResult createMany
   */
  export type AIProcessingResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIProcessingResults.
     */
    data: AIProcessingResultCreateManyInput | AIProcessingResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProcessingResult createManyAndReturn
   */
  export type AIProcessingResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AIProcessingResults.
     */
    data: AIProcessingResultCreateManyInput | AIProcessingResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIProcessingResult update
   */
  export type AIProcessingResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * The data needed to update a AIProcessingResult.
     */
    data: XOR<AIProcessingResultUpdateInput, AIProcessingResultUncheckedUpdateInput>
    /**
     * Choose, which AIProcessingResult to update.
     */
    where: AIProcessingResultWhereUniqueInput
  }

  /**
   * AIProcessingResult updateMany
   */
  export type AIProcessingResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIProcessingResults.
     */
    data: XOR<AIProcessingResultUpdateManyMutationInput, AIProcessingResultUncheckedUpdateManyInput>
    /**
     * Filter which AIProcessingResults to update
     */
    where?: AIProcessingResultWhereInput
  }

  /**
   * AIProcessingResult upsert
   */
  export type AIProcessingResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * The filter to search for the AIProcessingResult to update in case it exists.
     */
    where: AIProcessingResultWhereUniqueInput
    /**
     * In case the AIProcessingResult found by the `where` argument doesn't exist, create a new AIProcessingResult with this data.
     */
    create: XOR<AIProcessingResultCreateInput, AIProcessingResultUncheckedCreateInput>
    /**
     * In case the AIProcessingResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIProcessingResultUpdateInput, AIProcessingResultUncheckedUpdateInput>
  }

  /**
   * AIProcessingResult delete
   */
  export type AIProcessingResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
    /**
     * Filter which AIProcessingResult to delete.
     */
    where: AIProcessingResultWhereUniqueInput
  }

  /**
   * AIProcessingResult deleteMany
   */
  export type AIProcessingResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProcessingResults to delete
     */
    where?: AIProcessingResultWhereInput
  }

  /**
   * AIProcessingResult without action
   */
  export type AIProcessingResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProcessingResult
     */
    select?: AIProcessingResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProcessingResultInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    message: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    message: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    level: number
    message: number
    metadata: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    level?: true
    message?: true
    userId?: true
    createdAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    level?: true
    message?: true
    userId?: true
    createdAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    level?: true
    message?: true
    metadata?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    level: $Enums.LogLevel
    message: string
    metadata: JsonValue | null
    userId: string | null
    createdAt: Date
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: $Enums.LogLevel
      message: string
      metadata: Prisma.JsonValue | null
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly level: FieldRef<"Log", 'LogLevel'>
    readonly message: FieldRef<"Log", 'String'>
    readonly metadata: FieldRef<"Log", 'Json'>
    readonly userId: FieldRef<"Log", 'String'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model CacheEntry
   */

  export type AggregateCacheEntry = {
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  export type CacheEntryMinAggregateOutputType = {
    key: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type CacheEntryMaxAggregateOutputType = {
    key: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type CacheEntryCountAggregateOutputType = {
    key: number
    value: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type CacheEntryMinAggregateInputType = {
    key?: true
    value?: true
    expiresAt?: true
    createdAt?: true
  }

  export type CacheEntryMaxAggregateInputType = {
    key?: true
    value?: true
    expiresAt?: true
    createdAt?: true
  }

  export type CacheEntryCountAggregateInputType = {
    key?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type CacheEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntry to aggregate.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CacheEntries
    **/
    _count?: true | CacheEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheEntryMaxAggregateInputType
  }

  export type GetCacheEntryAggregateType<T extends CacheEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCacheEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCacheEntry[P]>
      : GetScalarType<T[P], AggregateCacheEntry[P]>
  }




  export type CacheEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CacheEntryWhereInput
    orderBy?: CacheEntryOrderByWithAggregationInput | CacheEntryOrderByWithAggregationInput[]
    by: CacheEntryScalarFieldEnum[] | CacheEntryScalarFieldEnum
    having?: CacheEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheEntryCountAggregateInputType | true
    _min?: CacheEntryMinAggregateInputType
    _max?: CacheEntryMaxAggregateInputType
  }

  export type CacheEntryGroupByOutputType = {
    key: string
    value: string
    expiresAt: Date
    createdAt: Date
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  type GetCacheEntryGroupByPayload<T extends CacheEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
        }
      >
    >


  export type CacheEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectScalar = {
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $CacheEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CacheEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["cacheEntry"]>
    composites: {}
  }

  type CacheEntryGetPayload<S extends boolean | null | undefined | CacheEntryDefaultArgs> = $Result.GetResult<Prisma.$CacheEntryPayload, S>

  type CacheEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CacheEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CacheEntryCountAggregateInputType | true
    }

  export interface CacheEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CacheEntry'], meta: { name: 'CacheEntry' } }
    /**
     * Find zero or one CacheEntry that matches the filter.
     * @param {CacheEntryFindUniqueArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CacheEntryFindUniqueArgs>(args: SelectSubset<T, CacheEntryFindUniqueArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CacheEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CacheEntryFindUniqueOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CacheEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CacheEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CacheEntryFindFirstArgs>(args?: SelectSubset<T, CacheEntryFindFirstArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CacheEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CacheEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CacheEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany()
     * 
     * // Get first 10 CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cacheEntryWithKeyOnly = await prisma.cacheEntry.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends CacheEntryFindManyArgs>(args?: SelectSubset<T, CacheEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CacheEntry.
     * @param {CacheEntryCreateArgs} args - Arguments to create a CacheEntry.
     * @example
     * // Create one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.create({
     *   data: {
     *     // ... data to create a CacheEntry
     *   }
     * })
     * 
     */
    create<T extends CacheEntryCreateArgs>(args: SelectSubset<T, CacheEntryCreateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CacheEntries.
     * @param {CacheEntryCreateManyArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CacheEntryCreateManyArgs>(args?: SelectSubset<T, CacheEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CacheEntries and returns the data saved in the database.
     * @param {CacheEntryCreateManyAndReturnArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CacheEntries and only return the `key`
     * const cacheEntryWithKeyOnly = await prisma.cacheEntry.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CacheEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CacheEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CacheEntry.
     * @param {CacheEntryDeleteArgs} args - Arguments to delete one CacheEntry.
     * @example
     * // Delete one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.delete({
     *   where: {
     *     // ... filter to delete one CacheEntry
     *   }
     * })
     * 
     */
    delete<T extends CacheEntryDeleteArgs>(args: SelectSubset<T, CacheEntryDeleteArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CacheEntry.
     * @param {CacheEntryUpdateArgs} args - Arguments to update one CacheEntry.
     * @example
     * // Update one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CacheEntryUpdateArgs>(args: SelectSubset<T, CacheEntryUpdateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CacheEntries.
     * @param {CacheEntryDeleteManyArgs} args - Arguments to filter CacheEntries to delete.
     * @example
     * // Delete a few CacheEntries
     * const { count } = await prisma.cacheEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CacheEntryDeleteManyArgs>(args?: SelectSubset<T, CacheEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CacheEntryUpdateManyArgs>(args: SelectSubset<T, CacheEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CacheEntry.
     * @param {CacheEntryUpsertArgs} args - Arguments to update or create a CacheEntry.
     * @example
     * // Update or create a CacheEntry
     * const cacheEntry = await prisma.cacheEntry.upsert({
     *   create: {
     *     // ... data to create a CacheEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CacheEntry we want to update
     *   }
     * })
     */
    upsert<T extends CacheEntryUpsertArgs>(args: SelectSubset<T, CacheEntryUpsertArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryCountArgs} args - Arguments to filter CacheEntries to count.
     * @example
     * // Count the number of CacheEntries
     * const count = await prisma.cacheEntry.count({
     *   where: {
     *     // ... the filter for the CacheEntries we want to count
     *   }
     * })
    **/
    count<T extends CacheEntryCountArgs>(
      args?: Subset<T, CacheEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheEntryAggregateArgs>(args: Subset<T, CacheEntryAggregateArgs>): Prisma.PrismaPromise<GetCacheEntryAggregateType<T>>

    /**
     * Group by CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CacheEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CacheEntryGroupByArgs['orderBy'] }
        : { orderBy?: CacheEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CacheEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CacheEntry model
   */
  readonly fields: CacheEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CacheEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CacheEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CacheEntry model
   */ 
  interface CacheEntryFieldRefs {
    readonly key: FieldRef<"CacheEntry", 'String'>
    readonly value: FieldRef<"CacheEntry", 'String'>
    readonly expiresAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly createdAt: FieldRef<"CacheEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CacheEntry findUnique
   */
  export type CacheEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findUniqueOrThrow
   */
  export type CacheEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findFirst
   */
  export type CacheEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findFirstOrThrow
   */
  export type CacheEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findMany
   */
  export type CacheEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter, which CacheEntries to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry create
   */
  export type CacheEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The data needed to create a CacheEntry.
     */
    data: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
  }

  /**
   * CacheEntry createMany
   */
  export type CacheEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CacheEntry createManyAndReturn
   */
  export type CacheEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CacheEntry update
   */
  export type CacheEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The data needed to update a CacheEntry.
     */
    data: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
    /**
     * Choose, which CacheEntry to update.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry updateMany
   */
  export type CacheEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CacheEntries.
     */
    data: XOR<CacheEntryUpdateManyMutationInput, CacheEntryUncheckedUpdateManyInput>
    /**
     * Filter which CacheEntries to update
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry upsert
   */
  export type CacheEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * The filter to search for the CacheEntry to update in case it exists.
     */
    where: CacheEntryWhereUniqueInput
    /**
     * In case the CacheEntry found by the `where` argument doesn't exist, create a new CacheEntry with this data.
     */
    create: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
    /**
     * In case the CacheEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
  }

  /**
   * CacheEntry delete
   */
  export type CacheEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Filter which CacheEntry to delete.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry deleteMany
   */
  export type CacheEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntries to delete
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry without action
   */
  export type CacheEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
  }


  /**
   * Model SpedContribuicoesItem
   */

  export type AggregateSpedContribuicoesItem = {
    _count: SpedContribuicoesItemCountAggregateOutputType | null
    _avg: SpedContribuicoesItemAvgAggregateOutputType | null
    _sum: SpedContribuicoesItemSumAggregateOutputType | null
    _min: SpedContribuicoesItemMinAggregateOutputType | null
    _max: SpedContribuicoesItemMaxAggregateOutputType | null
  }

  export type SpedContribuicoesItemAvgAggregateOutputType = {
    valor: number | null
    basePis: number | null
    valorPis: number | null
    baseCofins: number | null
    valorCofins: number | null
  }

  export type SpedContribuicoesItemSumAggregateOutputType = {
    valor: number | null
    basePis: number | null
    valorPis: number | null
    baseCofins: number | null
    valorCofins: number | null
  }

  export type SpedContribuicoesItemMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    documento: string | null
    data: string | null
    cnpj: string | null
    produto: string | null
    cfop: string | null
    cst: string | null
    valor: number | null
    basePis: number | null
    valorPis: number | null
    baseCofins: number | null
    valorCofins: number | null
    createdAt: Date | null
  }

  export type SpedContribuicoesItemMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    documento: string | null
    data: string | null
    cnpj: string | null
    produto: string | null
    cfop: string | null
    cst: string | null
    valor: number | null
    basePis: number | null
    valorPis: number | null
    baseCofins: number | null
    valorCofins: number | null
    createdAt: Date | null
  }

  export type SpedContribuicoesItemCountAggregateOutputType = {
    id: number
    documentId: number
    empresaId: number
    documento: number
    data: number
    cnpj: number
    produto: number
    cfop: number
    cst: number
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt: number
    _all: number
  }


  export type SpedContribuicoesItemAvgAggregateInputType = {
    valor?: true
    basePis?: true
    valorPis?: true
    baseCofins?: true
    valorCofins?: true
  }

  export type SpedContribuicoesItemSumAggregateInputType = {
    valor?: true
    basePis?: true
    valorPis?: true
    baseCofins?: true
    valorCofins?: true
  }

  export type SpedContribuicoesItemMinAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    valor?: true
    basePis?: true
    valorPis?: true
    baseCofins?: true
    valorCofins?: true
    createdAt?: true
  }

  export type SpedContribuicoesItemMaxAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    valor?: true
    basePis?: true
    valorPis?: true
    baseCofins?: true
    valorCofins?: true
    createdAt?: true
  }

  export type SpedContribuicoesItemCountAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    valor?: true
    basePis?: true
    valorPis?: true
    baseCofins?: true
    valorCofins?: true
    createdAt?: true
    _all?: true
  }

  export type SpedContribuicoesItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedContribuicoesItem to aggregate.
     */
    where?: SpedContribuicoesItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesItems to fetch.
     */
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpedContribuicoesItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpedContribuicoesItems
    **/
    _count?: true | SpedContribuicoesItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpedContribuicoesItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpedContribuicoesItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpedContribuicoesItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpedContribuicoesItemMaxAggregateInputType
  }

  export type GetSpedContribuicoesItemAggregateType<T extends SpedContribuicoesItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSpedContribuicoesItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpedContribuicoesItem[P]>
      : GetScalarType<T[P], AggregateSpedContribuicoesItem[P]>
  }




  export type SpedContribuicoesItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesItemWhereInput
    orderBy?: SpedContribuicoesItemOrderByWithAggregationInput | SpedContribuicoesItemOrderByWithAggregationInput[]
    by: SpedContribuicoesItemScalarFieldEnum[] | SpedContribuicoesItemScalarFieldEnum
    having?: SpedContribuicoesItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpedContribuicoesItemCountAggregateInputType | true
    _avg?: SpedContribuicoesItemAvgAggregateInputType
    _sum?: SpedContribuicoesItemSumAggregateInputType
    _min?: SpedContribuicoesItemMinAggregateInputType
    _max?: SpedContribuicoesItemMaxAggregateInputType
  }

  export type SpedContribuicoesItemGroupByOutputType = {
    id: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt: Date
    _count: SpedContribuicoesItemCountAggregateOutputType | null
    _avg: SpedContribuicoesItemAvgAggregateOutputType | null
    _sum: SpedContribuicoesItemSumAggregateOutputType | null
    _min: SpedContribuicoesItemMinAggregateOutputType | null
    _max: SpedContribuicoesItemMaxAggregateOutputType | null
  }

  type GetSpedContribuicoesItemGroupByPayload<T extends SpedContribuicoesItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpedContribuicoesItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpedContribuicoesItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpedContribuicoesItemGroupByOutputType[P]>
            : GetScalarType<T[P], SpedContribuicoesItemGroupByOutputType[P]>
        }
      >
    >


  export type SpedContribuicoesItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    valor?: boolean
    basePis?: boolean
    valorPis?: boolean
    baseCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedContribuicoesItem"]>

  export type SpedContribuicoesItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    valor?: boolean
    basePis?: boolean
    valorPis?: boolean
    baseCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedContribuicoesItem"]>

  export type SpedContribuicoesItemSelectScalar = {
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    valor?: boolean
    basePis?: boolean
    valorPis?: boolean
    baseCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
  }

  export type SpedContribuicoesItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type SpedContribuicoesItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $SpedContribuicoesItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpedContribuicoesItem"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      empresaId: string
      documento: string
      data: string
      cnpj: string
      produto: string
      cfop: string
      cst: string
      valor: number
      basePis: number
      valorPis: number
      baseCofins: number
      valorCofins: number
      createdAt: Date
    }, ExtArgs["result"]["spedContribuicoesItem"]>
    composites: {}
  }

  type SpedContribuicoesItemGetPayload<S extends boolean | null | undefined | SpedContribuicoesItemDefaultArgs> = $Result.GetResult<Prisma.$SpedContribuicoesItemPayload, S>

  type SpedContribuicoesItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpedContribuicoesItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpedContribuicoesItemCountAggregateInputType | true
    }

  export interface SpedContribuicoesItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpedContribuicoesItem'], meta: { name: 'SpedContribuicoesItem' } }
    /**
     * Find zero or one SpedContribuicoesItem that matches the filter.
     * @param {SpedContribuicoesItemFindUniqueArgs} args - Arguments to find a SpedContribuicoesItem
     * @example
     * // Get one SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpedContribuicoesItemFindUniqueArgs>(args: SelectSubset<T, SpedContribuicoesItemFindUniqueArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpedContribuicoesItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpedContribuicoesItemFindUniqueOrThrowArgs} args - Arguments to find a SpedContribuicoesItem
     * @example
     * // Get one SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpedContribuicoesItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SpedContribuicoesItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpedContribuicoesItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemFindFirstArgs} args - Arguments to find a SpedContribuicoesItem
     * @example
     * // Get one SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpedContribuicoesItemFindFirstArgs>(args?: SelectSubset<T, SpedContribuicoesItemFindFirstArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpedContribuicoesItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemFindFirstOrThrowArgs} args - Arguments to find a SpedContribuicoesItem
     * @example
     * // Get one SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpedContribuicoesItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SpedContribuicoesItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpedContribuicoesItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpedContribuicoesItems
     * const spedContribuicoesItems = await prisma.spedContribuicoesItem.findMany()
     * 
     * // Get first 10 SpedContribuicoesItems
     * const spedContribuicoesItems = await prisma.spedContribuicoesItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spedContribuicoesItemWithIdOnly = await prisma.spedContribuicoesItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpedContribuicoesItemFindManyArgs>(args?: SelectSubset<T, SpedContribuicoesItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpedContribuicoesItem.
     * @param {SpedContribuicoesItemCreateArgs} args - Arguments to create a SpedContribuicoesItem.
     * @example
     * // Create one SpedContribuicoesItem
     * const SpedContribuicoesItem = await prisma.spedContribuicoesItem.create({
     *   data: {
     *     // ... data to create a SpedContribuicoesItem
     *   }
     * })
     * 
     */
    create<T extends SpedContribuicoesItemCreateArgs>(args: SelectSubset<T, SpedContribuicoesItemCreateArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpedContribuicoesItems.
     * @param {SpedContribuicoesItemCreateManyArgs} args - Arguments to create many SpedContribuicoesItems.
     * @example
     * // Create many SpedContribuicoesItems
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpedContribuicoesItemCreateManyArgs>(args?: SelectSubset<T, SpedContribuicoesItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpedContribuicoesItems and returns the data saved in the database.
     * @param {SpedContribuicoesItemCreateManyAndReturnArgs} args - Arguments to create many SpedContribuicoesItems.
     * @example
     * // Create many SpedContribuicoesItems
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpedContribuicoesItems and only return the `id`
     * const spedContribuicoesItemWithIdOnly = await prisma.spedContribuicoesItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpedContribuicoesItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SpedContribuicoesItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpedContribuicoesItem.
     * @param {SpedContribuicoesItemDeleteArgs} args - Arguments to delete one SpedContribuicoesItem.
     * @example
     * // Delete one SpedContribuicoesItem
     * const SpedContribuicoesItem = await prisma.spedContribuicoesItem.delete({
     *   where: {
     *     // ... filter to delete one SpedContribuicoesItem
     *   }
     * })
     * 
     */
    delete<T extends SpedContribuicoesItemDeleteArgs>(args: SelectSubset<T, SpedContribuicoesItemDeleteArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpedContribuicoesItem.
     * @param {SpedContribuicoesItemUpdateArgs} args - Arguments to update one SpedContribuicoesItem.
     * @example
     * // Update one SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpedContribuicoesItemUpdateArgs>(args: SelectSubset<T, SpedContribuicoesItemUpdateArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpedContribuicoesItems.
     * @param {SpedContribuicoesItemDeleteManyArgs} args - Arguments to filter SpedContribuicoesItems to delete.
     * @example
     * // Delete a few SpedContribuicoesItems
     * const { count } = await prisma.spedContribuicoesItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpedContribuicoesItemDeleteManyArgs>(args?: SelectSubset<T, SpedContribuicoesItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpedContribuicoesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpedContribuicoesItems
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpedContribuicoesItemUpdateManyArgs>(args: SelectSubset<T, SpedContribuicoesItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpedContribuicoesItem.
     * @param {SpedContribuicoesItemUpsertArgs} args - Arguments to update or create a SpedContribuicoesItem.
     * @example
     * // Update or create a SpedContribuicoesItem
     * const spedContribuicoesItem = await prisma.spedContribuicoesItem.upsert({
     *   create: {
     *     // ... data to create a SpedContribuicoesItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpedContribuicoesItem we want to update
     *   }
     * })
     */
    upsert<T extends SpedContribuicoesItemUpsertArgs>(args: SelectSubset<T, SpedContribuicoesItemUpsertArgs<ExtArgs>>): Prisma__SpedContribuicoesItemClient<$Result.GetResult<Prisma.$SpedContribuicoesItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpedContribuicoesItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemCountArgs} args - Arguments to filter SpedContribuicoesItems to count.
     * @example
     * // Count the number of SpedContribuicoesItems
     * const count = await prisma.spedContribuicoesItem.count({
     *   where: {
     *     // ... the filter for the SpedContribuicoesItems we want to count
     *   }
     * })
    **/
    count<T extends SpedContribuicoesItemCountArgs>(
      args?: Subset<T, SpedContribuicoesItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpedContribuicoesItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpedContribuicoesItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpedContribuicoesItemAggregateArgs>(args: Subset<T, SpedContribuicoesItemAggregateArgs>): Prisma.PrismaPromise<GetSpedContribuicoesItemAggregateType<T>>

    /**
     * Group by SpedContribuicoesItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpedContribuicoesItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpedContribuicoesItemGroupByArgs['orderBy'] }
        : { orderBy?: SpedContribuicoesItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpedContribuicoesItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpedContribuicoesItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpedContribuicoesItem model
   */
  readonly fields: SpedContribuicoesItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpedContribuicoesItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpedContribuicoesItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpedContribuicoesItem model
   */ 
  interface SpedContribuicoesItemFieldRefs {
    readonly id: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly documentId: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly empresaId: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly documento: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly data: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly cnpj: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly produto: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly cfop: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly cst: FieldRef<"SpedContribuicoesItem", 'String'>
    readonly valor: FieldRef<"SpedContribuicoesItem", 'Float'>
    readonly basePis: FieldRef<"SpedContribuicoesItem", 'Float'>
    readonly valorPis: FieldRef<"SpedContribuicoesItem", 'Float'>
    readonly baseCofins: FieldRef<"SpedContribuicoesItem", 'Float'>
    readonly valorCofins: FieldRef<"SpedContribuicoesItem", 'Float'>
    readonly createdAt: FieldRef<"SpedContribuicoesItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpedContribuicoesItem findUnique
   */
  export type SpedContribuicoesItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesItem to fetch.
     */
    where: SpedContribuicoesItemWhereUniqueInput
  }

  /**
   * SpedContribuicoesItem findUniqueOrThrow
   */
  export type SpedContribuicoesItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesItem to fetch.
     */
    where: SpedContribuicoesItemWhereUniqueInput
  }

  /**
   * SpedContribuicoesItem findFirst
   */
  export type SpedContribuicoesItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesItem to fetch.
     */
    where?: SpedContribuicoesItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesItems to fetch.
     */
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedContribuicoesItems.
     */
    cursor?: SpedContribuicoesItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedContribuicoesItems.
     */
    distinct?: SpedContribuicoesItemScalarFieldEnum | SpedContribuicoesItemScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesItem findFirstOrThrow
   */
  export type SpedContribuicoesItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesItem to fetch.
     */
    where?: SpedContribuicoesItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesItems to fetch.
     */
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedContribuicoesItems.
     */
    cursor?: SpedContribuicoesItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedContribuicoesItems.
     */
    distinct?: SpedContribuicoesItemScalarFieldEnum | SpedContribuicoesItemScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesItem findMany
   */
  export type SpedContribuicoesItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesItems to fetch.
     */
    where?: SpedContribuicoesItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesItems to fetch.
     */
    orderBy?: SpedContribuicoesItemOrderByWithRelationInput | SpedContribuicoesItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpedContribuicoesItems.
     */
    cursor?: SpedContribuicoesItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesItems.
     */
    skip?: number
    distinct?: SpedContribuicoesItemScalarFieldEnum | SpedContribuicoesItemScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesItem create
   */
  export type SpedContribuicoesItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SpedContribuicoesItem.
     */
    data: XOR<SpedContribuicoesItemCreateInput, SpedContribuicoesItemUncheckedCreateInput>
  }

  /**
   * SpedContribuicoesItem createMany
   */
  export type SpedContribuicoesItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpedContribuicoesItems.
     */
    data: SpedContribuicoesItemCreateManyInput | SpedContribuicoesItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpedContribuicoesItem createManyAndReturn
   */
  export type SpedContribuicoesItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpedContribuicoesItems.
     */
    data: SpedContribuicoesItemCreateManyInput | SpedContribuicoesItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpedContribuicoesItem update
   */
  export type SpedContribuicoesItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SpedContribuicoesItem.
     */
    data: XOR<SpedContribuicoesItemUpdateInput, SpedContribuicoesItemUncheckedUpdateInput>
    /**
     * Choose, which SpedContribuicoesItem to update.
     */
    where: SpedContribuicoesItemWhereUniqueInput
  }

  /**
   * SpedContribuicoesItem updateMany
   */
  export type SpedContribuicoesItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpedContribuicoesItems.
     */
    data: XOR<SpedContribuicoesItemUpdateManyMutationInput, SpedContribuicoesItemUncheckedUpdateManyInput>
    /**
     * Filter which SpedContribuicoesItems to update
     */
    where?: SpedContribuicoesItemWhereInput
  }

  /**
   * SpedContribuicoesItem upsert
   */
  export type SpedContribuicoesItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SpedContribuicoesItem to update in case it exists.
     */
    where: SpedContribuicoesItemWhereUniqueInput
    /**
     * In case the SpedContribuicoesItem found by the `where` argument doesn't exist, create a new SpedContribuicoesItem with this data.
     */
    create: XOR<SpedContribuicoesItemCreateInput, SpedContribuicoesItemUncheckedCreateInput>
    /**
     * In case the SpedContribuicoesItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpedContribuicoesItemUpdateInput, SpedContribuicoesItemUncheckedUpdateInput>
  }

  /**
   * SpedContribuicoesItem delete
   */
  export type SpedContribuicoesItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
    /**
     * Filter which SpedContribuicoesItem to delete.
     */
    where: SpedContribuicoesItemWhereUniqueInput
  }

  /**
   * SpedContribuicoesItem deleteMany
   */
  export type SpedContribuicoesItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedContribuicoesItems to delete
     */
    where?: SpedContribuicoesItemWhereInput
  }

  /**
   * SpedContribuicoesItem without action
   */
  export type SpedContribuicoesItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesItem
     */
    select?: SpedContribuicoesItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesItemInclude<ExtArgs> | null
  }


  /**
   * Model SpedContribuicoesApuracao
   */

  export type AggregateSpedContribuicoesApuracao = {
    _count: SpedContribuicoesApuracaoCountAggregateOutputType | null
    _avg: SpedContribuicoesApuracaoAvgAggregateOutputType | null
    _sum: SpedContribuicoesApuracaoSumAggregateOutputType | null
    _min: SpedContribuicoesApuracaoMinAggregateOutputType | null
    _max: SpedContribuicoesApuracaoMaxAggregateOutputType | null
  }

  export type SpedContribuicoesApuracaoAvgAggregateOutputType = {
    base: number | null
    aliquota: number | null
    valor: number | null
  }

  export type SpedContribuicoesApuracaoSumAggregateOutputType = {
    base: number | null
    aliquota: number | null
    valor: number | null
  }

  export type SpedContribuicoesApuracaoMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    tipo: string | null
    periodo: string | null
    base: number | null
    aliquota: number | null
    valor: number | null
    createdAt: Date | null
  }

  export type SpedContribuicoesApuracaoMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    tipo: string | null
    periodo: string | null
    base: number | null
    aliquota: number | null
    valor: number | null
    createdAt: Date | null
  }

  export type SpedContribuicoesApuracaoCountAggregateOutputType = {
    id: number
    documentId: number
    empresaId: number
    tipo: number
    periodo: number
    base: number
    aliquota: number
    valor: number
    createdAt: number
    _all: number
  }


  export type SpedContribuicoesApuracaoAvgAggregateInputType = {
    base?: true
    aliquota?: true
    valor?: true
  }

  export type SpedContribuicoesApuracaoSumAggregateInputType = {
    base?: true
    aliquota?: true
    valor?: true
  }

  export type SpedContribuicoesApuracaoMinAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipo?: true
    periodo?: true
    base?: true
    aliquota?: true
    valor?: true
    createdAt?: true
  }

  export type SpedContribuicoesApuracaoMaxAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipo?: true
    periodo?: true
    base?: true
    aliquota?: true
    valor?: true
    createdAt?: true
  }

  export type SpedContribuicoesApuracaoCountAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipo?: true
    periodo?: true
    base?: true
    aliquota?: true
    valor?: true
    createdAt?: true
    _all?: true
  }

  export type SpedContribuicoesApuracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedContribuicoesApuracao to aggregate.
     */
    where?: SpedContribuicoesApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesApuracaos to fetch.
     */
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpedContribuicoesApuracaos
    **/
    _count?: true | SpedContribuicoesApuracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpedContribuicoesApuracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpedContribuicoesApuracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpedContribuicoesApuracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpedContribuicoesApuracaoMaxAggregateInputType
  }

  export type GetSpedContribuicoesApuracaoAggregateType<T extends SpedContribuicoesApuracaoAggregateArgs> = {
        [P in keyof T & keyof AggregateSpedContribuicoesApuracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpedContribuicoesApuracao[P]>
      : GetScalarType<T[P], AggregateSpedContribuicoesApuracao[P]>
  }




  export type SpedContribuicoesApuracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedContribuicoesApuracaoWhereInput
    orderBy?: SpedContribuicoesApuracaoOrderByWithAggregationInput | SpedContribuicoesApuracaoOrderByWithAggregationInput[]
    by: SpedContribuicoesApuracaoScalarFieldEnum[] | SpedContribuicoesApuracaoScalarFieldEnum
    having?: SpedContribuicoesApuracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpedContribuicoesApuracaoCountAggregateInputType | true
    _avg?: SpedContribuicoesApuracaoAvgAggregateInputType
    _sum?: SpedContribuicoesApuracaoSumAggregateInputType
    _min?: SpedContribuicoesApuracaoMinAggregateInputType
    _max?: SpedContribuicoesApuracaoMaxAggregateInputType
  }

  export type SpedContribuicoesApuracaoGroupByOutputType = {
    id: string
    documentId: string
    empresaId: string
    tipo: string
    periodo: string
    base: number | null
    aliquota: number | null
    valor: number
    createdAt: Date
    _count: SpedContribuicoesApuracaoCountAggregateOutputType | null
    _avg: SpedContribuicoesApuracaoAvgAggregateOutputType | null
    _sum: SpedContribuicoesApuracaoSumAggregateOutputType | null
    _min: SpedContribuicoesApuracaoMinAggregateOutputType | null
    _max: SpedContribuicoesApuracaoMaxAggregateOutputType | null
  }

  type GetSpedContribuicoesApuracaoGroupByPayload<T extends SpedContribuicoesApuracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpedContribuicoesApuracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpedContribuicoesApuracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpedContribuicoesApuracaoGroupByOutputType[P]>
            : GetScalarType<T[P], SpedContribuicoesApuracaoGroupByOutputType[P]>
        }
      >
    >


  export type SpedContribuicoesApuracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipo?: boolean
    periodo?: boolean
    base?: boolean
    aliquota?: boolean
    valor?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedContribuicoesApuracao"]>

  export type SpedContribuicoesApuracaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipo?: boolean
    periodo?: boolean
    base?: boolean
    aliquota?: boolean
    valor?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedContribuicoesApuracao"]>

  export type SpedContribuicoesApuracaoSelectScalar = {
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipo?: boolean
    periodo?: boolean
    base?: boolean
    aliquota?: boolean
    valor?: boolean
    createdAt?: boolean
  }

  export type SpedContribuicoesApuracaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type SpedContribuicoesApuracaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $SpedContribuicoesApuracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpedContribuicoesApuracao"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      empresaId: string
      tipo: string
      periodo: string
      base: number | null
      aliquota: number | null
      valor: number
      createdAt: Date
    }, ExtArgs["result"]["spedContribuicoesApuracao"]>
    composites: {}
  }

  type SpedContribuicoesApuracaoGetPayload<S extends boolean | null | undefined | SpedContribuicoesApuracaoDefaultArgs> = $Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload, S>

  type SpedContribuicoesApuracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpedContribuicoesApuracaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpedContribuicoesApuracaoCountAggregateInputType | true
    }

  export interface SpedContribuicoesApuracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpedContribuicoesApuracao'], meta: { name: 'SpedContribuicoesApuracao' } }
    /**
     * Find zero or one SpedContribuicoesApuracao that matches the filter.
     * @param {SpedContribuicoesApuracaoFindUniqueArgs} args - Arguments to find a SpedContribuicoesApuracao
     * @example
     * // Get one SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpedContribuicoesApuracaoFindUniqueArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoFindUniqueArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpedContribuicoesApuracao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpedContribuicoesApuracaoFindUniqueOrThrowArgs} args - Arguments to find a SpedContribuicoesApuracao
     * @example
     * // Get one SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpedContribuicoesApuracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpedContribuicoesApuracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoFindFirstArgs} args - Arguments to find a SpedContribuicoesApuracao
     * @example
     * // Get one SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpedContribuicoesApuracaoFindFirstArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoFindFirstArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpedContribuicoesApuracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoFindFirstOrThrowArgs} args - Arguments to find a SpedContribuicoesApuracao
     * @example
     * // Get one SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpedContribuicoesApuracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpedContribuicoesApuracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpedContribuicoesApuracaos
     * const spedContribuicoesApuracaos = await prisma.spedContribuicoesApuracao.findMany()
     * 
     * // Get first 10 SpedContribuicoesApuracaos
     * const spedContribuicoesApuracaos = await prisma.spedContribuicoesApuracao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spedContribuicoesApuracaoWithIdOnly = await prisma.spedContribuicoesApuracao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpedContribuicoesApuracaoFindManyArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpedContribuicoesApuracao.
     * @param {SpedContribuicoesApuracaoCreateArgs} args - Arguments to create a SpedContribuicoesApuracao.
     * @example
     * // Create one SpedContribuicoesApuracao
     * const SpedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.create({
     *   data: {
     *     // ... data to create a SpedContribuicoesApuracao
     *   }
     * })
     * 
     */
    create<T extends SpedContribuicoesApuracaoCreateArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoCreateArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpedContribuicoesApuracaos.
     * @param {SpedContribuicoesApuracaoCreateManyArgs} args - Arguments to create many SpedContribuicoesApuracaos.
     * @example
     * // Create many SpedContribuicoesApuracaos
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpedContribuicoesApuracaoCreateManyArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpedContribuicoesApuracaos and returns the data saved in the database.
     * @param {SpedContribuicoesApuracaoCreateManyAndReturnArgs} args - Arguments to create many SpedContribuicoesApuracaos.
     * @example
     * // Create many SpedContribuicoesApuracaos
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpedContribuicoesApuracaos and only return the `id`
     * const spedContribuicoesApuracaoWithIdOnly = await prisma.spedContribuicoesApuracao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpedContribuicoesApuracaoCreateManyAndReturnArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpedContribuicoesApuracao.
     * @param {SpedContribuicoesApuracaoDeleteArgs} args - Arguments to delete one SpedContribuicoesApuracao.
     * @example
     * // Delete one SpedContribuicoesApuracao
     * const SpedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.delete({
     *   where: {
     *     // ... filter to delete one SpedContribuicoesApuracao
     *   }
     * })
     * 
     */
    delete<T extends SpedContribuicoesApuracaoDeleteArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoDeleteArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpedContribuicoesApuracao.
     * @param {SpedContribuicoesApuracaoUpdateArgs} args - Arguments to update one SpedContribuicoesApuracao.
     * @example
     * // Update one SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpedContribuicoesApuracaoUpdateArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoUpdateArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpedContribuicoesApuracaos.
     * @param {SpedContribuicoesApuracaoDeleteManyArgs} args - Arguments to filter SpedContribuicoesApuracaos to delete.
     * @example
     * // Delete a few SpedContribuicoesApuracaos
     * const { count } = await prisma.spedContribuicoesApuracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpedContribuicoesApuracaoDeleteManyArgs>(args?: SelectSubset<T, SpedContribuicoesApuracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpedContribuicoesApuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpedContribuicoesApuracaos
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpedContribuicoesApuracaoUpdateManyArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpedContribuicoesApuracao.
     * @param {SpedContribuicoesApuracaoUpsertArgs} args - Arguments to update or create a SpedContribuicoesApuracao.
     * @example
     * // Update or create a SpedContribuicoesApuracao
     * const spedContribuicoesApuracao = await prisma.spedContribuicoesApuracao.upsert({
     *   create: {
     *     // ... data to create a SpedContribuicoesApuracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpedContribuicoesApuracao we want to update
     *   }
     * })
     */
    upsert<T extends SpedContribuicoesApuracaoUpsertArgs>(args: SelectSubset<T, SpedContribuicoesApuracaoUpsertArgs<ExtArgs>>): Prisma__SpedContribuicoesApuracaoClient<$Result.GetResult<Prisma.$SpedContribuicoesApuracaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpedContribuicoesApuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoCountArgs} args - Arguments to filter SpedContribuicoesApuracaos to count.
     * @example
     * // Count the number of SpedContribuicoesApuracaos
     * const count = await prisma.spedContribuicoesApuracao.count({
     *   where: {
     *     // ... the filter for the SpedContribuicoesApuracaos we want to count
     *   }
     * })
    **/
    count<T extends SpedContribuicoesApuracaoCountArgs>(
      args?: Subset<T, SpedContribuicoesApuracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpedContribuicoesApuracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpedContribuicoesApuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpedContribuicoesApuracaoAggregateArgs>(args: Subset<T, SpedContribuicoesApuracaoAggregateArgs>): Prisma.PrismaPromise<GetSpedContribuicoesApuracaoAggregateType<T>>

    /**
     * Group by SpedContribuicoesApuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedContribuicoesApuracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpedContribuicoesApuracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpedContribuicoesApuracaoGroupByArgs['orderBy'] }
        : { orderBy?: SpedContribuicoesApuracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpedContribuicoesApuracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpedContribuicoesApuracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpedContribuicoesApuracao model
   */
  readonly fields: SpedContribuicoesApuracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpedContribuicoesApuracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpedContribuicoesApuracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpedContribuicoesApuracao model
   */ 
  interface SpedContribuicoesApuracaoFieldRefs {
    readonly id: FieldRef<"SpedContribuicoesApuracao", 'String'>
    readonly documentId: FieldRef<"SpedContribuicoesApuracao", 'String'>
    readonly empresaId: FieldRef<"SpedContribuicoesApuracao", 'String'>
    readonly tipo: FieldRef<"SpedContribuicoesApuracao", 'String'>
    readonly periodo: FieldRef<"SpedContribuicoesApuracao", 'String'>
    readonly base: FieldRef<"SpedContribuicoesApuracao", 'Float'>
    readonly aliquota: FieldRef<"SpedContribuicoesApuracao", 'Float'>
    readonly valor: FieldRef<"SpedContribuicoesApuracao", 'Float'>
    readonly createdAt: FieldRef<"SpedContribuicoesApuracao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpedContribuicoesApuracao findUnique
   */
  export type SpedContribuicoesApuracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesApuracao to fetch.
     */
    where: SpedContribuicoesApuracaoWhereUniqueInput
  }

  /**
   * SpedContribuicoesApuracao findUniqueOrThrow
   */
  export type SpedContribuicoesApuracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesApuracao to fetch.
     */
    where: SpedContribuicoesApuracaoWhereUniqueInput
  }

  /**
   * SpedContribuicoesApuracao findFirst
   */
  export type SpedContribuicoesApuracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesApuracao to fetch.
     */
    where?: SpedContribuicoesApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesApuracaos to fetch.
     */
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedContribuicoesApuracaos.
     */
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedContribuicoesApuracaos.
     */
    distinct?: SpedContribuicoesApuracaoScalarFieldEnum | SpedContribuicoesApuracaoScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesApuracao findFirstOrThrow
   */
  export type SpedContribuicoesApuracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesApuracao to fetch.
     */
    where?: SpedContribuicoesApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesApuracaos to fetch.
     */
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedContribuicoesApuracaos.
     */
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedContribuicoesApuracaos.
     */
    distinct?: SpedContribuicoesApuracaoScalarFieldEnum | SpedContribuicoesApuracaoScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesApuracao findMany
   */
  export type SpedContribuicoesApuracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedContribuicoesApuracaos to fetch.
     */
    where?: SpedContribuicoesApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedContribuicoesApuracaos to fetch.
     */
    orderBy?: SpedContribuicoesApuracaoOrderByWithRelationInput | SpedContribuicoesApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpedContribuicoesApuracaos.
     */
    cursor?: SpedContribuicoesApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedContribuicoesApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedContribuicoesApuracaos.
     */
    skip?: number
    distinct?: SpedContribuicoesApuracaoScalarFieldEnum | SpedContribuicoesApuracaoScalarFieldEnum[]
  }

  /**
   * SpedContribuicoesApuracao create
   */
  export type SpedContribuicoesApuracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * The data needed to create a SpedContribuicoesApuracao.
     */
    data: XOR<SpedContribuicoesApuracaoCreateInput, SpedContribuicoesApuracaoUncheckedCreateInput>
  }

  /**
   * SpedContribuicoesApuracao createMany
   */
  export type SpedContribuicoesApuracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpedContribuicoesApuracaos.
     */
    data: SpedContribuicoesApuracaoCreateManyInput | SpedContribuicoesApuracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpedContribuicoesApuracao createManyAndReturn
   */
  export type SpedContribuicoesApuracaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpedContribuicoesApuracaos.
     */
    data: SpedContribuicoesApuracaoCreateManyInput | SpedContribuicoesApuracaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpedContribuicoesApuracao update
   */
  export type SpedContribuicoesApuracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * The data needed to update a SpedContribuicoesApuracao.
     */
    data: XOR<SpedContribuicoesApuracaoUpdateInput, SpedContribuicoesApuracaoUncheckedUpdateInput>
    /**
     * Choose, which SpedContribuicoesApuracao to update.
     */
    where: SpedContribuicoesApuracaoWhereUniqueInput
  }

  /**
   * SpedContribuicoesApuracao updateMany
   */
  export type SpedContribuicoesApuracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpedContribuicoesApuracaos.
     */
    data: XOR<SpedContribuicoesApuracaoUpdateManyMutationInput, SpedContribuicoesApuracaoUncheckedUpdateManyInput>
    /**
     * Filter which SpedContribuicoesApuracaos to update
     */
    where?: SpedContribuicoesApuracaoWhereInput
  }

  /**
   * SpedContribuicoesApuracao upsert
   */
  export type SpedContribuicoesApuracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * The filter to search for the SpedContribuicoesApuracao to update in case it exists.
     */
    where: SpedContribuicoesApuracaoWhereUniqueInput
    /**
     * In case the SpedContribuicoesApuracao found by the `where` argument doesn't exist, create a new SpedContribuicoesApuracao with this data.
     */
    create: XOR<SpedContribuicoesApuracaoCreateInput, SpedContribuicoesApuracaoUncheckedCreateInput>
    /**
     * In case the SpedContribuicoesApuracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpedContribuicoesApuracaoUpdateInput, SpedContribuicoesApuracaoUncheckedUpdateInput>
  }

  /**
   * SpedContribuicoesApuracao delete
   */
  export type SpedContribuicoesApuracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
    /**
     * Filter which SpedContribuicoesApuracao to delete.
     */
    where: SpedContribuicoesApuracaoWhereUniqueInput
  }

  /**
   * SpedContribuicoesApuracao deleteMany
   */
  export type SpedContribuicoesApuracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedContribuicoesApuracaos to delete
     */
    where?: SpedContribuicoesApuracaoWhereInput
  }

  /**
   * SpedContribuicoesApuracao without action
   */
  export type SpedContribuicoesApuracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedContribuicoesApuracao
     */
    select?: SpedContribuicoesApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedContribuicoesApuracaoInclude<ExtArgs> | null
  }


  /**
   * Model SpedFiscalItem
   */

  export type AggregateSpedFiscalItem = {
    _count: SpedFiscalItemCountAggregateOutputType | null
    _avg: SpedFiscalItemAvgAggregateOutputType | null
    _sum: SpedFiscalItemSumAggregateOutputType | null
    _min: SpedFiscalItemMinAggregateOutputType | null
    _max: SpedFiscalItemMaxAggregateOutputType | null
  }

  export type SpedFiscalItemAvgAggregateOutputType = {
    valor: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIpi: number | null
    valorIpi: number | null
  }

  export type SpedFiscalItemSumAggregateOutputType = {
    valor: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIpi: number | null
    valorIpi: number | null
  }

  export type SpedFiscalItemMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    documento: string | null
    data: string | null
    cnpj: string | null
    produto: string | null
    cfop: string | null
    cst: string | null
    ncm: string | null
    valor: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIpi: number | null
    valorIpi: number | null
    createdAt: Date | null
  }

  export type SpedFiscalItemMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    documento: string | null
    data: string | null
    cnpj: string | null
    produto: string | null
    cfop: string | null
    cst: string | null
    ncm: string | null
    valor: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIpi: number | null
    valorIpi: number | null
    createdAt: Date | null
  }

  export type SpedFiscalItemCountAggregateOutputType = {
    id: number
    documentId: number
    empresaId: number
    documento: number
    data: number
    cnpj: number
    produto: number
    cfop: number
    cst: number
    ncm: number
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt: number
    _all: number
  }


  export type SpedFiscalItemAvgAggregateInputType = {
    valor?: true
    baseIcms?: true
    valorIcms?: true
    baseIpi?: true
    valorIpi?: true
  }

  export type SpedFiscalItemSumAggregateInputType = {
    valor?: true
    baseIcms?: true
    valorIcms?: true
    baseIpi?: true
    valorIpi?: true
  }

  export type SpedFiscalItemMinAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    ncm?: true
    valor?: true
    baseIcms?: true
    valorIcms?: true
    baseIpi?: true
    valorIpi?: true
    createdAt?: true
  }

  export type SpedFiscalItemMaxAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    ncm?: true
    valor?: true
    baseIcms?: true
    valorIcms?: true
    baseIpi?: true
    valorIpi?: true
    createdAt?: true
  }

  export type SpedFiscalItemCountAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    documento?: true
    data?: true
    cnpj?: true
    produto?: true
    cfop?: true
    cst?: true
    ncm?: true
    valor?: true
    baseIcms?: true
    valorIcms?: true
    baseIpi?: true
    valorIpi?: true
    createdAt?: true
    _all?: true
  }

  export type SpedFiscalItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedFiscalItem to aggregate.
     */
    where?: SpedFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalItems to fetch.
     */
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpedFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpedFiscalItems
    **/
    _count?: true | SpedFiscalItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpedFiscalItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpedFiscalItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpedFiscalItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpedFiscalItemMaxAggregateInputType
  }

  export type GetSpedFiscalItemAggregateType<T extends SpedFiscalItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSpedFiscalItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpedFiscalItem[P]>
      : GetScalarType<T[P], AggregateSpedFiscalItem[P]>
  }




  export type SpedFiscalItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalItemWhereInput
    orderBy?: SpedFiscalItemOrderByWithAggregationInput | SpedFiscalItemOrderByWithAggregationInput[]
    by: SpedFiscalItemScalarFieldEnum[] | SpedFiscalItemScalarFieldEnum
    having?: SpedFiscalItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpedFiscalItemCountAggregateInputType | true
    _avg?: SpedFiscalItemAvgAggregateInputType
    _sum?: SpedFiscalItemSumAggregateInputType
    _min?: SpedFiscalItemMinAggregateInputType
    _max?: SpedFiscalItemMaxAggregateInputType
  }

  export type SpedFiscalItemGroupByOutputType = {
    id: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt: Date
    _count: SpedFiscalItemCountAggregateOutputType | null
    _avg: SpedFiscalItemAvgAggregateOutputType | null
    _sum: SpedFiscalItemSumAggregateOutputType | null
    _min: SpedFiscalItemMinAggregateOutputType | null
    _max: SpedFiscalItemMaxAggregateOutputType | null
  }

  type GetSpedFiscalItemGroupByPayload<T extends SpedFiscalItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpedFiscalItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpedFiscalItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpedFiscalItemGroupByOutputType[P]>
            : GetScalarType<T[P], SpedFiscalItemGroupByOutputType[P]>
        }
      >
    >


  export type SpedFiscalItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    ncm?: boolean
    valor?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIpi?: boolean
    valorIpi?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedFiscalItem"]>

  export type SpedFiscalItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    ncm?: boolean
    valor?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIpi?: boolean
    valorIpi?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedFiscalItem"]>

  export type SpedFiscalItemSelectScalar = {
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    documento?: boolean
    data?: boolean
    cnpj?: boolean
    produto?: boolean
    cfop?: boolean
    cst?: boolean
    ncm?: boolean
    valor?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIpi?: boolean
    valorIpi?: boolean
    createdAt?: boolean
  }

  export type SpedFiscalItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type SpedFiscalItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $SpedFiscalItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpedFiscalItem"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      empresaId: string
      documento: string
      data: string
      cnpj: string
      produto: string
      cfop: string
      cst: string
      ncm: string
      valor: number
      baseIcms: number
      valorIcms: number
      baseIpi: number
      valorIpi: number
      createdAt: Date
    }, ExtArgs["result"]["spedFiscalItem"]>
    composites: {}
  }

  type SpedFiscalItemGetPayload<S extends boolean | null | undefined | SpedFiscalItemDefaultArgs> = $Result.GetResult<Prisma.$SpedFiscalItemPayload, S>

  type SpedFiscalItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpedFiscalItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpedFiscalItemCountAggregateInputType | true
    }

  export interface SpedFiscalItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpedFiscalItem'], meta: { name: 'SpedFiscalItem' } }
    /**
     * Find zero or one SpedFiscalItem that matches the filter.
     * @param {SpedFiscalItemFindUniqueArgs} args - Arguments to find a SpedFiscalItem
     * @example
     * // Get one SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpedFiscalItemFindUniqueArgs>(args: SelectSubset<T, SpedFiscalItemFindUniqueArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpedFiscalItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpedFiscalItemFindUniqueOrThrowArgs} args - Arguments to find a SpedFiscalItem
     * @example
     * // Get one SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpedFiscalItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SpedFiscalItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpedFiscalItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemFindFirstArgs} args - Arguments to find a SpedFiscalItem
     * @example
     * // Get one SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpedFiscalItemFindFirstArgs>(args?: SelectSubset<T, SpedFiscalItemFindFirstArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpedFiscalItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemFindFirstOrThrowArgs} args - Arguments to find a SpedFiscalItem
     * @example
     * // Get one SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpedFiscalItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SpedFiscalItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpedFiscalItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpedFiscalItems
     * const spedFiscalItems = await prisma.spedFiscalItem.findMany()
     * 
     * // Get first 10 SpedFiscalItems
     * const spedFiscalItems = await prisma.spedFiscalItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spedFiscalItemWithIdOnly = await prisma.spedFiscalItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpedFiscalItemFindManyArgs>(args?: SelectSubset<T, SpedFiscalItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpedFiscalItem.
     * @param {SpedFiscalItemCreateArgs} args - Arguments to create a SpedFiscalItem.
     * @example
     * // Create one SpedFiscalItem
     * const SpedFiscalItem = await prisma.spedFiscalItem.create({
     *   data: {
     *     // ... data to create a SpedFiscalItem
     *   }
     * })
     * 
     */
    create<T extends SpedFiscalItemCreateArgs>(args: SelectSubset<T, SpedFiscalItemCreateArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpedFiscalItems.
     * @param {SpedFiscalItemCreateManyArgs} args - Arguments to create many SpedFiscalItems.
     * @example
     * // Create many SpedFiscalItems
     * const spedFiscalItem = await prisma.spedFiscalItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpedFiscalItemCreateManyArgs>(args?: SelectSubset<T, SpedFiscalItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpedFiscalItems and returns the data saved in the database.
     * @param {SpedFiscalItemCreateManyAndReturnArgs} args - Arguments to create many SpedFiscalItems.
     * @example
     * // Create many SpedFiscalItems
     * const spedFiscalItem = await prisma.spedFiscalItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpedFiscalItems and only return the `id`
     * const spedFiscalItemWithIdOnly = await prisma.spedFiscalItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpedFiscalItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SpedFiscalItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpedFiscalItem.
     * @param {SpedFiscalItemDeleteArgs} args - Arguments to delete one SpedFiscalItem.
     * @example
     * // Delete one SpedFiscalItem
     * const SpedFiscalItem = await prisma.spedFiscalItem.delete({
     *   where: {
     *     // ... filter to delete one SpedFiscalItem
     *   }
     * })
     * 
     */
    delete<T extends SpedFiscalItemDeleteArgs>(args: SelectSubset<T, SpedFiscalItemDeleteArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpedFiscalItem.
     * @param {SpedFiscalItemUpdateArgs} args - Arguments to update one SpedFiscalItem.
     * @example
     * // Update one SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpedFiscalItemUpdateArgs>(args: SelectSubset<T, SpedFiscalItemUpdateArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpedFiscalItems.
     * @param {SpedFiscalItemDeleteManyArgs} args - Arguments to filter SpedFiscalItems to delete.
     * @example
     * // Delete a few SpedFiscalItems
     * const { count } = await prisma.spedFiscalItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpedFiscalItemDeleteManyArgs>(args?: SelectSubset<T, SpedFiscalItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpedFiscalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpedFiscalItems
     * const spedFiscalItem = await prisma.spedFiscalItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpedFiscalItemUpdateManyArgs>(args: SelectSubset<T, SpedFiscalItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpedFiscalItem.
     * @param {SpedFiscalItemUpsertArgs} args - Arguments to update or create a SpedFiscalItem.
     * @example
     * // Update or create a SpedFiscalItem
     * const spedFiscalItem = await prisma.spedFiscalItem.upsert({
     *   create: {
     *     // ... data to create a SpedFiscalItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpedFiscalItem we want to update
     *   }
     * })
     */
    upsert<T extends SpedFiscalItemUpsertArgs>(args: SelectSubset<T, SpedFiscalItemUpsertArgs<ExtArgs>>): Prisma__SpedFiscalItemClient<$Result.GetResult<Prisma.$SpedFiscalItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpedFiscalItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemCountArgs} args - Arguments to filter SpedFiscalItems to count.
     * @example
     * // Count the number of SpedFiscalItems
     * const count = await prisma.spedFiscalItem.count({
     *   where: {
     *     // ... the filter for the SpedFiscalItems we want to count
     *   }
     * })
    **/
    count<T extends SpedFiscalItemCountArgs>(
      args?: Subset<T, SpedFiscalItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpedFiscalItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpedFiscalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpedFiscalItemAggregateArgs>(args: Subset<T, SpedFiscalItemAggregateArgs>): Prisma.PrismaPromise<GetSpedFiscalItemAggregateType<T>>

    /**
     * Group by SpedFiscalItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpedFiscalItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpedFiscalItemGroupByArgs['orderBy'] }
        : { orderBy?: SpedFiscalItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpedFiscalItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpedFiscalItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpedFiscalItem model
   */
  readonly fields: SpedFiscalItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpedFiscalItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpedFiscalItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpedFiscalItem model
   */ 
  interface SpedFiscalItemFieldRefs {
    readonly id: FieldRef<"SpedFiscalItem", 'String'>
    readonly documentId: FieldRef<"SpedFiscalItem", 'String'>
    readonly empresaId: FieldRef<"SpedFiscalItem", 'String'>
    readonly documento: FieldRef<"SpedFiscalItem", 'String'>
    readonly data: FieldRef<"SpedFiscalItem", 'String'>
    readonly cnpj: FieldRef<"SpedFiscalItem", 'String'>
    readonly produto: FieldRef<"SpedFiscalItem", 'String'>
    readonly cfop: FieldRef<"SpedFiscalItem", 'String'>
    readonly cst: FieldRef<"SpedFiscalItem", 'String'>
    readonly ncm: FieldRef<"SpedFiscalItem", 'String'>
    readonly valor: FieldRef<"SpedFiscalItem", 'Float'>
    readonly baseIcms: FieldRef<"SpedFiscalItem", 'Float'>
    readonly valorIcms: FieldRef<"SpedFiscalItem", 'Float'>
    readonly baseIpi: FieldRef<"SpedFiscalItem", 'Float'>
    readonly valorIpi: FieldRef<"SpedFiscalItem", 'Float'>
    readonly createdAt: FieldRef<"SpedFiscalItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpedFiscalItem findUnique
   */
  export type SpedFiscalItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalItem to fetch.
     */
    where: SpedFiscalItemWhereUniqueInput
  }

  /**
   * SpedFiscalItem findUniqueOrThrow
   */
  export type SpedFiscalItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalItem to fetch.
     */
    where: SpedFiscalItemWhereUniqueInput
  }

  /**
   * SpedFiscalItem findFirst
   */
  export type SpedFiscalItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalItem to fetch.
     */
    where?: SpedFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalItems to fetch.
     */
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedFiscalItems.
     */
    cursor?: SpedFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedFiscalItems.
     */
    distinct?: SpedFiscalItemScalarFieldEnum | SpedFiscalItemScalarFieldEnum[]
  }

  /**
   * SpedFiscalItem findFirstOrThrow
   */
  export type SpedFiscalItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalItem to fetch.
     */
    where?: SpedFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalItems to fetch.
     */
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedFiscalItems.
     */
    cursor?: SpedFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedFiscalItems.
     */
    distinct?: SpedFiscalItemScalarFieldEnum | SpedFiscalItemScalarFieldEnum[]
  }

  /**
   * SpedFiscalItem findMany
   */
  export type SpedFiscalItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalItems to fetch.
     */
    where?: SpedFiscalItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalItems to fetch.
     */
    orderBy?: SpedFiscalItemOrderByWithRelationInput | SpedFiscalItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpedFiscalItems.
     */
    cursor?: SpedFiscalItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalItems.
     */
    skip?: number
    distinct?: SpedFiscalItemScalarFieldEnum | SpedFiscalItemScalarFieldEnum[]
  }

  /**
   * SpedFiscalItem create
   */
  export type SpedFiscalItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SpedFiscalItem.
     */
    data: XOR<SpedFiscalItemCreateInput, SpedFiscalItemUncheckedCreateInput>
  }

  /**
   * SpedFiscalItem createMany
   */
  export type SpedFiscalItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpedFiscalItems.
     */
    data: SpedFiscalItemCreateManyInput | SpedFiscalItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpedFiscalItem createManyAndReturn
   */
  export type SpedFiscalItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpedFiscalItems.
     */
    data: SpedFiscalItemCreateManyInput | SpedFiscalItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpedFiscalItem update
   */
  export type SpedFiscalItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SpedFiscalItem.
     */
    data: XOR<SpedFiscalItemUpdateInput, SpedFiscalItemUncheckedUpdateInput>
    /**
     * Choose, which SpedFiscalItem to update.
     */
    where: SpedFiscalItemWhereUniqueInput
  }

  /**
   * SpedFiscalItem updateMany
   */
  export type SpedFiscalItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpedFiscalItems.
     */
    data: XOR<SpedFiscalItemUpdateManyMutationInput, SpedFiscalItemUncheckedUpdateManyInput>
    /**
     * Filter which SpedFiscalItems to update
     */
    where?: SpedFiscalItemWhereInput
  }

  /**
   * SpedFiscalItem upsert
   */
  export type SpedFiscalItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SpedFiscalItem to update in case it exists.
     */
    where: SpedFiscalItemWhereUniqueInput
    /**
     * In case the SpedFiscalItem found by the `where` argument doesn't exist, create a new SpedFiscalItem with this data.
     */
    create: XOR<SpedFiscalItemCreateInput, SpedFiscalItemUncheckedCreateInput>
    /**
     * In case the SpedFiscalItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpedFiscalItemUpdateInput, SpedFiscalItemUncheckedUpdateInput>
  }

  /**
   * SpedFiscalItem delete
   */
  export type SpedFiscalItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
    /**
     * Filter which SpedFiscalItem to delete.
     */
    where: SpedFiscalItemWhereUniqueInput
  }

  /**
   * SpedFiscalItem deleteMany
   */
  export type SpedFiscalItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedFiscalItems to delete
     */
    where?: SpedFiscalItemWhereInput
  }

  /**
   * SpedFiscalItem without action
   */
  export type SpedFiscalItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalItem
     */
    select?: SpedFiscalItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalItemInclude<ExtArgs> | null
  }


  /**
   * Model SpedFiscalApuracao
   */

  export type AggregateSpedFiscalApuracao = {
    _count: SpedFiscalApuracaoCountAggregateOutputType | null
    _avg: SpedFiscalApuracaoAvgAggregateOutputType | null
    _sum: SpedFiscalApuracaoSumAggregateOutputType | null
    _min: SpedFiscalApuracaoMinAggregateOutputType | null
    _max: SpedFiscalApuracaoMaxAggregateOutputType | null
  }

  export type SpedFiscalApuracaoAvgAggregateOutputType = {
    aliquota: number | null
    valorOperacao: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIcmsSt: number | null
    valorIcmsSt: number | null
    valorRedBc: number | null
    valorIpi: number | null
  }

  export type SpedFiscalApuracaoSumAggregateOutputType = {
    aliquota: number | null
    valorOperacao: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIcmsSt: number | null
    valorIcmsSt: number | null
    valorRedBc: number | null
    valorIpi: number | null
  }

  export type SpedFiscalApuracaoMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    cst: string | null
    cfop: string | null
    aliquota: number | null
    valorOperacao: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIcmsSt: number | null
    valorIcmsSt: number | null
    valorRedBc: number | null
    valorIpi: number | null
    createdAt: Date | null
  }

  export type SpedFiscalApuracaoMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    cst: string | null
    cfop: string | null
    aliquota: number | null
    valorOperacao: number | null
    baseIcms: number | null
    valorIcms: number | null
    baseIcmsSt: number | null
    valorIcmsSt: number | null
    valorRedBc: number | null
    valorIpi: number | null
    createdAt: Date | null
  }

  export type SpedFiscalApuracaoCountAggregateOutputType = {
    id: number
    documentId: number
    empresaId: number
    cst: number
    cfop: number
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt: number
    _all: number
  }


  export type SpedFiscalApuracaoAvgAggregateInputType = {
    aliquota?: true
    valorOperacao?: true
    baseIcms?: true
    valorIcms?: true
    baseIcmsSt?: true
    valorIcmsSt?: true
    valorRedBc?: true
    valorIpi?: true
  }

  export type SpedFiscalApuracaoSumAggregateInputType = {
    aliquota?: true
    valorOperacao?: true
    baseIcms?: true
    valorIcms?: true
    baseIcmsSt?: true
    valorIcmsSt?: true
    valorRedBc?: true
    valorIpi?: true
  }

  export type SpedFiscalApuracaoMinAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    cst?: true
    cfop?: true
    aliquota?: true
    valorOperacao?: true
    baseIcms?: true
    valorIcms?: true
    baseIcmsSt?: true
    valorIcmsSt?: true
    valorRedBc?: true
    valorIpi?: true
    createdAt?: true
  }

  export type SpedFiscalApuracaoMaxAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    cst?: true
    cfop?: true
    aliquota?: true
    valorOperacao?: true
    baseIcms?: true
    valorIcms?: true
    baseIcmsSt?: true
    valorIcmsSt?: true
    valorRedBc?: true
    valorIpi?: true
    createdAt?: true
  }

  export type SpedFiscalApuracaoCountAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    cst?: true
    cfop?: true
    aliquota?: true
    valorOperacao?: true
    baseIcms?: true
    valorIcms?: true
    baseIcmsSt?: true
    valorIcmsSt?: true
    valorRedBc?: true
    valorIpi?: true
    createdAt?: true
    _all?: true
  }

  export type SpedFiscalApuracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedFiscalApuracao to aggregate.
     */
    where?: SpedFiscalApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalApuracaos to fetch.
     */
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpedFiscalApuracaos
    **/
    _count?: true | SpedFiscalApuracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpedFiscalApuracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpedFiscalApuracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpedFiscalApuracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpedFiscalApuracaoMaxAggregateInputType
  }

  export type GetSpedFiscalApuracaoAggregateType<T extends SpedFiscalApuracaoAggregateArgs> = {
        [P in keyof T & keyof AggregateSpedFiscalApuracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpedFiscalApuracao[P]>
      : GetScalarType<T[P], AggregateSpedFiscalApuracao[P]>
  }




  export type SpedFiscalApuracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpedFiscalApuracaoWhereInput
    orderBy?: SpedFiscalApuracaoOrderByWithAggregationInput | SpedFiscalApuracaoOrderByWithAggregationInput[]
    by: SpedFiscalApuracaoScalarFieldEnum[] | SpedFiscalApuracaoScalarFieldEnum
    having?: SpedFiscalApuracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpedFiscalApuracaoCountAggregateInputType | true
    _avg?: SpedFiscalApuracaoAvgAggregateInputType
    _sum?: SpedFiscalApuracaoSumAggregateInputType
    _min?: SpedFiscalApuracaoMinAggregateInputType
    _max?: SpedFiscalApuracaoMaxAggregateInputType
  }

  export type SpedFiscalApuracaoGroupByOutputType = {
    id: string
    documentId: string
    empresaId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt: Date
    _count: SpedFiscalApuracaoCountAggregateOutputType | null
    _avg: SpedFiscalApuracaoAvgAggregateOutputType | null
    _sum: SpedFiscalApuracaoSumAggregateOutputType | null
    _min: SpedFiscalApuracaoMinAggregateOutputType | null
    _max: SpedFiscalApuracaoMaxAggregateOutputType | null
  }

  type GetSpedFiscalApuracaoGroupByPayload<T extends SpedFiscalApuracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpedFiscalApuracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpedFiscalApuracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpedFiscalApuracaoGroupByOutputType[P]>
            : GetScalarType<T[P], SpedFiscalApuracaoGroupByOutputType[P]>
        }
      >
    >


  export type SpedFiscalApuracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    cst?: boolean
    cfop?: boolean
    aliquota?: boolean
    valorOperacao?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIcmsSt?: boolean
    valorIcmsSt?: boolean
    valorRedBc?: boolean
    valorIpi?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedFiscalApuracao"]>

  export type SpedFiscalApuracaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    cst?: boolean
    cfop?: boolean
    aliquota?: boolean
    valorOperacao?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIcmsSt?: boolean
    valorIcmsSt?: boolean
    valorRedBc?: boolean
    valorIpi?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spedFiscalApuracao"]>

  export type SpedFiscalApuracaoSelectScalar = {
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    cst?: boolean
    cfop?: boolean
    aliquota?: boolean
    valorOperacao?: boolean
    baseIcms?: boolean
    valorIcms?: boolean
    baseIcmsSt?: boolean
    valorIcmsSt?: boolean
    valorRedBc?: boolean
    valorIpi?: boolean
    createdAt?: boolean
  }

  export type SpedFiscalApuracaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }
  export type SpedFiscalApuracaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $SpedFiscalApuracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpedFiscalApuracao"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      empresaId: string
      cst: string
      cfop: string
      aliquota: number
      valorOperacao: number
      baseIcms: number
      valorIcms: number
      baseIcmsSt: number
      valorIcmsSt: number
      valorRedBc: number
      valorIpi: number
      createdAt: Date
    }, ExtArgs["result"]["spedFiscalApuracao"]>
    composites: {}
  }

  type SpedFiscalApuracaoGetPayload<S extends boolean | null | undefined | SpedFiscalApuracaoDefaultArgs> = $Result.GetResult<Prisma.$SpedFiscalApuracaoPayload, S>

  type SpedFiscalApuracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpedFiscalApuracaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpedFiscalApuracaoCountAggregateInputType | true
    }

  export interface SpedFiscalApuracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpedFiscalApuracao'], meta: { name: 'SpedFiscalApuracao' } }
    /**
     * Find zero or one SpedFiscalApuracao that matches the filter.
     * @param {SpedFiscalApuracaoFindUniqueArgs} args - Arguments to find a SpedFiscalApuracao
     * @example
     * // Get one SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpedFiscalApuracaoFindUniqueArgs>(args: SelectSubset<T, SpedFiscalApuracaoFindUniqueArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpedFiscalApuracao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpedFiscalApuracaoFindUniqueOrThrowArgs} args - Arguments to find a SpedFiscalApuracao
     * @example
     * // Get one SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpedFiscalApuracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, SpedFiscalApuracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpedFiscalApuracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoFindFirstArgs} args - Arguments to find a SpedFiscalApuracao
     * @example
     * // Get one SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpedFiscalApuracaoFindFirstArgs>(args?: SelectSubset<T, SpedFiscalApuracaoFindFirstArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpedFiscalApuracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoFindFirstOrThrowArgs} args - Arguments to find a SpedFiscalApuracao
     * @example
     * // Get one SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpedFiscalApuracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, SpedFiscalApuracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpedFiscalApuracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpedFiscalApuracaos
     * const spedFiscalApuracaos = await prisma.spedFiscalApuracao.findMany()
     * 
     * // Get first 10 SpedFiscalApuracaos
     * const spedFiscalApuracaos = await prisma.spedFiscalApuracao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spedFiscalApuracaoWithIdOnly = await prisma.spedFiscalApuracao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpedFiscalApuracaoFindManyArgs>(args?: SelectSubset<T, SpedFiscalApuracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpedFiscalApuracao.
     * @param {SpedFiscalApuracaoCreateArgs} args - Arguments to create a SpedFiscalApuracao.
     * @example
     * // Create one SpedFiscalApuracao
     * const SpedFiscalApuracao = await prisma.spedFiscalApuracao.create({
     *   data: {
     *     // ... data to create a SpedFiscalApuracao
     *   }
     * })
     * 
     */
    create<T extends SpedFiscalApuracaoCreateArgs>(args: SelectSubset<T, SpedFiscalApuracaoCreateArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpedFiscalApuracaos.
     * @param {SpedFiscalApuracaoCreateManyArgs} args - Arguments to create many SpedFiscalApuracaos.
     * @example
     * // Create many SpedFiscalApuracaos
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpedFiscalApuracaoCreateManyArgs>(args?: SelectSubset<T, SpedFiscalApuracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpedFiscalApuracaos and returns the data saved in the database.
     * @param {SpedFiscalApuracaoCreateManyAndReturnArgs} args - Arguments to create many SpedFiscalApuracaos.
     * @example
     * // Create many SpedFiscalApuracaos
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpedFiscalApuracaos and only return the `id`
     * const spedFiscalApuracaoWithIdOnly = await prisma.spedFiscalApuracao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpedFiscalApuracaoCreateManyAndReturnArgs>(args?: SelectSubset<T, SpedFiscalApuracaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpedFiscalApuracao.
     * @param {SpedFiscalApuracaoDeleteArgs} args - Arguments to delete one SpedFiscalApuracao.
     * @example
     * // Delete one SpedFiscalApuracao
     * const SpedFiscalApuracao = await prisma.spedFiscalApuracao.delete({
     *   where: {
     *     // ... filter to delete one SpedFiscalApuracao
     *   }
     * })
     * 
     */
    delete<T extends SpedFiscalApuracaoDeleteArgs>(args: SelectSubset<T, SpedFiscalApuracaoDeleteArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpedFiscalApuracao.
     * @param {SpedFiscalApuracaoUpdateArgs} args - Arguments to update one SpedFiscalApuracao.
     * @example
     * // Update one SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpedFiscalApuracaoUpdateArgs>(args: SelectSubset<T, SpedFiscalApuracaoUpdateArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpedFiscalApuracaos.
     * @param {SpedFiscalApuracaoDeleteManyArgs} args - Arguments to filter SpedFiscalApuracaos to delete.
     * @example
     * // Delete a few SpedFiscalApuracaos
     * const { count } = await prisma.spedFiscalApuracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpedFiscalApuracaoDeleteManyArgs>(args?: SelectSubset<T, SpedFiscalApuracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpedFiscalApuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpedFiscalApuracaos
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpedFiscalApuracaoUpdateManyArgs>(args: SelectSubset<T, SpedFiscalApuracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpedFiscalApuracao.
     * @param {SpedFiscalApuracaoUpsertArgs} args - Arguments to update or create a SpedFiscalApuracao.
     * @example
     * // Update or create a SpedFiscalApuracao
     * const spedFiscalApuracao = await prisma.spedFiscalApuracao.upsert({
     *   create: {
     *     // ... data to create a SpedFiscalApuracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpedFiscalApuracao we want to update
     *   }
     * })
     */
    upsert<T extends SpedFiscalApuracaoUpsertArgs>(args: SelectSubset<T, SpedFiscalApuracaoUpsertArgs<ExtArgs>>): Prisma__SpedFiscalApuracaoClient<$Result.GetResult<Prisma.$SpedFiscalApuracaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpedFiscalApuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoCountArgs} args - Arguments to filter SpedFiscalApuracaos to count.
     * @example
     * // Count the number of SpedFiscalApuracaos
     * const count = await prisma.spedFiscalApuracao.count({
     *   where: {
     *     // ... the filter for the SpedFiscalApuracaos we want to count
     *   }
     * })
    **/
    count<T extends SpedFiscalApuracaoCountArgs>(
      args?: Subset<T, SpedFiscalApuracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpedFiscalApuracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpedFiscalApuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpedFiscalApuracaoAggregateArgs>(args: Subset<T, SpedFiscalApuracaoAggregateArgs>): Prisma.PrismaPromise<GetSpedFiscalApuracaoAggregateType<T>>

    /**
     * Group by SpedFiscalApuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpedFiscalApuracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpedFiscalApuracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpedFiscalApuracaoGroupByArgs['orderBy'] }
        : { orderBy?: SpedFiscalApuracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpedFiscalApuracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpedFiscalApuracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpedFiscalApuracao model
   */
  readonly fields: SpedFiscalApuracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpedFiscalApuracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpedFiscalApuracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpedFiscalApuracao model
   */ 
  interface SpedFiscalApuracaoFieldRefs {
    readonly id: FieldRef<"SpedFiscalApuracao", 'String'>
    readonly documentId: FieldRef<"SpedFiscalApuracao", 'String'>
    readonly empresaId: FieldRef<"SpedFiscalApuracao", 'String'>
    readonly cst: FieldRef<"SpedFiscalApuracao", 'String'>
    readonly cfop: FieldRef<"SpedFiscalApuracao", 'String'>
    readonly aliquota: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly valorOperacao: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly baseIcms: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly valorIcms: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly baseIcmsSt: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly valorIcmsSt: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly valorRedBc: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly valorIpi: FieldRef<"SpedFiscalApuracao", 'Float'>
    readonly createdAt: FieldRef<"SpedFiscalApuracao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpedFiscalApuracao findUnique
   */
  export type SpedFiscalApuracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalApuracao to fetch.
     */
    where: SpedFiscalApuracaoWhereUniqueInput
  }

  /**
   * SpedFiscalApuracao findUniqueOrThrow
   */
  export type SpedFiscalApuracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalApuracao to fetch.
     */
    where: SpedFiscalApuracaoWhereUniqueInput
  }

  /**
   * SpedFiscalApuracao findFirst
   */
  export type SpedFiscalApuracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalApuracao to fetch.
     */
    where?: SpedFiscalApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalApuracaos to fetch.
     */
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedFiscalApuracaos.
     */
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedFiscalApuracaos.
     */
    distinct?: SpedFiscalApuracaoScalarFieldEnum | SpedFiscalApuracaoScalarFieldEnum[]
  }

  /**
   * SpedFiscalApuracao findFirstOrThrow
   */
  export type SpedFiscalApuracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalApuracao to fetch.
     */
    where?: SpedFiscalApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalApuracaos to fetch.
     */
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpedFiscalApuracaos.
     */
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalApuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpedFiscalApuracaos.
     */
    distinct?: SpedFiscalApuracaoScalarFieldEnum | SpedFiscalApuracaoScalarFieldEnum[]
  }

  /**
   * SpedFiscalApuracao findMany
   */
  export type SpedFiscalApuracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter, which SpedFiscalApuracaos to fetch.
     */
    where?: SpedFiscalApuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpedFiscalApuracaos to fetch.
     */
    orderBy?: SpedFiscalApuracaoOrderByWithRelationInput | SpedFiscalApuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpedFiscalApuracaos.
     */
    cursor?: SpedFiscalApuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpedFiscalApuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpedFiscalApuracaos.
     */
    skip?: number
    distinct?: SpedFiscalApuracaoScalarFieldEnum | SpedFiscalApuracaoScalarFieldEnum[]
  }

  /**
   * SpedFiscalApuracao create
   */
  export type SpedFiscalApuracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * The data needed to create a SpedFiscalApuracao.
     */
    data: XOR<SpedFiscalApuracaoCreateInput, SpedFiscalApuracaoUncheckedCreateInput>
  }

  /**
   * SpedFiscalApuracao createMany
   */
  export type SpedFiscalApuracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpedFiscalApuracaos.
     */
    data: SpedFiscalApuracaoCreateManyInput | SpedFiscalApuracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpedFiscalApuracao createManyAndReturn
   */
  export type SpedFiscalApuracaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpedFiscalApuracaos.
     */
    data: SpedFiscalApuracaoCreateManyInput | SpedFiscalApuracaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpedFiscalApuracao update
   */
  export type SpedFiscalApuracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * The data needed to update a SpedFiscalApuracao.
     */
    data: XOR<SpedFiscalApuracaoUpdateInput, SpedFiscalApuracaoUncheckedUpdateInput>
    /**
     * Choose, which SpedFiscalApuracao to update.
     */
    where: SpedFiscalApuracaoWhereUniqueInput
  }

  /**
   * SpedFiscalApuracao updateMany
   */
  export type SpedFiscalApuracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpedFiscalApuracaos.
     */
    data: XOR<SpedFiscalApuracaoUpdateManyMutationInput, SpedFiscalApuracaoUncheckedUpdateManyInput>
    /**
     * Filter which SpedFiscalApuracaos to update
     */
    where?: SpedFiscalApuracaoWhereInput
  }

  /**
   * SpedFiscalApuracao upsert
   */
  export type SpedFiscalApuracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * The filter to search for the SpedFiscalApuracao to update in case it exists.
     */
    where: SpedFiscalApuracaoWhereUniqueInput
    /**
     * In case the SpedFiscalApuracao found by the `where` argument doesn't exist, create a new SpedFiscalApuracao with this data.
     */
    create: XOR<SpedFiscalApuracaoCreateInput, SpedFiscalApuracaoUncheckedCreateInput>
    /**
     * In case the SpedFiscalApuracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpedFiscalApuracaoUpdateInput, SpedFiscalApuracaoUncheckedUpdateInput>
  }

  /**
   * SpedFiscalApuracao delete
   */
  export type SpedFiscalApuracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
    /**
     * Filter which SpedFiscalApuracao to delete.
     */
    where: SpedFiscalApuracaoWhereUniqueInput
  }

  /**
   * SpedFiscalApuracao deleteMany
   */
  export type SpedFiscalApuracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpedFiscalApuracaos to delete
     */
    where?: SpedFiscalApuracaoWhereInput
  }

  /**
   * SpedFiscalApuracao without action
   */
  export type SpedFiscalApuracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpedFiscalApuracao
     */
    select?: SpedFiscalApuracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpedFiscalApuracaoInclude<ExtArgs> | null
  }


  /**
   * Model XMLDocument
   */

  export type AggregateXMLDocument = {
    _count: XMLDocumentCountAggregateOutputType | null
    _avg: XMLDocumentAvgAggregateOutputType | null
    _sum: XMLDocumentSumAggregateOutputType | null
    _min: XMLDocumentMinAggregateOutputType | null
    _max: XMLDocumentMaxAggregateOutputType | null
  }

  export type XMLDocumentAvgAggregateOutputType = {
    valorTotal: number | null
    valorTotalIcms: number | null
    valorTotalIpi: number | null
    valorTotalPis: number | null
    valorTotalCofins: number | null
    valorTotalIss: number | null
    baseCalculoIcms: number | null
    baseCalculoPis: number | null
    baseCalculoCofins: number | null
  }

  export type XMLDocumentSumAggregateOutputType = {
    valorTotal: number | null
    valorTotalIcms: number | null
    valorTotalIpi: number | null
    valorTotalPis: number | null
    valorTotalCofins: number | null
    valorTotalIss: number | null
    baseCalculoIcms: number | null
    baseCalculoPis: number | null
    baseCalculoCofins: number | null
  }

  export type XMLDocumentMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    tipoDocumento: string | null
    numeroDocumento: string | null
    serie: string | null
    dataEmissao: Date | null
    valorTotal: number | null
    cnpjEmitente: string | null
    cnpjDestinatario: string | null
    cpfDestinatario: string | null
    chaveAcesso: string | null
    protocolo: string | null
    status: string | null
    observacoes: string | null
    valorTotalIcms: number | null
    valorTotalIpi: number | null
    valorTotalPis: number | null
    valorTotalCofins: number | null
    valorTotalIss: number | null
    baseCalculoIcms: number | null
    baseCalculoPis: number | null
    baseCalculoCofins: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XMLDocumentMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    empresaId: string | null
    tipoDocumento: string | null
    numeroDocumento: string | null
    serie: string | null
    dataEmissao: Date | null
    valorTotal: number | null
    cnpjEmitente: string | null
    cnpjDestinatario: string | null
    cpfDestinatario: string | null
    chaveAcesso: string | null
    protocolo: string | null
    status: string | null
    observacoes: string | null
    valorTotalIcms: number | null
    valorTotalIpi: number | null
    valorTotalPis: number | null
    valorTotalCofins: number | null
    valorTotalIss: number | null
    baseCalculoIcms: number | null
    baseCalculoPis: number | null
    baseCalculoCofins: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XMLDocumentCountAggregateOutputType = {
    id: number
    documentId: number
    empresaId: number
    tipoDocumento: number
    numeroDocumento: number
    serie: number
    dataEmissao: number
    valorTotal: number
    cnpjEmitente: number
    cnpjDestinatario: number
    cpfDestinatario: number
    chaveAcesso: number
    protocolo: number
    status: number
    observacoes: number
    valorTotalIcms: number
    valorTotalIpi: number
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss: number
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XMLDocumentAvgAggregateInputType = {
    valorTotal?: true
    valorTotalIcms?: true
    valorTotalIpi?: true
    valorTotalPis?: true
    valorTotalCofins?: true
    valorTotalIss?: true
    baseCalculoIcms?: true
    baseCalculoPis?: true
    baseCalculoCofins?: true
  }

  export type XMLDocumentSumAggregateInputType = {
    valorTotal?: true
    valorTotalIcms?: true
    valorTotalIpi?: true
    valorTotalPis?: true
    valorTotalCofins?: true
    valorTotalIss?: true
    baseCalculoIcms?: true
    baseCalculoPis?: true
    baseCalculoCofins?: true
  }

  export type XMLDocumentMinAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipoDocumento?: true
    numeroDocumento?: true
    serie?: true
    dataEmissao?: true
    valorTotal?: true
    cnpjEmitente?: true
    cnpjDestinatario?: true
    cpfDestinatario?: true
    chaveAcesso?: true
    protocolo?: true
    status?: true
    observacoes?: true
    valorTotalIcms?: true
    valorTotalIpi?: true
    valorTotalPis?: true
    valorTotalCofins?: true
    valorTotalIss?: true
    baseCalculoIcms?: true
    baseCalculoPis?: true
    baseCalculoCofins?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XMLDocumentMaxAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipoDocumento?: true
    numeroDocumento?: true
    serie?: true
    dataEmissao?: true
    valorTotal?: true
    cnpjEmitente?: true
    cnpjDestinatario?: true
    cpfDestinatario?: true
    chaveAcesso?: true
    protocolo?: true
    status?: true
    observacoes?: true
    valorTotalIcms?: true
    valorTotalIpi?: true
    valorTotalPis?: true
    valorTotalCofins?: true
    valorTotalIss?: true
    baseCalculoIcms?: true
    baseCalculoPis?: true
    baseCalculoCofins?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XMLDocumentCountAggregateInputType = {
    id?: true
    documentId?: true
    empresaId?: true
    tipoDocumento?: true
    numeroDocumento?: true
    serie?: true
    dataEmissao?: true
    valorTotal?: true
    cnpjEmitente?: true
    cnpjDestinatario?: true
    cpfDestinatario?: true
    chaveAcesso?: true
    protocolo?: true
    status?: true
    observacoes?: true
    valorTotalIcms?: true
    valorTotalIpi?: true
    valorTotalPis?: true
    valorTotalCofins?: true
    valorTotalIss?: true
    baseCalculoIcms?: true
    baseCalculoPis?: true
    baseCalculoCofins?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XMLDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XMLDocument to aggregate.
     */
    where?: XMLDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLDocuments to fetch.
     */
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XMLDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XMLDocuments
    **/
    _count?: true | XMLDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XMLDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XMLDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XMLDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XMLDocumentMaxAggregateInputType
  }

  export type GetXMLDocumentAggregateType<T extends XMLDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateXMLDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXMLDocument[P]>
      : GetScalarType<T[P], AggregateXMLDocument[P]>
  }




  export type XMLDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XMLDocumentWhereInput
    orderBy?: XMLDocumentOrderByWithAggregationInput | XMLDocumentOrderByWithAggregationInput[]
    by: XMLDocumentScalarFieldEnum[] | XMLDocumentScalarFieldEnum
    having?: XMLDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XMLDocumentCountAggregateInputType | true
    _avg?: XMLDocumentAvgAggregateInputType
    _sum?: XMLDocumentSumAggregateInputType
    _min?: XMLDocumentMinAggregateInputType
    _max?: XMLDocumentMaxAggregateInputType
  }

  export type XMLDocumentGroupByOutputType = {
    id: string
    documentId: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario: string | null
    cpfDestinatario: string | null
    chaveAcesso: string | null
    protocolo: string | null
    status: string
    observacoes: string | null
    valorTotalIcms: number
    valorTotalIpi: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt: Date
    updatedAt: Date
    _count: XMLDocumentCountAggregateOutputType | null
    _avg: XMLDocumentAvgAggregateOutputType | null
    _sum: XMLDocumentSumAggregateOutputType | null
    _min: XMLDocumentMinAggregateOutputType | null
    _max: XMLDocumentMaxAggregateOutputType | null
  }

  type GetXMLDocumentGroupByPayload<T extends XMLDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XMLDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XMLDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XMLDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], XMLDocumentGroupByOutputType[P]>
        }
      >
    >


  export type XMLDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipoDocumento?: boolean
    numeroDocumento?: boolean
    serie?: boolean
    dataEmissao?: boolean
    valorTotal?: boolean
    cnpjEmitente?: boolean
    cnpjDestinatario?: boolean
    cpfDestinatario?: boolean
    chaveAcesso?: boolean
    protocolo?: boolean
    status?: boolean
    observacoes?: boolean
    valorTotalIcms?: boolean
    valorTotalIpi?: boolean
    valorTotalPis?: boolean
    valorTotalCofins?: boolean
    valorTotalIss?: boolean
    baseCalculoIcms?: boolean
    baseCalculoPis?: boolean
    baseCalculoCofins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    itens?: boolean | XMLDocument$itensArgs<ExtArgs>
    _count?: boolean | XMLDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xMLDocument"]>

  export type XMLDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipoDocumento?: boolean
    numeroDocumento?: boolean
    serie?: boolean
    dataEmissao?: boolean
    valorTotal?: boolean
    cnpjEmitente?: boolean
    cnpjDestinatario?: boolean
    cpfDestinatario?: boolean
    chaveAcesso?: boolean
    protocolo?: boolean
    status?: boolean
    observacoes?: boolean
    valorTotalIcms?: boolean
    valorTotalIpi?: boolean
    valorTotalPis?: boolean
    valorTotalCofins?: boolean
    valorTotalIss?: boolean
    baseCalculoIcms?: boolean
    baseCalculoPis?: boolean
    baseCalculoCofins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xMLDocument"]>

  export type XMLDocumentSelectScalar = {
    id?: boolean
    documentId?: boolean
    empresaId?: boolean
    tipoDocumento?: boolean
    numeroDocumento?: boolean
    serie?: boolean
    dataEmissao?: boolean
    valorTotal?: boolean
    cnpjEmitente?: boolean
    cnpjDestinatario?: boolean
    cpfDestinatario?: boolean
    chaveAcesso?: boolean
    protocolo?: boolean
    status?: boolean
    observacoes?: boolean
    valorTotalIcms?: boolean
    valorTotalIpi?: boolean
    valorTotalPis?: boolean
    valorTotalCofins?: boolean
    valorTotalIss?: boolean
    baseCalculoIcms?: boolean
    baseCalculoPis?: boolean
    baseCalculoCofins?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XMLDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
    itens?: boolean | XMLDocument$itensArgs<ExtArgs>
    _count?: boolean | XMLDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type XMLDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    empresa?: boolean | EmpresaDefaultArgs<ExtArgs>
  }

  export type $XMLDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XMLDocument"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      empresa: Prisma.$EmpresaPayload<ExtArgs>
      itens: Prisma.$XMLItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      empresaId: string
      tipoDocumento: string
      numeroDocumento: string
      serie: string
      dataEmissao: Date
      valorTotal: number
      cnpjEmitente: string
      cnpjDestinatario: string | null
      cpfDestinatario: string | null
      chaveAcesso: string | null
      protocolo: string | null
      status: string
      observacoes: string | null
      valorTotalIcms: number
      valorTotalIpi: number | null
      valorTotalPis: number
      valorTotalCofins: number
      valorTotalIss: number | null
      baseCalculoIcms: number
      baseCalculoPis: number
      baseCalculoCofins: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xMLDocument"]>
    composites: {}
  }

  type XMLDocumentGetPayload<S extends boolean | null | undefined | XMLDocumentDefaultArgs> = $Result.GetResult<Prisma.$XMLDocumentPayload, S>

  type XMLDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XMLDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XMLDocumentCountAggregateInputType | true
    }

  export interface XMLDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XMLDocument'], meta: { name: 'XMLDocument' } }
    /**
     * Find zero or one XMLDocument that matches the filter.
     * @param {XMLDocumentFindUniqueArgs} args - Arguments to find a XMLDocument
     * @example
     * // Get one XMLDocument
     * const xMLDocument = await prisma.xMLDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XMLDocumentFindUniqueArgs>(args: SelectSubset<T, XMLDocumentFindUniqueArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XMLDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XMLDocumentFindUniqueOrThrowArgs} args - Arguments to find a XMLDocument
     * @example
     * // Get one XMLDocument
     * const xMLDocument = await prisma.xMLDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XMLDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, XMLDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XMLDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentFindFirstArgs} args - Arguments to find a XMLDocument
     * @example
     * // Get one XMLDocument
     * const xMLDocument = await prisma.xMLDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XMLDocumentFindFirstArgs>(args?: SelectSubset<T, XMLDocumentFindFirstArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XMLDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentFindFirstOrThrowArgs} args - Arguments to find a XMLDocument
     * @example
     * // Get one XMLDocument
     * const xMLDocument = await prisma.xMLDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XMLDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, XMLDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XMLDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XMLDocuments
     * const xMLDocuments = await prisma.xMLDocument.findMany()
     * 
     * // Get first 10 XMLDocuments
     * const xMLDocuments = await prisma.xMLDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xMLDocumentWithIdOnly = await prisma.xMLDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XMLDocumentFindManyArgs>(args?: SelectSubset<T, XMLDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XMLDocument.
     * @param {XMLDocumentCreateArgs} args - Arguments to create a XMLDocument.
     * @example
     * // Create one XMLDocument
     * const XMLDocument = await prisma.xMLDocument.create({
     *   data: {
     *     // ... data to create a XMLDocument
     *   }
     * })
     * 
     */
    create<T extends XMLDocumentCreateArgs>(args: SelectSubset<T, XMLDocumentCreateArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XMLDocuments.
     * @param {XMLDocumentCreateManyArgs} args - Arguments to create many XMLDocuments.
     * @example
     * // Create many XMLDocuments
     * const xMLDocument = await prisma.xMLDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XMLDocumentCreateManyArgs>(args?: SelectSubset<T, XMLDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XMLDocuments and returns the data saved in the database.
     * @param {XMLDocumentCreateManyAndReturnArgs} args - Arguments to create many XMLDocuments.
     * @example
     * // Create many XMLDocuments
     * const xMLDocument = await prisma.xMLDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XMLDocuments and only return the `id`
     * const xMLDocumentWithIdOnly = await prisma.xMLDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XMLDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, XMLDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XMLDocument.
     * @param {XMLDocumentDeleteArgs} args - Arguments to delete one XMLDocument.
     * @example
     * // Delete one XMLDocument
     * const XMLDocument = await prisma.xMLDocument.delete({
     *   where: {
     *     // ... filter to delete one XMLDocument
     *   }
     * })
     * 
     */
    delete<T extends XMLDocumentDeleteArgs>(args: SelectSubset<T, XMLDocumentDeleteArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XMLDocument.
     * @param {XMLDocumentUpdateArgs} args - Arguments to update one XMLDocument.
     * @example
     * // Update one XMLDocument
     * const xMLDocument = await prisma.xMLDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XMLDocumentUpdateArgs>(args: SelectSubset<T, XMLDocumentUpdateArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XMLDocuments.
     * @param {XMLDocumentDeleteManyArgs} args - Arguments to filter XMLDocuments to delete.
     * @example
     * // Delete a few XMLDocuments
     * const { count } = await prisma.xMLDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XMLDocumentDeleteManyArgs>(args?: SelectSubset<T, XMLDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XMLDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XMLDocuments
     * const xMLDocument = await prisma.xMLDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XMLDocumentUpdateManyArgs>(args: SelectSubset<T, XMLDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XMLDocument.
     * @param {XMLDocumentUpsertArgs} args - Arguments to update or create a XMLDocument.
     * @example
     * // Update or create a XMLDocument
     * const xMLDocument = await prisma.xMLDocument.upsert({
     *   create: {
     *     // ... data to create a XMLDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XMLDocument we want to update
     *   }
     * })
     */
    upsert<T extends XMLDocumentUpsertArgs>(args: SelectSubset<T, XMLDocumentUpsertArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XMLDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentCountArgs} args - Arguments to filter XMLDocuments to count.
     * @example
     * // Count the number of XMLDocuments
     * const count = await prisma.xMLDocument.count({
     *   where: {
     *     // ... the filter for the XMLDocuments we want to count
     *   }
     * })
    **/
    count<T extends XMLDocumentCountArgs>(
      args?: Subset<T, XMLDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XMLDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XMLDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XMLDocumentAggregateArgs>(args: Subset<T, XMLDocumentAggregateArgs>): Prisma.PrismaPromise<GetXMLDocumentAggregateType<T>>

    /**
     * Group by XMLDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XMLDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XMLDocumentGroupByArgs['orderBy'] }
        : { orderBy?: XMLDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XMLDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXMLDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XMLDocument model
   */
  readonly fields: XMLDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XMLDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XMLDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    empresa<T extends EmpresaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpresaDefaultArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    itens<T extends XMLDocument$itensArgs<ExtArgs> = {}>(args?: Subset<T, XMLDocument$itensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XMLDocument model
   */ 
  interface XMLDocumentFieldRefs {
    readonly id: FieldRef<"XMLDocument", 'String'>
    readonly documentId: FieldRef<"XMLDocument", 'String'>
    readonly empresaId: FieldRef<"XMLDocument", 'String'>
    readonly tipoDocumento: FieldRef<"XMLDocument", 'String'>
    readonly numeroDocumento: FieldRef<"XMLDocument", 'String'>
    readonly serie: FieldRef<"XMLDocument", 'String'>
    readonly dataEmissao: FieldRef<"XMLDocument", 'DateTime'>
    readonly valorTotal: FieldRef<"XMLDocument", 'Float'>
    readonly cnpjEmitente: FieldRef<"XMLDocument", 'String'>
    readonly cnpjDestinatario: FieldRef<"XMLDocument", 'String'>
    readonly cpfDestinatario: FieldRef<"XMLDocument", 'String'>
    readonly chaveAcesso: FieldRef<"XMLDocument", 'String'>
    readonly protocolo: FieldRef<"XMLDocument", 'String'>
    readonly status: FieldRef<"XMLDocument", 'String'>
    readonly observacoes: FieldRef<"XMLDocument", 'String'>
    readonly valorTotalIcms: FieldRef<"XMLDocument", 'Float'>
    readonly valorTotalIpi: FieldRef<"XMLDocument", 'Float'>
    readonly valorTotalPis: FieldRef<"XMLDocument", 'Float'>
    readonly valorTotalCofins: FieldRef<"XMLDocument", 'Float'>
    readonly valorTotalIss: FieldRef<"XMLDocument", 'Float'>
    readonly baseCalculoIcms: FieldRef<"XMLDocument", 'Float'>
    readonly baseCalculoPis: FieldRef<"XMLDocument", 'Float'>
    readonly baseCalculoCofins: FieldRef<"XMLDocument", 'Float'>
    readonly createdAt: FieldRef<"XMLDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"XMLDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XMLDocument findUnique
   */
  export type XMLDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter, which XMLDocument to fetch.
     */
    where: XMLDocumentWhereUniqueInput
  }

  /**
   * XMLDocument findUniqueOrThrow
   */
  export type XMLDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter, which XMLDocument to fetch.
     */
    where: XMLDocumentWhereUniqueInput
  }

  /**
   * XMLDocument findFirst
   */
  export type XMLDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter, which XMLDocument to fetch.
     */
    where?: XMLDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLDocuments to fetch.
     */
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XMLDocuments.
     */
    cursor?: XMLDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XMLDocuments.
     */
    distinct?: XMLDocumentScalarFieldEnum | XMLDocumentScalarFieldEnum[]
  }

  /**
   * XMLDocument findFirstOrThrow
   */
  export type XMLDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter, which XMLDocument to fetch.
     */
    where?: XMLDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLDocuments to fetch.
     */
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XMLDocuments.
     */
    cursor?: XMLDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XMLDocuments.
     */
    distinct?: XMLDocumentScalarFieldEnum | XMLDocumentScalarFieldEnum[]
  }

  /**
   * XMLDocument findMany
   */
  export type XMLDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter, which XMLDocuments to fetch.
     */
    where?: XMLDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLDocuments to fetch.
     */
    orderBy?: XMLDocumentOrderByWithRelationInput | XMLDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XMLDocuments.
     */
    cursor?: XMLDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLDocuments.
     */
    skip?: number
    distinct?: XMLDocumentScalarFieldEnum | XMLDocumentScalarFieldEnum[]
  }

  /**
   * XMLDocument create
   */
  export type XMLDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a XMLDocument.
     */
    data: XOR<XMLDocumentCreateInput, XMLDocumentUncheckedCreateInput>
  }

  /**
   * XMLDocument createMany
   */
  export type XMLDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XMLDocuments.
     */
    data: XMLDocumentCreateManyInput | XMLDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XMLDocument createManyAndReturn
   */
  export type XMLDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XMLDocuments.
     */
    data: XMLDocumentCreateManyInput | XMLDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XMLDocument update
   */
  export type XMLDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a XMLDocument.
     */
    data: XOR<XMLDocumentUpdateInput, XMLDocumentUncheckedUpdateInput>
    /**
     * Choose, which XMLDocument to update.
     */
    where: XMLDocumentWhereUniqueInput
  }

  /**
   * XMLDocument updateMany
   */
  export type XMLDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XMLDocuments.
     */
    data: XOR<XMLDocumentUpdateManyMutationInput, XMLDocumentUncheckedUpdateManyInput>
    /**
     * Filter which XMLDocuments to update
     */
    where?: XMLDocumentWhereInput
  }

  /**
   * XMLDocument upsert
   */
  export type XMLDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the XMLDocument to update in case it exists.
     */
    where: XMLDocumentWhereUniqueInput
    /**
     * In case the XMLDocument found by the `where` argument doesn't exist, create a new XMLDocument with this data.
     */
    create: XOR<XMLDocumentCreateInput, XMLDocumentUncheckedCreateInput>
    /**
     * In case the XMLDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XMLDocumentUpdateInput, XMLDocumentUncheckedUpdateInput>
  }

  /**
   * XMLDocument delete
   */
  export type XMLDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
    /**
     * Filter which XMLDocument to delete.
     */
    where: XMLDocumentWhereUniqueInput
  }

  /**
   * XMLDocument deleteMany
   */
  export type XMLDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XMLDocuments to delete
     */
    where?: XMLDocumentWhereInput
  }

  /**
   * XMLDocument.itens
   */
  export type XMLDocument$itensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    where?: XMLItemWhereInput
    orderBy?: XMLItemOrderByWithRelationInput | XMLItemOrderByWithRelationInput[]
    cursor?: XMLItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XMLItemScalarFieldEnum | XMLItemScalarFieldEnum[]
  }

  /**
   * XMLDocument without action
   */
  export type XMLDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLDocument
     */
    select?: XMLDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLDocumentInclude<ExtArgs> | null
  }


  /**
   * Model XMLItem
   */

  export type AggregateXMLItem = {
    _count: XMLItemCountAggregateOutputType | null
    _avg: XMLItemAvgAggregateOutputType | null
    _sum: XMLItemSumAggregateOutputType | null
    _min: XMLItemMinAggregateOutputType | null
    _max: XMLItemMaxAggregateOutputType | null
  }

  export type XMLItemAvgAggregateOutputType = {
    quantidade: number | null
    valorUnitario: number | null
    valorTotal: number | null
    aliquotaIcms: number | null
    valorIcms: number | null
    aliquotaIpi: number | null
    valorIpi: number | null
    aliquotaPis: number | null
    valorPis: number | null
    aliquotaCofins: number | null
    valorCofins: number | null
  }

  export type XMLItemSumAggregateOutputType = {
    quantidade: number | null
    valorUnitario: number | null
    valorTotal: number | null
    aliquotaIcms: number | null
    valorIcms: number | null
    aliquotaIpi: number | null
    valorIpi: number | null
    aliquotaPis: number | null
    valorPis: number | null
    aliquotaCofins: number | null
    valorCofins: number | null
  }

  export type XMLItemMinAggregateOutputType = {
    id: string | null
    xmlDocumentId: string | null
    codigo: string | null
    descricao: string | null
    ncm: string | null
    cfop: string | null
    quantidade: number | null
    valorUnitario: number | null
    valorTotal: number | null
    cst: string | null
    aliquotaIcms: number | null
    valorIcms: number | null
    aliquotaIpi: number | null
    valorIpi: number | null
    aliquotaPis: number | null
    valorPis: number | null
    aliquotaCofins: number | null
    valorCofins: number | null
    createdAt: Date | null
  }

  export type XMLItemMaxAggregateOutputType = {
    id: string | null
    xmlDocumentId: string | null
    codigo: string | null
    descricao: string | null
    ncm: string | null
    cfop: string | null
    quantidade: number | null
    valorUnitario: number | null
    valorTotal: number | null
    cst: string | null
    aliquotaIcms: number | null
    valorIcms: number | null
    aliquotaIpi: number | null
    valorIpi: number | null
    aliquotaPis: number | null
    valorPis: number | null
    aliquotaCofins: number | null
    valorCofins: number | null
    createdAt: Date | null
  }

  export type XMLItemCountAggregateOutputType = {
    id: number
    xmlDocumentId: number
    codigo: number
    descricao: number
    ncm: number
    cfop: number
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: number
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi: number
    valorIpi: number
    aliquotaPis: number
    valorPis: number
    aliquotaCofins: number
    valorCofins: number
    createdAt: number
    _all: number
  }


  export type XMLItemAvgAggregateInputType = {
    quantidade?: true
    valorUnitario?: true
    valorTotal?: true
    aliquotaIcms?: true
    valorIcms?: true
    aliquotaIpi?: true
    valorIpi?: true
    aliquotaPis?: true
    valorPis?: true
    aliquotaCofins?: true
    valorCofins?: true
  }

  export type XMLItemSumAggregateInputType = {
    quantidade?: true
    valorUnitario?: true
    valorTotal?: true
    aliquotaIcms?: true
    valorIcms?: true
    aliquotaIpi?: true
    valorIpi?: true
    aliquotaPis?: true
    valorPis?: true
    aliquotaCofins?: true
    valorCofins?: true
  }

  export type XMLItemMinAggregateInputType = {
    id?: true
    xmlDocumentId?: true
    codigo?: true
    descricao?: true
    ncm?: true
    cfop?: true
    quantidade?: true
    valorUnitario?: true
    valorTotal?: true
    cst?: true
    aliquotaIcms?: true
    valorIcms?: true
    aliquotaIpi?: true
    valorIpi?: true
    aliquotaPis?: true
    valorPis?: true
    aliquotaCofins?: true
    valorCofins?: true
    createdAt?: true
  }

  export type XMLItemMaxAggregateInputType = {
    id?: true
    xmlDocumentId?: true
    codigo?: true
    descricao?: true
    ncm?: true
    cfop?: true
    quantidade?: true
    valorUnitario?: true
    valorTotal?: true
    cst?: true
    aliquotaIcms?: true
    valorIcms?: true
    aliquotaIpi?: true
    valorIpi?: true
    aliquotaPis?: true
    valorPis?: true
    aliquotaCofins?: true
    valorCofins?: true
    createdAt?: true
  }

  export type XMLItemCountAggregateInputType = {
    id?: true
    xmlDocumentId?: true
    codigo?: true
    descricao?: true
    ncm?: true
    cfop?: true
    quantidade?: true
    valorUnitario?: true
    valorTotal?: true
    cst?: true
    aliquotaIcms?: true
    valorIcms?: true
    aliquotaIpi?: true
    valorIpi?: true
    aliquotaPis?: true
    valorPis?: true
    aliquotaCofins?: true
    valorCofins?: true
    createdAt?: true
    _all?: true
  }

  export type XMLItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XMLItem to aggregate.
     */
    where?: XMLItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLItems to fetch.
     */
    orderBy?: XMLItemOrderByWithRelationInput | XMLItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XMLItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XMLItems
    **/
    _count?: true | XMLItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XMLItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XMLItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XMLItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XMLItemMaxAggregateInputType
  }

  export type GetXMLItemAggregateType<T extends XMLItemAggregateArgs> = {
        [P in keyof T & keyof AggregateXMLItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXMLItem[P]>
      : GetScalarType<T[P], AggregateXMLItem[P]>
  }




  export type XMLItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XMLItemWhereInput
    orderBy?: XMLItemOrderByWithAggregationInput | XMLItemOrderByWithAggregationInput[]
    by: XMLItemScalarFieldEnum[] | XMLItemScalarFieldEnum
    having?: XMLItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XMLItemCountAggregateInputType | true
    _avg?: XMLItemAvgAggregateInputType
    _sum?: XMLItemSumAggregateInputType
    _min?: XMLItemMinAggregateInputType
    _max?: XMLItemMaxAggregateInputType
  }

  export type XMLItemGroupByOutputType = {
    id: string
    xmlDocumentId: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi: number | null
    valorIpi: number | null
    aliquotaPis: number | null
    valorPis: number | null
    aliquotaCofins: number | null
    valorCofins: number | null
    createdAt: Date
    _count: XMLItemCountAggregateOutputType | null
    _avg: XMLItemAvgAggregateOutputType | null
    _sum: XMLItemSumAggregateOutputType | null
    _min: XMLItemMinAggregateOutputType | null
    _max: XMLItemMaxAggregateOutputType | null
  }

  type GetXMLItemGroupByPayload<T extends XMLItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XMLItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XMLItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XMLItemGroupByOutputType[P]>
            : GetScalarType<T[P], XMLItemGroupByOutputType[P]>
        }
      >
    >


  export type XMLItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xmlDocumentId?: boolean
    codigo?: boolean
    descricao?: boolean
    ncm?: boolean
    cfop?: boolean
    quantidade?: boolean
    valorUnitario?: boolean
    valorTotal?: boolean
    cst?: boolean
    aliquotaIcms?: boolean
    valorIcms?: boolean
    aliquotaIpi?: boolean
    valorIpi?: boolean
    aliquotaPis?: boolean
    valorPis?: boolean
    aliquotaCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
    xmlDocument?: boolean | XMLDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xMLItem"]>

  export type XMLItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xmlDocumentId?: boolean
    codigo?: boolean
    descricao?: boolean
    ncm?: boolean
    cfop?: boolean
    quantidade?: boolean
    valorUnitario?: boolean
    valorTotal?: boolean
    cst?: boolean
    aliquotaIcms?: boolean
    valorIcms?: boolean
    aliquotaIpi?: boolean
    valorIpi?: boolean
    aliquotaPis?: boolean
    valorPis?: boolean
    aliquotaCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
    xmlDocument?: boolean | XMLDocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xMLItem"]>

  export type XMLItemSelectScalar = {
    id?: boolean
    xmlDocumentId?: boolean
    codigo?: boolean
    descricao?: boolean
    ncm?: boolean
    cfop?: boolean
    quantidade?: boolean
    valorUnitario?: boolean
    valorTotal?: boolean
    cst?: boolean
    aliquotaIcms?: boolean
    valorIcms?: boolean
    aliquotaIpi?: boolean
    valorIpi?: boolean
    aliquotaPis?: boolean
    valorPis?: boolean
    aliquotaCofins?: boolean
    valorCofins?: boolean
    createdAt?: boolean
  }

  export type XMLItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    xmlDocument?: boolean | XMLDocumentDefaultArgs<ExtArgs>
  }
  export type XMLItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    xmlDocument?: boolean | XMLDocumentDefaultArgs<ExtArgs>
  }

  export type $XMLItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XMLItem"
    objects: {
      xmlDocument: Prisma.$XMLDocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xmlDocumentId: string
      codigo: string
      descricao: string
      ncm: string
      cfop: string
      quantidade: number
      valorUnitario: number
      valorTotal: number
      cst: string
      aliquotaIcms: number
      valorIcms: number
      aliquotaIpi: number | null
      valorIpi: number | null
      aliquotaPis: number | null
      valorPis: number | null
      aliquotaCofins: number | null
      valorCofins: number | null
      createdAt: Date
    }, ExtArgs["result"]["xMLItem"]>
    composites: {}
  }

  type XMLItemGetPayload<S extends boolean | null | undefined | XMLItemDefaultArgs> = $Result.GetResult<Prisma.$XMLItemPayload, S>

  type XMLItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<XMLItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: XMLItemCountAggregateInputType | true
    }

  export interface XMLItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XMLItem'], meta: { name: 'XMLItem' } }
    /**
     * Find zero or one XMLItem that matches the filter.
     * @param {XMLItemFindUniqueArgs} args - Arguments to find a XMLItem
     * @example
     * // Get one XMLItem
     * const xMLItem = await prisma.xMLItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XMLItemFindUniqueArgs>(args: SelectSubset<T, XMLItemFindUniqueArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one XMLItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {XMLItemFindUniqueOrThrowArgs} args - Arguments to find a XMLItem
     * @example
     * // Get one XMLItem
     * const xMLItem = await prisma.xMLItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XMLItemFindUniqueOrThrowArgs>(args: SelectSubset<T, XMLItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first XMLItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemFindFirstArgs} args - Arguments to find a XMLItem
     * @example
     * // Get one XMLItem
     * const xMLItem = await prisma.xMLItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XMLItemFindFirstArgs>(args?: SelectSubset<T, XMLItemFindFirstArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first XMLItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemFindFirstOrThrowArgs} args - Arguments to find a XMLItem
     * @example
     * // Get one XMLItem
     * const xMLItem = await prisma.xMLItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XMLItemFindFirstOrThrowArgs>(args?: SelectSubset<T, XMLItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more XMLItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XMLItems
     * const xMLItems = await prisma.xMLItem.findMany()
     * 
     * // Get first 10 XMLItems
     * const xMLItems = await prisma.xMLItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xMLItemWithIdOnly = await prisma.xMLItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XMLItemFindManyArgs>(args?: SelectSubset<T, XMLItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a XMLItem.
     * @param {XMLItemCreateArgs} args - Arguments to create a XMLItem.
     * @example
     * // Create one XMLItem
     * const XMLItem = await prisma.xMLItem.create({
     *   data: {
     *     // ... data to create a XMLItem
     *   }
     * })
     * 
     */
    create<T extends XMLItemCreateArgs>(args: SelectSubset<T, XMLItemCreateArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many XMLItems.
     * @param {XMLItemCreateManyArgs} args - Arguments to create many XMLItems.
     * @example
     * // Create many XMLItems
     * const xMLItem = await prisma.xMLItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XMLItemCreateManyArgs>(args?: SelectSubset<T, XMLItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XMLItems and returns the data saved in the database.
     * @param {XMLItemCreateManyAndReturnArgs} args - Arguments to create many XMLItems.
     * @example
     * // Create many XMLItems
     * const xMLItem = await prisma.xMLItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XMLItems and only return the `id`
     * const xMLItemWithIdOnly = await prisma.xMLItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XMLItemCreateManyAndReturnArgs>(args?: SelectSubset<T, XMLItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a XMLItem.
     * @param {XMLItemDeleteArgs} args - Arguments to delete one XMLItem.
     * @example
     * // Delete one XMLItem
     * const XMLItem = await prisma.xMLItem.delete({
     *   where: {
     *     // ... filter to delete one XMLItem
     *   }
     * })
     * 
     */
    delete<T extends XMLItemDeleteArgs>(args: SelectSubset<T, XMLItemDeleteArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one XMLItem.
     * @param {XMLItemUpdateArgs} args - Arguments to update one XMLItem.
     * @example
     * // Update one XMLItem
     * const xMLItem = await prisma.xMLItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XMLItemUpdateArgs>(args: SelectSubset<T, XMLItemUpdateArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more XMLItems.
     * @param {XMLItemDeleteManyArgs} args - Arguments to filter XMLItems to delete.
     * @example
     * // Delete a few XMLItems
     * const { count } = await prisma.xMLItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XMLItemDeleteManyArgs>(args?: SelectSubset<T, XMLItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XMLItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XMLItems
     * const xMLItem = await prisma.xMLItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XMLItemUpdateManyArgs>(args: SelectSubset<T, XMLItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one XMLItem.
     * @param {XMLItemUpsertArgs} args - Arguments to update or create a XMLItem.
     * @example
     * // Update or create a XMLItem
     * const xMLItem = await prisma.xMLItem.upsert({
     *   create: {
     *     // ... data to create a XMLItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XMLItem we want to update
     *   }
     * })
     */
    upsert<T extends XMLItemUpsertArgs>(args: SelectSubset<T, XMLItemUpsertArgs<ExtArgs>>): Prisma__XMLItemClient<$Result.GetResult<Prisma.$XMLItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of XMLItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemCountArgs} args - Arguments to filter XMLItems to count.
     * @example
     * // Count the number of XMLItems
     * const count = await prisma.xMLItem.count({
     *   where: {
     *     // ... the filter for the XMLItems we want to count
     *   }
     * })
    **/
    count<T extends XMLItemCountArgs>(
      args?: Subset<T, XMLItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XMLItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XMLItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XMLItemAggregateArgs>(args: Subset<T, XMLItemAggregateArgs>): Prisma.PrismaPromise<GetXMLItemAggregateType<T>>

    /**
     * Group by XMLItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XMLItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XMLItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XMLItemGroupByArgs['orderBy'] }
        : { orderBy?: XMLItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XMLItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXMLItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XMLItem model
   */
  readonly fields: XMLItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XMLItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XMLItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    xmlDocument<T extends XMLDocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, XMLDocumentDefaultArgs<ExtArgs>>): Prisma__XMLDocumentClient<$Result.GetResult<Prisma.$XMLDocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XMLItem model
   */ 
  interface XMLItemFieldRefs {
    readonly id: FieldRef<"XMLItem", 'String'>
    readonly xmlDocumentId: FieldRef<"XMLItem", 'String'>
    readonly codigo: FieldRef<"XMLItem", 'String'>
    readonly descricao: FieldRef<"XMLItem", 'String'>
    readonly ncm: FieldRef<"XMLItem", 'String'>
    readonly cfop: FieldRef<"XMLItem", 'String'>
    readonly quantidade: FieldRef<"XMLItem", 'Float'>
    readonly valorUnitario: FieldRef<"XMLItem", 'Float'>
    readonly valorTotal: FieldRef<"XMLItem", 'Float'>
    readonly cst: FieldRef<"XMLItem", 'String'>
    readonly aliquotaIcms: FieldRef<"XMLItem", 'Float'>
    readonly valorIcms: FieldRef<"XMLItem", 'Float'>
    readonly aliquotaIpi: FieldRef<"XMLItem", 'Float'>
    readonly valorIpi: FieldRef<"XMLItem", 'Float'>
    readonly aliquotaPis: FieldRef<"XMLItem", 'Float'>
    readonly valorPis: FieldRef<"XMLItem", 'Float'>
    readonly aliquotaCofins: FieldRef<"XMLItem", 'Float'>
    readonly valorCofins: FieldRef<"XMLItem", 'Float'>
    readonly createdAt: FieldRef<"XMLItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XMLItem findUnique
   */
  export type XMLItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter, which XMLItem to fetch.
     */
    where: XMLItemWhereUniqueInput
  }

  /**
   * XMLItem findUniqueOrThrow
   */
  export type XMLItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter, which XMLItem to fetch.
     */
    where: XMLItemWhereUniqueInput
  }

  /**
   * XMLItem findFirst
   */
  export type XMLItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter, which XMLItem to fetch.
     */
    where?: XMLItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLItems to fetch.
     */
    orderBy?: XMLItemOrderByWithRelationInput | XMLItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XMLItems.
     */
    cursor?: XMLItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XMLItems.
     */
    distinct?: XMLItemScalarFieldEnum | XMLItemScalarFieldEnum[]
  }

  /**
   * XMLItem findFirstOrThrow
   */
  export type XMLItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter, which XMLItem to fetch.
     */
    where?: XMLItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLItems to fetch.
     */
    orderBy?: XMLItemOrderByWithRelationInput | XMLItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XMLItems.
     */
    cursor?: XMLItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XMLItems.
     */
    distinct?: XMLItemScalarFieldEnum | XMLItemScalarFieldEnum[]
  }

  /**
   * XMLItem findMany
   */
  export type XMLItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter, which XMLItems to fetch.
     */
    where?: XMLItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XMLItems to fetch.
     */
    orderBy?: XMLItemOrderByWithRelationInput | XMLItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XMLItems.
     */
    cursor?: XMLItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XMLItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XMLItems.
     */
    skip?: number
    distinct?: XMLItemScalarFieldEnum | XMLItemScalarFieldEnum[]
  }

  /**
   * XMLItem create
   */
  export type XMLItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * The data needed to create a XMLItem.
     */
    data: XOR<XMLItemCreateInput, XMLItemUncheckedCreateInput>
  }

  /**
   * XMLItem createMany
   */
  export type XMLItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XMLItems.
     */
    data: XMLItemCreateManyInput | XMLItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XMLItem createManyAndReturn
   */
  export type XMLItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many XMLItems.
     */
    data: XMLItemCreateManyInput | XMLItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XMLItem update
   */
  export type XMLItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * The data needed to update a XMLItem.
     */
    data: XOR<XMLItemUpdateInput, XMLItemUncheckedUpdateInput>
    /**
     * Choose, which XMLItem to update.
     */
    where: XMLItemWhereUniqueInput
  }

  /**
   * XMLItem updateMany
   */
  export type XMLItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XMLItems.
     */
    data: XOR<XMLItemUpdateManyMutationInput, XMLItemUncheckedUpdateManyInput>
    /**
     * Filter which XMLItems to update
     */
    where?: XMLItemWhereInput
  }

  /**
   * XMLItem upsert
   */
  export type XMLItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * The filter to search for the XMLItem to update in case it exists.
     */
    where: XMLItemWhereUniqueInput
    /**
     * In case the XMLItem found by the `where` argument doesn't exist, create a new XMLItem with this data.
     */
    create: XOR<XMLItemCreateInput, XMLItemUncheckedCreateInput>
    /**
     * In case the XMLItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XMLItemUpdateInput, XMLItemUncheckedUpdateInput>
  }

  /**
   * XMLItem delete
   */
  export type XMLItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
    /**
     * Filter which XMLItem to delete.
     */
    where: XMLItemWhereUniqueInput
  }

  /**
   * XMLItem deleteMany
   */
  export type XMLItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XMLItems to delete
     */
    where?: XMLItemWhereInput
  }

  /**
   * XMLItem without action
   */
  export type XMLItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XMLItem
     */
    select?: XMLItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XMLItemInclude<ExtArgs> | null
  }


  /**
   * Model Processamento
   */

  export type AggregateProcessamento = {
    _count: ProcessamentoCountAggregateOutputType | null
    _min: ProcessamentoMinAggregateOutputType | null
    _max: ProcessamentoMaxAggregateOutputType | null
  }

  export type ProcessamentoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    documentoId: string | null
    status: $Enums.ProcessamentoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessamentoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    documentoId: string | null
    status: $Enums.ProcessamentoStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessamentoCountAggregateOutputType = {
    id: number
    userId: number
    documentoId: number
    status: number
    resultado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessamentoMinAggregateInputType = {
    id?: true
    userId?: true
    documentoId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessamentoMaxAggregateInputType = {
    id?: true
    userId?: true
    documentoId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessamentoCountAggregateInputType = {
    id?: true
    userId?: true
    documentoId?: true
    status?: true
    resultado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processamento to aggregate.
     */
    where?: ProcessamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processamentos to fetch.
     */
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processamentos
    **/
    _count?: true | ProcessamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessamentoMaxAggregateInputType
  }

  export type GetProcessamentoAggregateType<T extends ProcessamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessamento[P]>
      : GetScalarType<T[P], AggregateProcessamento[P]>
  }




  export type ProcessamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessamentoWhereInput
    orderBy?: ProcessamentoOrderByWithAggregationInput | ProcessamentoOrderByWithAggregationInput[]
    by: ProcessamentoScalarFieldEnum[] | ProcessamentoScalarFieldEnum
    having?: ProcessamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessamentoCountAggregateInputType | true
    _min?: ProcessamentoMinAggregateInputType
    _max?: ProcessamentoMaxAggregateInputType
  }

  export type ProcessamentoGroupByOutputType = {
    id: string
    userId: string
    documentoId: string
    status: $Enums.ProcessamentoStatus
    resultado: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProcessamentoCountAggregateOutputType | null
    _min: ProcessamentoMinAggregateOutputType | null
    _max: ProcessamentoMaxAggregateOutputType | null
  }

  type GetProcessamentoGroupByPayload<T extends ProcessamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessamentoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessamentoGroupByOutputType[P]>
        }
      >
    >


  export type ProcessamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    documentoId?: boolean
    status?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    documento?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processamento"]>

  export type ProcessamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    documentoId?: boolean
    status?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    documento?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processamento"]>

  export type ProcessamentoSelectScalar = {
    id?: boolean
    userId?: boolean
    documentoId?: boolean
    status?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    documento?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type ProcessamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    documento?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $ProcessamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Processamento"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      documento: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      documentoId: string
      status: $Enums.ProcessamentoStatus
      resultado: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["processamento"]>
    composites: {}
  }

  type ProcessamentoGetPayload<S extends boolean | null | undefined | ProcessamentoDefaultArgs> = $Result.GetResult<Prisma.$ProcessamentoPayload, S>

  type ProcessamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcessamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcessamentoCountAggregateInputType | true
    }

  export interface ProcessamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Processamento'], meta: { name: 'Processamento' } }
    /**
     * Find zero or one Processamento that matches the filter.
     * @param {ProcessamentoFindUniqueArgs} args - Arguments to find a Processamento
     * @example
     * // Get one Processamento
     * const processamento = await prisma.processamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessamentoFindUniqueArgs>(args: SelectSubset<T, ProcessamentoFindUniqueArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Processamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcessamentoFindUniqueOrThrowArgs} args - Arguments to find a Processamento
     * @example
     * // Get one Processamento
     * const processamento = await prisma.processamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Processamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoFindFirstArgs} args - Arguments to find a Processamento
     * @example
     * // Get one Processamento
     * const processamento = await prisma.processamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessamentoFindFirstArgs>(args?: SelectSubset<T, ProcessamentoFindFirstArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Processamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoFindFirstOrThrowArgs} args - Arguments to find a Processamento
     * @example
     * // Get one Processamento
     * const processamento = await prisma.processamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Processamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processamentos
     * const processamentos = await prisma.processamento.findMany()
     * 
     * // Get first 10 Processamentos
     * const processamentos = await prisma.processamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processamentoWithIdOnly = await prisma.processamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessamentoFindManyArgs>(args?: SelectSubset<T, ProcessamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Processamento.
     * @param {ProcessamentoCreateArgs} args - Arguments to create a Processamento.
     * @example
     * // Create one Processamento
     * const Processamento = await prisma.processamento.create({
     *   data: {
     *     // ... data to create a Processamento
     *   }
     * })
     * 
     */
    create<T extends ProcessamentoCreateArgs>(args: SelectSubset<T, ProcessamentoCreateArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Processamentos.
     * @param {ProcessamentoCreateManyArgs} args - Arguments to create many Processamentos.
     * @example
     * // Create many Processamentos
     * const processamento = await prisma.processamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessamentoCreateManyArgs>(args?: SelectSubset<T, ProcessamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Processamentos and returns the data saved in the database.
     * @param {ProcessamentoCreateManyAndReturnArgs} args - Arguments to create many Processamentos.
     * @example
     * // Create many Processamentos
     * const processamento = await prisma.processamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Processamentos and only return the `id`
     * const processamentoWithIdOnly = await prisma.processamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Processamento.
     * @param {ProcessamentoDeleteArgs} args - Arguments to delete one Processamento.
     * @example
     * // Delete one Processamento
     * const Processamento = await prisma.processamento.delete({
     *   where: {
     *     // ... filter to delete one Processamento
     *   }
     * })
     * 
     */
    delete<T extends ProcessamentoDeleteArgs>(args: SelectSubset<T, ProcessamentoDeleteArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Processamento.
     * @param {ProcessamentoUpdateArgs} args - Arguments to update one Processamento.
     * @example
     * // Update one Processamento
     * const processamento = await prisma.processamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessamentoUpdateArgs>(args: SelectSubset<T, ProcessamentoUpdateArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Processamentos.
     * @param {ProcessamentoDeleteManyArgs} args - Arguments to filter Processamentos to delete.
     * @example
     * // Delete a few Processamentos
     * const { count } = await prisma.processamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessamentoDeleteManyArgs>(args?: SelectSubset<T, ProcessamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processamentos
     * const processamento = await prisma.processamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessamentoUpdateManyArgs>(args: SelectSubset<T, ProcessamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Processamento.
     * @param {ProcessamentoUpsertArgs} args - Arguments to update or create a Processamento.
     * @example
     * // Update or create a Processamento
     * const processamento = await prisma.processamento.upsert({
     *   create: {
     *     // ... data to create a Processamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Processamento we want to update
     *   }
     * })
     */
    upsert<T extends ProcessamentoUpsertArgs>(args: SelectSubset<T, ProcessamentoUpsertArgs<ExtArgs>>): Prisma__ProcessamentoClient<$Result.GetResult<Prisma.$ProcessamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Processamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoCountArgs} args - Arguments to filter Processamentos to count.
     * @example
     * // Count the number of Processamentos
     * const count = await prisma.processamento.count({
     *   where: {
     *     // ... the filter for the Processamentos we want to count
     *   }
     * })
    **/
    count<T extends ProcessamentoCountArgs>(
      args?: Subset<T, ProcessamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Processamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessamentoAggregateArgs>(args: Subset<T, ProcessamentoAggregateArgs>): Prisma.PrismaPromise<GetProcessamentoAggregateType<T>>

    /**
     * Group by Processamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessamentoGroupByArgs['orderBy'] }
        : { orderBy?: ProcessamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Processamento model
   */
  readonly fields: ProcessamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Processamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documento<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Processamento model
   */ 
  interface ProcessamentoFieldRefs {
    readonly id: FieldRef<"Processamento", 'String'>
    readonly userId: FieldRef<"Processamento", 'String'>
    readonly documentoId: FieldRef<"Processamento", 'String'>
    readonly status: FieldRef<"Processamento", 'ProcessamentoStatus'>
    readonly resultado: FieldRef<"Processamento", 'Json'>
    readonly createdAt: FieldRef<"Processamento", 'DateTime'>
    readonly updatedAt: FieldRef<"Processamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Processamento findUnique
   */
  export type ProcessamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter, which Processamento to fetch.
     */
    where: ProcessamentoWhereUniqueInput
  }

  /**
   * Processamento findUniqueOrThrow
   */
  export type ProcessamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter, which Processamento to fetch.
     */
    where: ProcessamentoWhereUniqueInput
  }

  /**
   * Processamento findFirst
   */
  export type ProcessamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter, which Processamento to fetch.
     */
    where?: ProcessamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processamentos to fetch.
     */
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processamentos.
     */
    cursor?: ProcessamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processamentos.
     */
    distinct?: ProcessamentoScalarFieldEnum | ProcessamentoScalarFieldEnum[]
  }

  /**
   * Processamento findFirstOrThrow
   */
  export type ProcessamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter, which Processamento to fetch.
     */
    where?: ProcessamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processamentos to fetch.
     */
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processamentos.
     */
    cursor?: ProcessamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processamentos.
     */
    distinct?: ProcessamentoScalarFieldEnum | ProcessamentoScalarFieldEnum[]
  }

  /**
   * Processamento findMany
   */
  export type ProcessamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter, which Processamentos to fetch.
     */
    where?: ProcessamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processamentos to fetch.
     */
    orderBy?: ProcessamentoOrderByWithRelationInput | ProcessamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processamentos.
     */
    cursor?: ProcessamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processamentos.
     */
    skip?: number
    distinct?: ProcessamentoScalarFieldEnum | ProcessamentoScalarFieldEnum[]
  }

  /**
   * Processamento create
   */
  export type ProcessamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Processamento.
     */
    data: XOR<ProcessamentoCreateInput, ProcessamentoUncheckedCreateInput>
  }

  /**
   * Processamento createMany
   */
  export type ProcessamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processamentos.
     */
    data: ProcessamentoCreateManyInput | ProcessamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Processamento createManyAndReturn
   */
  export type ProcessamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Processamentos.
     */
    data: ProcessamentoCreateManyInput | ProcessamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Processamento update
   */
  export type ProcessamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Processamento.
     */
    data: XOR<ProcessamentoUpdateInput, ProcessamentoUncheckedUpdateInput>
    /**
     * Choose, which Processamento to update.
     */
    where: ProcessamentoWhereUniqueInput
  }

  /**
   * Processamento updateMany
   */
  export type ProcessamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processamentos.
     */
    data: XOR<ProcessamentoUpdateManyMutationInput, ProcessamentoUncheckedUpdateManyInput>
    /**
     * Filter which Processamentos to update
     */
    where?: ProcessamentoWhereInput
  }

  /**
   * Processamento upsert
   */
  export type ProcessamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Processamento to update in case it exists.
     */
    where: ProcessamentoWhereUniqueInput
    /**
     * In case the Processamento found by the `where` argument doesn't exist, create a new Processamento with this data.
     */
    create: XOR<ProcessamentoCreateInput, ProcessamentoUncheckedCreateInput>
    /**
     * In case the Processamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessamentoUpdateInput, ProcessamentoUncheckedUpdateInput>
  }

  /**
   * Processamento delete
   */
  export type ProcessamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
    /**
     * Filter which Processamento to delete.
     */
    where: ProcessamentoWhereUniqueInput
  }

  /**
   * Processamento deleteMany
   */
  export type ProcessamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processamentos to delete
     */
    where?: ProcessamentoWhereInput
  }

  /**
   * Processamento without action
   */
  export type ProcessamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Processamento
     */
    select?: ProcessamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessamentoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const EmpresaScalarFieldEnum: {
    id: 'id',
    cnpj: 'cnpj',
    razaoSocial: 'razaoSocial',
    nomeFantasia: 'nomeFantasia',
    ie: 'ie',
    im: 'im',
    cnae: 'cnae',
    endereco: 'endereco',
    regimeTributario: 'regimeTributario',
    dataCadastro: 'dataCadastro',
    updatedAt: 'updatedAt'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    filename: 'filename',
    originalName: 'originalName',
    path: 'path',
    size: 'size',
    mimeType: 'mimeType',
    status: 'status',
    metadata: 'metadata',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const AIProcessingResultScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    model: 'model',
    tokens: 'tokens',
    processingTime: 'processingTime',
    result: 'result',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type AIProcessingResultScalarFieldEnum = (typeof AIProcessingResultScalarFieldEnum)[keyof typeof AIProcessingResultScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    message: 'message',
    metadata: 'metadata',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const CacheEntryScalarFieldEnum: {
    key: 'key',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type CacheEntryScalarFieldEnum = (typeof CacheEntryScalarFieldEnum)[keyof typeof CacheEntryScalarFieldEnum]


  export const SpedContribuicoesItemScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    empresaId: 'empresaId',
    documento: 'documento',
    data: 'data',
    cnpj: 'cnpj',
    produto: 'produto',
    cfop: 'cfop',
    cst: 'cst',
    valor: 'valor',
    basePis: 'basePis',
    valorPis: 'valorPis',
    baseCofins: 'baseCofins',
    valorCofins: 'valorCofins',
    createdAt: 'createdAt'
  };

  export type SpedContribuicoesItemScalarFieldEnum = (typeof SpedContribuicoesItemScalarFieldEnum)[keyof typeof SpedContribuicoesItemScalarFieldEnum]


  export const SpedContribuicoesApuracaoScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    empresaId: 'empresaId',
    tipo: 'tipo',
    periodo: 'periodo',
    base: 'base',
    aliquota: 'aliquota',
    valor: 'valor',
    createdAt: 'createdAt'
  };

  export type SpedContribuicoesApuracaoScalarFieldEnum = (typeof SpedContribuicoesApuracaoScalarFieldEnum)[keyof typeof SpedContribuicoesApuracaoScalarFieldEnum]


  export const SpedFiscalItemScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    empresaId: 'empresaId',
    documento: 'documento',
    data: 'data',
    cnpj: 'cnpj',
    produto: 'produto',
    cfop: 'cfop',
    cst: 'cst',
    ncm: 'ncm',
    valor: 'valor',
    baseIcms: 'baseIcms',
    valorIcms: 'valorIcms',
    baseIpi: 'baseIpi',
    valorIpi: 'valorIpi',
    createdAt: 'createdAt'
  };

  export type SpedFiscalItemScalarFieldEnum = (typeof SpedFiscalItemScalarFieldEnum)[keyof typeof SpedFiscalItemScalarFieldEnum]


  export const SpedFiscalApuracaoScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    empresaId: 'empresaId',
    cst: 'cst',
    cfop: 'cfop',
    aliquota: 'aliquota',
    valorOperacao: 'valorOperacao',
    baseIcms: 'baseIcms',
    valorIcms: 'valorIcms',
    baseIcmsSt: 'baseIcmsSt',
    valorIcmsSt: 'valorIcmsSt',
    valorRedBc: 'valorRedBc',
    valorIpi: 'valorIpi',
    createdAt: 'createdAt'
  };

  export type SpedFiscalApuracaoScalarFieldEnum = (typeof SpedFiscalApuracaoScalarFieldEnum)[keyof typeof SpedFiscalApuracaoScalarFieldEnum]


  export const XMLDocumentScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    empresaId: 'empresaId',
    tipoDocumento: 'tipoDocumento',
    numeroDocumento: 'numeroDocumento',
    serie: 'serie',
    dataEmissao: 'dataEmissao',
    valorTotal: 'valorTotal',
    cnpjEmitente: 'cnpjEmitente',
    cnpjDestinatario: 'cnpjDestinatario',
    cpfDestinatario: 'cpfDestinatario',
    chaveAcesso: 'chaveAcesso',
    protocolo: 'protocolo',
    status: 'status',
    observacoes: 'observacoes',
    valorTotalIcms: 'valorTotalIcms',
    valorTotalIpi: 'valorTotalIpi',
    valorTotalPis: 'valorTotalPis',
    valorTotalCofins: 'valorTotalCofins',
    valorTotalIss: 'valorTotalIss',
    baseCalculoIcms: 'baseCalculoIcms',
    baseCalculoPis: 'baseCalculoPis',
    baseCalculoCofins: 'baseCalculoCofins',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XMLDocumentScalarFieldEnum = (typeof XMLDocumentScalarFieldEnum)[keyof typeof XMLDocumentScalarFieldEnum]


  export const XMLItemScalarFieldEnum: {
    id: 'id',
    xmlDocumentId: 'xmlDocumentId',
    codigo: 'codigo',
    descricao: 'descricao',
    ncm: 'ncm',
    cfop: 'cfop',
    quantidade: 'quantidade',
    valorUnitario: 'valorUnitario',
    valorTotal: 'valorTotal',
    cst: 'cst',
    aliquotaIcms: 'aliquotaIcms',
    valorIcms: 'valorIcms',
    aliquotaIpi: 'aliquotaIpi',
    valorIpi: 'valorIpi',
    aliquotaPis: 'aliquotaPis',
    valorPis: 'valorPis',
    aliquotaCofins: 'aliquotaCofins',
    valorCofins: 'valorCofins',
    createdAt: 'createdAt'
  };

  export type XMLItemScalarFieldEnum = (typeof XMLItemScalarFieldEnum)[keyof typeof XMLItemScalarFieldEnum]


  export const ProcessamentoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    documentoId: 'documentoId',
    status: 'status',
    resultado: 'resultado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessamentoScalarFieldEnum = (typeof ProcessamentoScalarFieldEnum)[keyof typeof ProcessamentoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProcessamentoStatus'
   */
  export type EnumProcessamentoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessamentoStatus'>
    


  /**
   * Reference to a field of type 'ProcessamentoStatus[]'
   */
  export type ListEnumProcessamentoStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessamentoStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    documents?: DocumentListRelationFilter
    processamentos?: ProcessamentoListRelationFilter
    sessions?: SessionListRelationFilter
    logs?: LogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: DocumentOrderByRelationAggregateInput
    processamentos?: ProcessamentoOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    documents?: DocumentListRelationFilter
    processamentos?: ProcessamentoListRelationFilter
    sessions?: SessionListRelationFilter
    logs?: LogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id?: StringFilter<"Empresa"> | string
    cnpj?: StringFilter<"Empresa"> | string
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    ie?: StringNullableFilter<"Empresa"> | string | null
    im?: StringNullableFilter<"Empresa"> | string | null
    cnae?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    regimeTributario?: StringNullableFilter<"Empresa"> | string | null
    dataCadastro?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
    documentos?: DocumentListRelationFilter
    spedContribuicoesItems?: SpedContribuicoesItemListRelationFilter
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoListRelationFilter
    spedFiscalItems?: SpedFiscalItemListRelationFilter
    spedFiscalApuracao?: SpedFiscalApuracaoListRelationFilter
    xmlDocuments?: XMLDocumentListRelationFilter
  }

  export type EmpresaOrderByWithRelationInput = {
    id?: SortOrder
    cnpj?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    ie?: SortOrderInput | SortOrder
    im?: SortOrderInput | SortOrder
    cnae?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    regimeTributario?: SortOrderInput | SortOrder
    dataCadastro?: SortOrder
    updatedAt?: SortOrder
    documentos?: DocumentOrderByRelationAggregateInput
    spedContribuicoesItems?: SpedContribuicoesItemOrderByRelationAggregateInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoOrderByRelationAggregateInput
    spedFiscalItems?: SpedFiscalItemOrderByRelationAggregateInput
    spedFiscalApuracao?: SpedFiscalApuracaoOrderByRelationAggregateInput
    xmlDocuments?: XMLDocumentOrderByRelationAggregateInput
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    ie?: StringNullableFilter<"Empresa"> | string | null
    im?: StringNullableFilter<"Empresa"> | string | null
    cnae?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    regimeTributario?: StringNullableFilter<"Empresa"> | string | null
    dataCadastro?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
    documentos?: DocumentListRelationFilter
    spedContribuicoesItems?: SpedContribuicoesItemListRelationFilter
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoListRelationFilter
    spedFiscalItems?: SpedFiscalItemListRelationFilter
    spedFiscalApuracao?: SpedFiscalApuracaoListRelationFilter
    xmlDocuments?: XMLDocumentListRelationFilter
  }, "id" | "cnpj">

  export type EmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    cnpj?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    ie?: SortOrderInput | SortOrder
    im?: SortOrderInput | SortOrder
    cnae?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    regimeTributario?: SortOrderInput | SortOrder
    dataCadastro?: SortOrder
    updatedAt?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Empresa"> | string
    cnpj?: StringWithAggregatesFilter<"Empresa"> | string
    razaoSocial?: StringWithAggregatesFilter<"Empresa"> | string
    nomeFantasia?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    ie?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    im?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cnae?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    endereco?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    regimeTributario?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    dataCadastro?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    metadata?: JsonNullableFilter<"Document">
    empresaId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    empresa?: XOR<EmpresaNullableRelationFilter, EmpresaWhereInput> | null
    processamentos?: ProcessamentoListRelationFilter
    aiResults?: AIProcessingResultListRelationFilter
    xmlDocuments?: XMLDocumentListRelationFilter
    spedContribuicoesItems?: SpedContribuicoesItemListRelationFilter
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoListRelationFilter
    spedFiscalItems?: SpedFiscalItemListRelationFilter
    spedFiscalApuracoes?: SpedFiscalApuracaoListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    empresaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
    processamentos?: ProcessamentoOrderByRelationAggregateInput
    aiResults?: AIProcessingResultOrderByRelationAggregateInput
    xmlDocuments?: XMLDocumentOrderByRelationAggregateInput
    spedContribuicoesItems?: SpedContribuicoesItemOrderByRelationAggregateInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoOrderByRelationAggregateInput
    spedFiscalItems?: SpedFiscalItemOrderByRelationAggregateInput
    spedFiscalApuracoes?: SpedFiscalApuracaoOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    metadata?: JsonNullableFilter<"Document">
    empresaId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    empresa?: XOR<EmpresaNullableRelationFilter, EmpresaWhereInput> | null
    processamentos?: ProcessamentoListRelationFilter
    aiResults?: AIProcessingResultListRelationFilter
    xmlDocuments?: XMLDocumentListRelationFilter
    spedContribuicoesItems?: SpedContribuicoesItemListRelationFilter
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoListRelationFilter
    spedFiscalItems?: SpedFiscalItemListRelationFilter
    spedFiscalApuracoes?: SpedFiscalApuracaoListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    empresaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringWithAggregatesFilter<"Document"> | string
    filename?: StringWithAggregatesFilter<"Document"> | string
    originalName?: StringWithAggregatesFilter<"Document"> | string
    path?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    empresaId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type AIProcessingResultWhereInput = {
    AND?: AIProcessingResultWhereInput | AIProcessingResultWhereInput[]
    OR?: AIProcessingResultWhereInput[]
    NOT?: AIProcessingResultWhereInput | AIProcessingResultWhereInput[]
    id?: StringFilter<"AIProcessingResult"> | string
    documentId?: StringFilter<"AIProcessingResult"> | string
    model?: StringFilter<"AIProcessingResult"> | string
    tokens?: IntFilter<"AIProcessingResult"> | number
    processingTime?: IntFilter<"AIProcessingResult"> | number
    result?: JsonFilter<"AIProcessingResult">
    error?: StringNullableFilter<"AIProcessingResult"> | string | null
    createdAt?: DateTimeFilter<"AIProcessingResult"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type AIProcessingResultOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    tokens?: SortOrder
    processingTime?: SortOrder
    result?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type AIProcessingResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIProcessingResultWhereInput | AIProcessingResultWhereInput[]
    OR?: AIProcessingResultWhereInput[]
    NOT?: AIProcessingResultWhereInput | AIProcessingResultWhereInput[]
    documentId?: StringFilter<"AIProcessingResult"> | string
    model?: StringFilter<"AIProcessingResult"> | string
    tokens?: IntFilter<"AIProcessingResult"> | number
    processingTime?: IntFilter<"AIProcessingResult"> | number
    result?: JsonFilter<"AIProcessingResult">
    error?: StringNullableFilter<"AIProcessingResult"> | string | null
    createdAt?: DateTimeFilter<"AIProcessingResult"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type AIProcessingResultOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    tokens?: SortOrder
    processingTime?: SortOrder
    result?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIProcessingResultCountOrderByAggregateInput
    _avg?: AIProcessingResultAvgOrderByAggregateInput
    _max?: AIProcessingResultMaxOrderByAggregateInput
    _min?: AIProcessingResultMinOrderByAggregateInput
    _sum?: AIProcessingResultSumOrderByAggregateInput
  }

  export type AIProcessingResultScalarWhereWithAggregatesInput = {
    AND?: AIProcessingResultScalarWhereWithAggregatesInput | AIProcessingResultScalarWhereWithAggregatesInput[]
    OR?: AIProcessingResultScalarWhereWithAggregatesInput[]
    NOT?: AIProcessingResultScalarWhereWithAggregatesInput | AIProcessingResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIProcessingResult"> | string
    documentId?: StringWithAggregatesFilter<"AIProcessingResult"> | string
    model?: StringWithAggregatesFilter<"AIProcessingResult"> | string
    tokens?: IntWithAggregatesFilter<"AIProcessingResult"> | number
    processingTime?: IntWithAggregatesFilter<"AIProcessingResult"> | number
    result?: JsonWithAggregatesFilter<"AIProcessingResult">
    error?: StringNullableWithAggregatesFilter<"AIProcessingResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIProcessingResult"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    level?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    message?: StringFilter<"Log"> | string
    metadata?: JsonNullableFilter<"Log">
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    level?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    message?: StringFilter<"Log"> | string
    metadata?: JsonNullableFilter<"Log">
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    level?: EnumLogLevelWithAggregatesFilter<"Log"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"Log"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Log">
    userId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
  }

  export type CacheEntryWhereInput = {
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    key?: StringFilter<"CacheEntry"> | string
    value?: StringFilter<"CacheEntry"> | string
    expiresAt?: DateTimeFilter<"CacheEntry"> | Date | string
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
  }

  export type CacheEntryOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CacheEntryWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    value?: StringFilter<"CacheEntry"> | string
    expiresAt?: DateTimeFilter<"CacheEntry"> | Date | string
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
  }, "key">

  export type CacheEntryOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: CacheEntryCountOrderByAggregateInput
    _max?: CacheEntryMaxOrderByAggregateInput
    _min?: CacheEntryMinOrderByAggregateInput
  }

  export type CacheEntryScalarWhereWithAggregatesInput = {
    AND?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    OR?: CacheEntryScalarWhereWithAggregatesInput[]
    NOT?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"CacheEntry"> | string
    value?: StringWithAggregatesFilter<"CacheEntry"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
  }

  export type SpedContribuicoesItemWhereInput = {
    AND?: SpedContribuicoesItemWhereInput | SpedContribuicoesItemWhereInput[]
    OR?: SpedContribuicoesItemWhereInput[]
    NOT?: SpedContribuicoesItemWhereInput | SpedContribuicoesItemWhereInput[]
    id?: StringFilter<"SpedContribuicoesItem"> | string
    documentId?: StringFilter<"SpedContribuicoesItem"> | string
    empresaId?: StringFilter<"SpedContribuicoesItem"> | string
    documento?: StringFilter<"SpedContribuicoesItem"> | string
    data?: StringFilter<"SpedContribuicoesItem"> | string
    cnpj?: StringFilter<"SpedContribuicoesItem"> | string
    produto?: StringFilter<"SpedContribuicoesItem"> | string
    cfop?: StringFilter<"SpedContribuicoesItem"> | string
    cst?: StringFilter<"SpedContribuicoesItem"> | string
    valor?: FloatFilter<"SpedContribuicoesItem"> | number
    basePis?: FloatFilter<"SpedContribuicoesItem"> | number
    valorPis?: FloatFilter<"SpedContribuicoesItem"> | number
    baseCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    valorCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type SpedContribuicoesItemOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type SpedContribuicoesItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpedContribuicoesItemWhereInput | SpedContribuicoesItemWhereInput[]
    OR?: SpedContribuicoesItemWhereInput[]
    NOT?: SpedContribuicoesItemWhereInput | SpedContribuicoesItemWhereInput[]
    documentId?: StringFilter<"SpedContribuicoesItem"> | string
    empresaId?: StringFilter<"SpedContribuicoesItem"> | string
    documento?: StringFilter<"SpedContribuicoesItem"> | string
    data?: StringFilter<"SpedContribuicoesItem"> | string
    cnpj?: StringFilter<"SpedContribuicoesItem"> | string
    produto?: StringFilter<"SpedContribuicoesItem"> | string
    cfop?: StringFilter<"SpedContribuicoesItem"> | string
    cst?: StringFilter<"SpedContribuicoesItem"> | string
    valor?: FloatFilter<"SpedContribuicoesItem"> | number
    basePis?: FloatFilter<"SpedContribuicoesItem"> | number
    valorPis?: FloatFilter<"SpedContribuicoesItem"> | number
    baseCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    valorCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type SpedContribuicoesItemOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
    _count?: SpedContribuicoesItemCountOrderByAggregateInput
    _avg?: SpedContribuicoesItemAvgOrderByAggregateInput
    _max?: SpedContribuicoesItemMaxOrderByAggregateInput
    _min?: SpedContribuicoesItemMinOrderByAggregateInput
    _sum?: SpedContribuicoesItemSumOrderByAggregateInput
  }

  export type SpedContribuicoesItemScalarWhereWithAggregatesInput = {
    AND?: SpedContribuicoesItemScalarWhereWithAggregatesInput | SpedContribuicoesItemScalarWhereWithAggregatesInput[]
    OR?: SpedContribuicoesItemScalarWhereWithAggregatesInput[]
    NOT?: SpedContribuicoesItemScalarWhereWithAggregatesInput | SpedContribuicoesItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    documentId?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    empresaId?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    documento?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    data?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    cnpj?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    produto?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    cfop?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    cst?: StringWithAggregatesFilter<"SpedContribuicoesItem"> | string
    valor?: FloatWithAggregatesFilter<"SpedContribuicoesItem"> | number
    basePis?: FloatWithAggregatesFilter<"SpedContribuicoesItem"> | number
    valorPis?: FloatWithAggregatesFilter<"SpedContribuicoesItem"> | number
    baseCofins?: FloatWithAggregatesFilter<"SpedContribuicoesItem"> | number
    valorCofins?: FloatWithAggregatesFilter<"SpedContribuicoesItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpedContribuicoesItem"> | Date | string
  }

  export type SpedContribuicoesApuracaoWhereInput = {
    AND?: SpedContribuicoesApuracaoWhereInput | SpedContribuicoesApuracaoWhereInput[]
    OR?: SpedContribuicoesApuracaoWhereInput[]
    NOT?: SpedContribuicoesApuracaoWhereInput | SpedContribuicoesApuracaoWhereInput[]
    id?: StringFilter<"SpedContribuicoesApuracao"> | string
    documentId?: StringFilter<"SpedContribuicoesApuracao"> | string
    empresaId?: StringFilter<"SpedContribuicoesApuracao"> | string
    tipo?: StringFilter<"SpedContribuicoesApuracao"> | string
    periodo?: StringFilter<"SpedContribuicoesApuracao"> | string
    base?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    aliquota?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    valor?: FloatFilter<"SpedContribuicoesApuracao"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesApuracao"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type SpedContribuicoesApuracaoOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipo?: SortOrder
    periodo?: SortOrder
    base?: SortOrderInput | SortOrder
    aliquota?: SortOrderInput | SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type SpedContribuicoesApuracaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpedContribuicoesApuracaoWhereInput | SpedContribuicoesApuracaoWhereInput[]
    OR?: SpedContribuicoesApuracaoWhereInput[]
    NOT?: SpedContribuicoesApuracaoWhereInput | SpedContribuicoesApuracaoWhereInput[]
    documentId?: StringFilter<"SpedContribuicoesApuracao"> | string
    empresaId?: StringFilter<"SpedContribuicoesApuracao"> | string
    tipo?: StringFilter<"SpedContribuicoesApuracao"> | string
    periodo?: StringFilter<"SpedContribuicoesApuracao"> | string
    base?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    aliquota?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    valor?: FloatFilter<"SpedContribuicoesApuracao"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesApuracao"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type SpedContribuicoesApuracaoOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipo?: SortOrder
    periodo?: SortOrder
    base?: SortOrderInput | SortOrder
    aliquota?: SortOrderInput | SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
    _count?: SpedContribuicoesApuracaoCountOrderByAggregateInput
    _avg?: SpedContribuicoesApuracaoAvgOrderByAggregateInput
    _max?: SpedContribuicoesApuracaoMaxOrderByAggregateInput
    _min?: SpedContribuicoesApuracaoMinOrderByAggregateInput
    _sum?: SpedContribuicoesApuracaoSumOrderByAggregateInput
  }

  export type SpedContribuicoesApuracaoScalarWhereWithAggregatesInput = {
    AND?: SpedContribuicoesApuracaoScalarWhereWithAggregatesInput | SpedContribuicoesApuracaoScalarWhereWithAggregatesInput[]
    OR?: SpedContribuicoesApuracaoScalarWhereWithAggregatesInput[]
    NOT?: SpedContribuicoesApuracaoScalarWhereWithAggregatesInput | SpedContribuicoesApuracaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpedContribuicoesApuracao"> | string
    documentId?: StringWithAggregatesFilter<"SpedContribuicoesApuracao"> | string
    empresaId?: StringWithAggregatesFilter<"SpedContribuicoesApuracao"> | string
    tipo?: StringWithAggregatesFilter<"SpedContribuicoesApuracao"> | string
    periodo?: StringWithAggregatesFilter<"SpedContribuicoesApuracao"> | string
    base?: FloatNullableWithAggregatesFilter<"SpedContribuicoesApuracao"> | number | null
    aliquota?: FloatNullableWithAggregatesFilter<"SpedContribuicoesApuracao"> | number | null
    valor?: FloatWithAggregatesFilter<"SpedContribuicoesApuracao"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpedContribuicoesApuracao"> | Date | string
  }

  export type SpedFiscalItemWhereInput = {
    AND?: SpedFiscalItemWhereInput | SpedFiscalItemWhereInput[]
    OR?: SpedFiscalItemWhereInput[]
    NOT?: SpedFiscalItemWhereInput | SpedFiscalItemWhereInput[]
    id?: StringFilter<"SpedFiscalItem"> | string
    documentId?: StringFilter<"SpedFiscalItem"> | string
    empresaId?: StringFilter<"SpedFiscalItem"> | string
    documento?: StringFilter<"SpedFiscalItem"> | string
    data?: StringFilter<"SpedFiscalItem"> | string
    cnpj?: StringFilter<"SpedFiscalItem"> | string
    produto?: StringFilter<"SpedFiscalItem"> | string
    cfop?: StringFilter<"SpedFiscalItem"> | string
    cst?: StringFilter<"SpedFiscalItem"> | string
    ncm?: StringFilter<"SpedFiscalItem"> | string
    valor?: FloatFilter<"SpedFiscalItem"> | number
    baseIcms?: FloatFilter<"SpedFiscalItem"> | number
    valorIcms?: FloatFilter<"SpedFiscalItem"> | number
    baseIpi?: FloatFilter<"SpedFiscalItem"> | number
    valorIpi?: FloatFilter<"SpedFiscalItem"> | number
    createdAt?: DateTimeFilter<"SpedFiscalItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type SpedFiscalItemOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    ncm?: SortOrder
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type SpedFiscalItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpedFiscalItemWhereInput | SpedFiscalItemWhereInput[]
    OR?: SpedFiscalItemWhereInput[]
    NOT?: SpedFiscalItemWhereInput | SpedFiscalItemWhereInput[]
    documentId?: StringFilter<"SpedFiscalItem"> | string
    empresaId?: StringFilter<"SpedFiscalItem"> | string
    documento?: StringFilter<"SpedFiscalItem"> | string
    data?: StringFilter<"SpedFiscalItem"> | string
    cnpj?: StringFilter<"SpedFiscalItem"> | string
    produto?: StringFilter<"SpedFiscalItem"> | string
    cfop?: StringFilter<"SpedFiscalItem"> | string
    cst?: StringFilter<"SpedFiscalItem"> | string
    ncm?: StringFilter<"SpedFiscalItem"> | string
    valor?: FloatFilter<"SpedFiscalItem"> | number
    baseIcms?: FloatFilter<"SpedFiscalItem"> | number
    valorIcms?: FloatFilter<"SpedFiscalItem"> | number
    baseIpi?: FloatFilter<"SpedFiscalItem"> | number
    valorIpi?: FloatFilter<"SpedFiscalItem"> | number
    createdAt?: DateTimeFilter<"SpedFiscalItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type SpedFiscalItemOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    ncm?: SortOrder
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
    _count?: SpedFiscalItemCountOrderByAggregateInput
    _avg?: SpedFiscalItemAvgOrderByAggregateInput
    _max?: SpedFiscalItemMaxOrderByAggregateInput
    _min?: SpedFiscalItemMinOrderByAggregateInput
    _sum?: SpedFiscalItemSumOrderByAggregateInput
  }

  export type SpedFiscalItemScalarWhereWithAggregatesInput = {
    AND?: SpedFiscalItemScalarWhereWithAggregatesInput | SpedFiscalItemScalarWhereWithAggregatesInput[]
    OR?: SpedFiscalItemScalarWhereWithAggregatesInput[]
    NOT?: SpedFiscalItemScalarWhereWithAggregatesInput | SpedFiscalItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    documentId?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    empresaId?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    documento?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    data?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    cnpj?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    produto?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    cfop?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    cst?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    ncm?: StringWithAggregatesFilter<"SpedFiscalItem"> | string
    valor?: FloatWithAggregatesFilter<"SpedFiscalItem"> | number
    baseIcms?: FloatWithAggregatesFilter<"SpedFiscalItem"> | number
    valorIcms?: FloatWithAggregatesFilter<"SpedFiscalItem"> | number
    baseIpi?: FloatWithAggregatesFilter<"SpedFiscalItem"> | number
    valorIpi?: FloatWithAggregatesFilter<"SpedFiscalItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpedFiscalItem"> | Date | string
  }

  export type SpedFiscalApuracaoWhereInput = {
    AND?: SpedFiscalApuracaoWhereInput | SpedFiscalApuracaoWhereInput[]
    OR?: SpedFiscalApuracaoWhereInput[]
    NOT?: SpedFiscalApuracaoWhereInput | SpedFiscalApuracaoWhereInput[]
    id?: StringFilter<"SpedFiscalApuracao"> | string
    documentId?: StringFilter<"SpedFiscalApuracao"> | string
    empresaId?: StringFilter<"SpedFiscalApuracao"> | string
    cst?: StringFilter<"SpedFiscalApuracao"> | string
    cfop?: StringFilter<"SpedFiscalApuracao"> | string
    aliquota?: FloatFilter<"SpedFiscalApuracao"> | number
    valorOperacao?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorRedBc?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIpi?: FloatFilter<"SpedFiscalApuracao"> | number
    createdAt?: DateTimeFilter<"SpedFiscalApuracao"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }

  export type SpedFiscalApuracaoOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    cst?: SortOrder
    cfop?: SortOrder
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
  }

  export type SpedFiscalApuracaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpedFiscalApuracaoWhereInput | SpedFiscalApuracaoWhereInput[]
    OR?: SpedFiscalApuracaoWhereInput[]
    NOT?: SpedFiscalApuracaoWhereInput | SpedFiscalApuracaoWhereInput[]
    documentId?: StringFilter<"SpedFiscalApuracao"> | string
    empresaId?: StringFilter<"SpedFiscalApuracao"> | string
    cst?: StringFilter<"SpedFiscalApuracao"> | string
    cfop?: StringFilter<"SpedFiscalApuracao"> | string
    aliquota?: FloatFilter<"SpedFiscalApuracao"> | number
    valorOperacao?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorRedBc?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIpi?: FloatFilter<"SpedFiscalApuracao"> | number
    createdAt?: DateTimeFilter<"SpedFiscalApuracao"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
  }, "id">

  export type SpedFiscalApuracaoOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    cst?: SortOrder
    cfop?: SortOrder
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
    _count?: SpedFiscalApuracaoCountOrderByAggregateInput
    _avg?: SpedFiscalApuracaoAvgOrderByAggregateInput
    _max?: SpedFiscalApuracaoMaxOrderByAggregateInput
    _min?: SpedFiscalApuracaoMinOrderByAggregateInput
    _sum?: SpedFiscalApuracaoSumOrderByAggregateInput
  }

  export type SpedFiscalApuracaoScalarWhereWithAggregatesInput = {
    AND?: SpedFiscalApuracaoScalarWhereWithAggregatesInput | SpedFiscalApuracaoScalarWhereWithAggregatesInput[]
    OR?: SpedFiscalApuracaoScalarWhereWithAggregatesInput[]
    NOT?: SpedFiscalApuracaoScalarWhereWithAggregatesInput | SpedFiscalApuracaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpedFiscalApuracao"> | string
    documentId?: StringWithAggregatesFilter<"SpedFiscalApuracao"> | string
    empresaId?: StringWithAggregatesFilter<"SpedFiscalApuracao"> | string
    cst?: StringWithAggregatesFilter<"SpedFiscalApuracao"> | string
    cfop?: StringWithAggregatesFilter<"SpedFiscalApuracao"> | string
    aliquota?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    valorOperacao?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    baseIcms?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    valorIcms?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    baseIcmsSt?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    valorIcmsSt?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    valorRedBc?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    valorIpi?: FloatWithAggregatesFilter<"SpedFiscalApuracao"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SpedFiscalApuracao"> | Date | string
  }

  export type XMLDocumentWhereInput = {
    AND?: XMLDocumentWhereInput | XMLDocumentWhereInput[]
    OR?: XMLDocumentWhereInput[]
    NOT?: XMLDocumentWhereInput | XMLDocumentWhereInput[]
    id?: StringFilter<"XMLDocument"> | string
    documentId?: StringFilter<"XMLDocument"> | string
    empresaId?: StringFilter<"XMLDocument"> | string
    tipoDocumento?: StringFilter<"XMLDocument"> | string
    numeroDocumento?: StringFilter<"XMLDocument"> | string
    serie?: StringFilter<"XMLDocument"> | string
    dataEmissao?: DateTimeFilter<"XMLDocument"> | Date | string
    valorTotal?: FloatFilter<"XMLDocument"> | number
    cnpjEmitente?: StringFilter<"XMLDocument"> | string
    cnpjDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    cpfDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    chaveAcesso?: StringNullableFilter<"XMLDocument"> | string | null
    protocolo?: StringNullableFilter<"XMLDocument"> | string | null
    status?: StringFilter<"XMLDocument"> | string
    observacoes?: StringNullableFilter<"XMLDocument"> | string | null
    valorTotalIcms?: FloatFilter<"XMLDocument"> | number
    valorTotalIpi?: FloatNullableFilter<"XMLDocument"> | number | null
    valorTotalPis?: FloatFilter<"XMLDocument"> | number
    valorTotalCofins?: FloatFilter<"XMLDocument"> | number
    valorTotalIss?: FloatNullableFilter<"XMLDocument"> | number | null
    baseCalculoIcms?: FloatFilter<"XMLDocument"> | number
    baseCalculoPis?: FloatFilter<"XMLDocument"> | number
    baseCalculoCofins?: FloatFilter<"XMLDocument"> | number
    createdAt?: DateTimeFilter<"XMLDocument"> | Date | string
    updatedAt?: DateTimeFilter<"XMLDocument"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    itens?: XMLItemListRelationFilter
  }

  export type XMLDocumentOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipoDocumento?: SortOrder
    numeroDocumento?: SortOrder
    serie?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    cnpjEmitente?: SortOrder
    cnpjDestinatario?: SortOrderInput | SortOrder
    cpfDestinatario?: SortOrderInput | SortOrder
    chaveAcesso?: SortOrderInput | SortOrder
    protocolo?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrderInput | SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrderInput | SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    empresa?: EmpresaOrderByWithRelationInput
    itens?: XMLItemOrderByRelationAggregateInput
  }

  export type XMLDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: XMLDocumentWhereInput | XMLDocumentWhereInput[]
    OR?: XMLDocumentWhereInput[]
    NOT?: XMLDocumentWhereInput | XMLDocumentWhereInput[]
    documentId?: StringFilter<"XMLDocument"> | string
    empresaId?: StringFilter<"XMLDocument"> | string
    tipoDocumento?: StringFilter<"XMLDocument"> | string
    numeroDocumento?: StringFilter<"XMLDocument"> | string
    serie?: StringFilter<"XMLDocument"> | string
    dataEmissao?: DateTimeFilter<"XMLDocument"> | Date | string
    valorTotal?: FloatFilter<"XMLDocument"> | number
    cnpjEmitente?: StringFilter<"XMLDocument"> | string
    cnpjDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    cpfDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    chaveAcesso?: StringNullableFilter<"XMLDocument"> | string | null
    protocolo?: StringNullableFilter<"XMLDocument"> | string | null
    status?: StringFilter<"XMLDocument"> | string
    observacoes?: StringNullableFilter<"XMLDocument"> | string | null
    valorTotalIcms?: FloatFilter<"XMLDocument"> | number
    valorTotalIpi?: FloatNullableFilter<"XMLDocument"> | number | null
    valorTotalPis?: FloatFilter<"XMLDocument"> | number
    valorTotalCofins?: FloatFilter<"XMLDocument"> | number
    valorTotalIss?: FloatNullableFilter<"XMLDocument"> | number | null
    baseCalculoIcms?: FloatFilter<"XMLDocument"> | number
    baseCalculoPis?: FloatFilter<"XMLDocument"> | number
    baseCalculoCofins?: FloatFilter<"XMLDocument"> | number
    createdAt?: DateTimeFilter<"XMLDocument"> | Date | string
    updatedAt?: DateTimeFilter<"XMLDocument"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    empresa?: XOR<EmpresaRelationFilter, EmpresaWhereInput>
    itens?: XMLItemListRelationFilter
  }, "id">

  export type XMLDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipoDocumento?: SortOrder
    numeroDocumento?: SortOrder
    serie?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    cnpjEmitente?: SortOrder
    cnpjDestinatario?: SortOrderInput | SortOrder
    cpfDestinatario?: SortOrderInput | SortOrder
    chaveAcesso?: SortOrderInput | SortOrder
    protocolo?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrderInput | SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrderInput | SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XMLDocumentCountOrderByAggregateInput
    _avg?: XMLDocumentAvgOrderByAggregateInput
    _max?: XMLDocumentMaxOrderByAggregateInput
    _min?: XMLDocumentMinOrderByAggregateInput
    _sum?: XMLDocumentSumOrderByAggregateInput
  }

  export type XMLDocumentScalarWhereWithAggregatesInput = {
    AND?: XMLDocumentScalarWhereWithAggregatesInput | XMLDocumentScalarWhereWithAggregatesInput[]
    OR?: XMLDocumentScalarWhereWithAggregatesInput[]
    NOT?: XMLDocumentScalarWhereWithAggregatesInput | XMLDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XMLDocument"> | string
    documentId?: StringWithAggregatesFilter<"XMLDocument"> | string
    empresaId?: StringWithAggregatesFilter<"XMLDocument"> | string
    tipoDocumento?: StringWithAggregatesFilter<"XMLDocument"> | string
    numeroDocumento?: StringWithAggregatesFilter<"XMLDocument"> | string
    serie?: StringWithAggregatesFilter<"XMLDocument"> | string
    dataEmissao?: DateTimeWithAggregatesFilter<"XMLDocument"> | Date | string
    valorTotal?: FloatWithAggregatesFilter<"XMLDocument"> | number
    cnpjEmitente?: StringWithAggregatesFilter<"XMLDocument"> | string
    cnpjDestinatario?: StringNullableWithAggregatesFilter<"XMLDocument"> | string | null
    cpfDestinatario?: StringNullableWithAggregatesFilter<"XMLDocument"> | string | null
    chaveAcesso?: StringNullableWithAggregatesFilter<"XMLDocument"> | string | null
    protocolo?: StringNullableWithAggregatesFilter<"XMLDocument"> | string | null
    status?: StringWithAggregatesFilter<"XMLDocument"> | string
    observacoes?: StringNullableWithAggregatesFilter<"XMLDocument"> | string | null
    valorTotalIcms?: FloatWithAggregatesFilter<"XMLDocument"> | number
    valorTotalIpi?: FloatNullableWithAggregatesFilter<"XMLDocument"> | number | null
    valorTotalPis?: FloatWithAggregatesFilter<"XMLDocument"> | number
    valorTotalCofins?: FloatWithAggregatesFilter<"XMLDocument"> | number
    valorTotalIss?: FloatNullableWithAggregatesFilter<"XMLDocument"> | number | null
    baseCalculoIcms?: FloatWithAggregatesFilter<"XMLDocument"> | number
    baseCalculoPis?: FloatWithAggregatesFilter<"XMLDocument"> | number
    baseCalculoCofins?: FloatWithAggregatesFilter<"XMLDocument"> | number
    createdAt?: DateTimeWithAggregatesFilter<"XMLDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XMLDocument"> | Date | string
  }

  export type XMLItemWhereInput = {
    AND?: XMLItemWhereInput | XMLItemWhereInput[]
    OR?: XMLItemWhereInput[]
    NOT?: XMLItemWhereInput | XMLItemWhereInput[]
    id?: StringFilter<"XMLItem"> | string
    xmlDocumentId?: StringFilter<"XMLItem"> | string
    codigo?: StringFilter<"XMLItem"> | string
    descricao?: StringFilter<"XMLItem"> | string
    ncm?: StringFilter<"XMLItem"> | string
    cfop?: StringFilter<"XMLItem"> | string
    quantidade?: FloatFilter<"XMLItem"> | number
    valorUnitario?: FloatFilter<"XMLItem"> | number
    valorTotal?: FloatFilter<"XMLItem"> | number
    cst?: StringFilter<"XMLItem"> | string
    aliquotaIcms?: FloatFilter<"XMLItem"> | number
    valorIcms?: FloatFilter<"XMLItem"> | number
    aliquotaIpi?: FloatNullableFilter<"XMLItem"> | number | null
    valorIpi?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaPis?: FloatNullableFilter<"XMLItem"> | number | null
    valorPis?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaCofins?: FloatNullableFilter<"XMLItem"> | number | null
    valorCofins?: FloatNullableFilter<"XMLItem"> | number | null
    createdAt?: DateTimeFilter<"XMLItem"> | Date | string
    xmlDocument?: XOR<XMLDocumentRelationFilter, XMLDocumentWhereInput>
  }

  export type XMLItemOrderByWithRelationInput = {
    id?: SortOrder
    xmlDocumentId?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    ncm?: SortOrder
    cfop?: SortOrder
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    cst?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrderInput | SortOrder
    valorIpi?: SortOrderInput | SortOrder
    aliquotaPis?: SortOrderInput | SortOrder
    valorPis?: SortOrderInput | SortOrder
    aliquotaCofins?: SortOrderInput | SortOrder
    valorCofins?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    xmlDocument?: XMLDocumentOrderByWithRelationInput
  }

  export type XMLItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: XMLItemWhereInput | XMLItemWhereInput[]
    OR?: XMLItemWhereInput[]
    NOT?: XMLItemWhereInput | XMLItemWhereInput[]
    xmlDocumentId?: StringFilter<"XMLItem"> | string
    codigo?: StringFilter<"XMLItem"> | string
    descricao?: StringFilter<"XMLItem"> | string
    ncm?: StringFilter<"XMLItem"> | string
    cfop?: StringFilter<"XMLItem"> | string
    quantidade?: FloatFilter<"XMLItem"> | number
    valorUnitario?: FloatFilter<"XMLItem"> | number
    valorTotal?: FloatFilter<"XMLItem"> | number
    cst?: StringFilter<"XMLItem"> | string
    aliquotaIcms?: FloatFilter<"XMLItem"> | number
    valorIcms?: FloatFilter<"XMLItem"> | number
    aliquotaIpi?: FloatNullableFilter<"XMLItem"> | number | null
    valorIpi?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaPis?: FloatNullableFilter<"XMLItem"> | number | null
    valorPis?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaCofins?: FloatNullableFilter<"XMLItem"> | number | null
    valorCofins?: FloatNullableFilter<"XMLItem"> | number | null
    createdAt?: DateTimeFilter<"XMLItem"> | Date | string
    xmlDocument?: XOR<XMLDocumentRelationFilter, XMLDocumentWhereInput>
  }, "id">

  export type XMLItemOrderByWithAggregationInput = {
    id?: SortOrder
    xmlDocumentId?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    ncm?: SortOrder
    cfop?: SortOrder
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    cst?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrderInput | SortOrder
    valorIpi?: SortOrderInput | SortOrder
    aliquotaPis?: SortOrderInput | SortOrder
    valorPis?: SortOrderInput | SortOrder
    aliquotaCofins?: SortOrderInput | SortOrder
    valorCofins?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: XMLItemCountOrderByAggregateInput
    _avg?: XMLItemAvgOrderByAggregateInput
    _max?: XMLItemMaxOrderByAggregateInput
    _min?: XMLItemMinOrderByAggregateInput
    _sum?: XMLItemSumOrderByAggregateInput
  }

  export type XMLItemScalarWhereWithAggregatesInput = {
    AND?: XMLItemScalarWhereWithAggregatesInput | XMLItemScalarWhereWithAggregatesInput[]
    OR?: XMLItemScalarWhereWithAggregatesInput[]
    NOT?: XMLItemScalarWhereWithAggregatesInput | XMLItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XMLItem"> | string
    xmlDocumentId?: StringWithAggregatesFilter<"XMLItem"> | string
    codigo?: StringWithAggregatesFilter<"XMLItem"> | string
    descricao?: StringWithAggregatesFilter<"XMLItem"> | string
    ncm?: StringWithAggregatesFilter<"XMLItem"> | string
    cfop?: StringWithAggregatesFilter<"XMLItem"> | string
    quantidade?: FloatWithAggregatesFilter<"XMLItem"> | number
    valorUnitario?: FloatWithAggregatesFilter<"XMLItem"> | number
    valorTotal?: FloatWithAggregatesFilter<"XMLItem"> | number
    cst?: StringWithAggregatesFilter<"XMLItem"> | string
    aliquotaIcms?: FloatWithAggregatesFilter<"XMLItem"> | number
    valorIcms?: FloatWithAggregatesFilter<"XMLItem"> | number
    aliquotaIpi?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    valorIpi?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    aliquotaPis?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    valorPis?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    aliquotaCofins?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    valorCofins?: FloatNullableWithAggregatesFilter<"XMLItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"XMLItem"> | Date | string
  }

  export type ProcessamentoWhereInput = {
    AND?: ProcessamentoWhereInput | ProcessamentoWhereInput[]
    OR?: ProcessamentoWhereInput[]
    NOT?: ProcessamentoWhereInput | ProcessamentoWhereInput[]
    id?: StringFilter<"Processamento"> | string
    userId?: StringFilter<"Processamento"> | string
    documentoId?: StringFilter<"Processamento"> | string
    status?: EnumProcessamentoStatusFilter<"Processamento"> | $Enums.ProcessamentoStatus
    resultado?: JsonNullableFilter<"Processamento">
    createdAt?: DateTimeFilter<"Processamento"> | Date | string
    updatedAt?: DateTimeFilter<"Processamento"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    documento?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type ProcessamentoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    documentoId?: SortOrder
    status?: SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    documento?: DocumentOrderByWithRelationInput
  }

  export type ProcessamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessamentoWhereInput | ProcessamentoWhereInput[]
    OR?: ProcessamentoWhereInput[]
    NOT?: ProcessamentoWhereInput | ProcessamentoWhereInput[]
    userId?: StringFilter<"Processamento"> | string
    documentoId?: StringFilter<"Processamento"> | string
    status?: EnumProcessamentoStatusFilter<"Processamento"> | $Enums.ProcessamentoStatus
    resultado?: JsonNullableFilter<"Processamento">
    createdAt?: DateTimeFilter<"Processamento"> | Date | string
    updatedAt?: DateTimeFilter<"Processamento"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    documento?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type ProcessamentoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    documentoId?: SortOrder
    status?: SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessamentoCountOrderByAggregateInput
    _max?: ProcessamentoMaxOrderByAggregateInput
    _min?: ProcessamentoMinOrderByAggregateInput
  }

  export type ProcessamentoScalarWhereWithAggregatesInput = {
    AND?: ProcessamentoScalarWhereWithAggregatesInput | ProcessamentoScalarWhereWithAggregatesInput[]
    OR?: ProcessamentoScalarWhereWithAggregatesInput[]
    NOT?: ProcessamentoScalarWhereWithAggregatesInput | ProcessamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Processamento"> | string
    userId?: StringWithAggregatesFilter<"Processamento"> | string
    documentoId?: StringWithAggregatesFilter<"Processamento"> | string
    status?: EnumProcessamentoStatusWithAggregatesFilter<"Processamento"> | $Enums.ProcessamentoStatus
    resultado?: JsonNullableWithAggregatesFilter<"Processamento">
    createdAt?: DateTimeWithAggregatesFilter<"Processamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Processamento"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaCreateInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaCreateManyInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultCreateInput = {
    id?: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutAiResultsInput
  }

  export type AIProcessingResultUncheckedCreateInput = {
    id?: string
    documentId: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
  }

  export type AIProcessingResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutAiResultsNestedInput
  }

  export type AIProcessingResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultCreateManyInput = {
    id?: string
    documentId: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
  }

  export type AIProcessingResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    createdAt?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryCreateInput = {
    key: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CacheEntryUncheckedCreateInput = {
    key: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CacheEntryUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryCreateManyInput = {
    key: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type CacheEntryUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemCreateInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedContribuicoesItemsInput
    empresa: EmpresaCreateNestedOneWithoutSpedContribuicoesItemsInput
  }

  export type SpedContribuicoesItemUncheckedCreateInput = {
    id?: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput
  }

  export type SpedContribuicoesItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemCreateManyInput = {
    id?: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoCreateInput = {
    id?: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedContribuicoesApuracoesInput
    empresa: EmpresaCreateNestedOneWithoutSpedContribuicoesApuracaoInput
  }

  export type SpedContribuicoesApuracaoUncheckedCreateInput = {
    id?: string
    documentId: string
    empresaId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedContribuicoesApuracoesNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutSpedContribuicoesApuracaoNestedInput
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoCreateManyInput = {
    id?: string
    documentId: string
    empresaId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemCreateInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedFiscalItemsInput
    empresa: EmpresaCreateNestedOneWithoutSpedFiscalItemsInput
  }

  export type SpedFiscalItemUncheckedCreateInput = {
    id?: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedFiscalItemsNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutSpedFiscalItemsNestedInput
  }

  export type SpedFiscalItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemCreateManyInput = {
    id?: string
    documentId: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoCreateInput = {
    id?: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedFiscalApuracoesInput
    empresa: EmpresaCreateNestedOneWithoutSpedFiscalApuracaoInput
  }

  export type SpedFiscalApuracaoUncheckedCreateInput = {
    id?: string
    documentId: string
    empresaId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedFiscalApuracoesNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutSpedFiscalApuracaoNestedInput
  }

  export type SpedFiscalApuracaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoCreateManyInput = {
    id?: string
    documentId: string
    empresaId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLDocumentCreateInput = {
    id?: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutXmlDocumentsInput
    empresa: EmpresaCreateNestedOneWithoutXmlDocumentsInput
    itens?: XMLItemCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentUncheckedCreateInput = {
    id?: string
    documentId: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itens?: XMLItemUncheckedCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutXmlDocumentsNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutXmlDocumentsNestedInput
    itens?: XMLItemUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: XMLItemUncheckedUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentCreateManyInput = {
    id?: string
    documentId: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XMLDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemCreateInput = {
    id?: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
    xmlDocument: XMLDocumentCreateNestedOneWithoutItensInput
  }

  export type XMLItemUncheckedCreateInput = {
    id?: string
    xmlDocumentId: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
  }

  export type XMLItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xmlDocument?: XMLDocumentUpdateOneRequiredWithoutItensNestedInput
  }

  export type XMLItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xmlDocumentId?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemCreateManyInput = {
    id?: string
    xmlDocumentId: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
  }

  export type XMLItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xmlDocumentId?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoCreateInput = {
    id?: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessamentosInput
    documento: DocumentCreateNestedOneWithoutProcessamentosInput
  }

  export type ProcessamentoUncheckedCreateInput = {
    id?: string
    userId: string
    documentoId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessamentosNestedInput
    documento?: DocumentUpdateOneRequiredWithoutProcessamentosNestedInput
  }

  export type ProcessamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoCreateManyInput = {
    id?: string
    userId: string
    documentoId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type ProcessamentoListRelationFilter = {
    every?: ProcessamentoWhereInput
    some?: ProcessamentoWhereInput
    none?: ProcessamentoWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SpedContribuicoesItemListRelationFilter = {
    every?: SpedContribuicoesItemWhereInput
    some?: SpedContribuicoesItemWhereInput
    none?: SpedContribuicoesItemWhereInput
  }

  export type SpedContribuicoesApuracaoListRelationFilter = {
    every?: SpedContribuicoesApuracaoWhereInput
    some?: SpedContribuicoesApuracaoWhereInput
    none?: SpedContribuicoesApuracaoWhereInput
  }

  export type SpedFiscalItemListRelationFilter = {
    every?: SpedFiscalItemWhereInput
    some?: SpedFiscalItemWhereInput
    none?: SpedFiscalItemWhereInput
  }

  export type SpedFiscalApuracaoListRelationFilter = {
    every?: SpedFiscalApuracaoWhereInput
    some?: SpedFiscalApuracaoWhereInput
    none?: SpedFiscalApuracaoWhereInput
  }

  export type XMLDocumentListRelationFilter = {
    every?: XMLDocumentWhereInput
    some?: XMLDocumentWhereInput
    none?: XMLDocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SpedContribuicoesItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpedContribuicoesApuracaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpedFiscalItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpedFiscalApuracaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XMLDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    cnpj?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    ie?: SortOrder
    im?: SortOrder
    cnae?: SortOrder
    endereco?: SortOrder
    regimeTributario?: SortOrder
    dataCadastro?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    cnpj?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    ie?: SortOrder
    im?: SortOrder
    cnae?: SortOrder
    endereco?: SortOrder
    regimeTributario?: SortOrder
    dataCadastro?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    cnpj?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    ie?: SortOrder
    im?: SortOrder
    cnae?: SortOrder
    endereco?: SortOrder
    regimeTributario?: SortOrder
    dataCadastro?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EmpresaNullableRelationFilter = {
    is?: EmpresaWhereInput | null
    isNot?: EmpresaWhereInput | null
  }

  export type AIProcessingResultListRelationFilter = {
    every?: AIProcessingResultWhereInput
    some?: AIProcessingResultWhereInput
    none?: AIProcessingResultWhereInput
  }

  export type AIProcessingResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type AIProcessingResultCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    tokens?: SortOrder
    processingTime?: SortOrder
    result?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIProcessingResultAvgOrderByAggregateInput = {
    tokens?: SortOrder
    processingTime?: SortOrder
  }

  export type AIProcessingResultMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    tokens?: SortOrder
    processingTime?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIProcessingResultMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    model?: SortOrder
    tokens?: SortOrder
    processingTime?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type AIProcessingResultSumOrderByAggregateInput = {
    tokens?: SortOrder
    processingTime?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type CacheEntryCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CacheEntryMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CacheEntryMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EmpresaRelationFilter = {
    is?: EmpresaWhereInput
    isNot?: EmpresaWhereInput
  }

  export type SpedContribuicoesItemCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesItemAvgOrderByAggregateInput = {
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
  }

  export type SpedContribuicoesItemMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesItemMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesItemSumOrderByAggregateInput = {
    valor?: SortOrder
    basePis?: SortOrder
    valorPis?: SortOrder
    baseCofins?: SortOrder
    valorCofins?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SpedContribuicoesApuracaoCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipo?: SortOrder
    periodo?: SortOrder
    base?: SortOrder
    aliquota?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesApuracaoAvgOrderByAggregateInput = {
    base?: SortOrder
    aliquota?: SortOrder
    valor?: SortOrder
  }

  export type SpedContribuicoesApuracaoMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipo?: SortOrder
    periodo?: SortOrder
    base?: SortOrder
    aliquota?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesApuracaoMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipo?: SortOrder
    periodo?: SortOrder
    base?: SortOrder
    aliquota?: SortOrder
    valor?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedContribuicoesApuracaoSumOrderByAggregateInput = {
    base?: SortOrder
    aliquota?: SortOrder
    valor?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SpedFiscalItemCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    ncm?: SortOrder
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalItemAvgOrderByAggregateInput = {
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
  }

  export type SpedFiscalItemMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    ncm?: SortOrder
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalItemMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    documento?: SortOrder
    data?: SortOrder
    cnpj?: SortOrder
    produto?: SortOrder
    cfop?: SortOrder
    cst?: SortOrder
    ncm?: SortOrder
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalItemSumOrderByAggregateInput = {
    valor?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIpi?: SortOrder
    valorIpi?: SortOrder
  }

  export type SpedFiscalApuracaoCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    cst?: SortOrder
    cfop?: SortOrder
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalApuracaoAvgOrderByAggregateInput = {
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
  }

  export type SpedFiscalApuracaoMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    cst?: SortOrder
    cfop?: SortOrder
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalApuracaoMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    cst?: SortOrder
    cfop?: SortOrder
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
    createdAt?: SortOrder
  }

  export type SpedFiscalApuracaoSumOrderByAggregateInput = {
    aliquota?: SortOrder
    valorOperacao?: SortOrder
    baseIcms?: SortOrder
    valorIcms?: SortOrder
    baseIcmsSt?: SortOrder
    valorIcmsSt?: SortOrder
    valorRedBc?: SortOrder
    valorIpi?: SortOrder
  }

  export type XMLItemListRelationFilter = {
    every?: XMLItemWhereInput
    some?: XMLItemWhereInput
    none?: XMLItemWhereInput
  }

  export type XMLItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XMLDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipoDocumento?: SortOrder
    numeroDocumento?: SortOrder
    serie?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    cnpjEmitente?: SortOrder
    cnpjDestinatario?: SortOrder
    cpfDestinatario?: SortOrder
    chaveAcesso?: SortOrder
    protocolo?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XMLDocumentAvgOrderByAggregateInput = {
    valorTotal?: SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
  }

  export type XMLDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipoDocumento?: SortOrder
    numeroDocumento?: SortOrder
    serie?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    cnpjEmitente?: SortOrder
    cnpjDestinatario?: SortOrder
    cpfDestinatario?: SortOrder
    chaveAcesso?: SortOrder
    protocolo?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XMLDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    empresaId?: SortOrder
    tipoDocumento?: SortOrder
    numeroDocumento?: SortOrder
    serie?: SortOrder
    dataEmissao?: SortOrder
    valorTotal?: SortOrder
    cnpjEmitente?: SortOrder
    cnpjDestinatario?: SortOrder
    cpfDestinatario?: SortOrder
    chaveAcesso?: SortOrder
    protocolo?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XMLDocumentSumOrderByAggregateInput = {
    valorTotal?: SortOrder
    valorTotalIcms?: SortOrder
    valorTotalIpi?: SortOrder
    valorTotalPis?: SortOrder
    valorTotalCofins?: SortOrder
    valorTotalIss?: SortOrder
    baseCalculoIcms?: SortOrder
    baseCalculoPis?: SortOrder
    baseCalculoCofins?: SortOrder
  }

  export type XMLDocumentRelationFilter = {
    is?: XMLDocumentWhereInput
    isNot?: XMLDocumentWhereInput
  }

  export type XMLItemCountOrderByAggregateInput = {
    id?: SortOrder
    xmlDocumentId?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    ncm?: SortOrder
    cfop?: SortOrder
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    cst?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrder
    valorIpi?: SortOrder
    aliquotaPis?: SortOrder
    valorPis?: SortOrder
    aliquotaCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type XMLItemAvgOrderByAggregateInput = {
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrder
    valorIpi?: SortOrder
    aliquotaPis?: SortOrder
    valorPis?: SortOrder
    aliquotaCofins?: SortOrder
    valorCofins?: SortOrder
  }

  export type XMLItemMaxOrderByAggregateInput = {
    id?: SortOrder
    xmlDocumentId?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    ncm?: SortOrder
    cfop?: SortOrder
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    cst?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrder
    valorIpi?: SortOrder
    aliquotaPis?: SortOrder
    valorPis?: SortOrder
    aliquotaCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type XMLItemMinOrderByAggregateInput = {
    id?: SortOrder
    xmlDocumentId?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    ncm?: SortOrder
    cfop?: SortOrder
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    cst?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrder
    valorIpi?: SortOrder
    aliquotaPis?: SortOrder
    valorPis?: SortOrder
    aliquotaCofins?: SortOrder
    valorCofins?: SortOrder
    createdAt?: SortOrder
  }

  export type XMLItemSumOrderByAggregateInput = {
    quantidade?: SortOrder
    valorUnitario?: SortOrder
    valorTotal?: SortOrder
    aliquotaIcms?: SortOrder
    valorIcms?: SortOrder
    aliquotaIpi?: SortOrder
    valorIpi?: SortOrder
    aliquotaPis?: SortOrder
    valorPis?: SortOrder
    aliquotaCofins?: SortOrder
    valorCofins?: SortOrder
  }

  export type EnumProcessamentoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessamentoStatus | EnumProcessamentoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessamentoStatusFilter<$PrismaModel> | $Enums.ProcessamentoStatus
  }

  export type ProcessamentoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentoId?: SortOrder
    status?: SortOrder
    resultado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentoId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessamentoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    documentoId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProcessamentoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessamentoStatus | EnumProcessamentoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessamentoStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessamentoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessamentoStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessamentoStatusFilter<$PrismaModel>
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ProcessamentoCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput> | ProcessamentoCreateWithoutUserInput[] | ProcessamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutUserInput | ProcessamentoCreateOrConnectWithoutUserInput[]
    createMany?: ProcessamentoCreateManyUserInputEnvelope
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ProcessamentoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput> | ProcessamentoCreateWithoutUserInput[] | ProcessamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutUserInput | ProcessamentoCreateOrConnectWithoutUserInput[]
    createMany?: ProcessamentoCreateManyUserInputEnvelope
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ProcessamentoUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput> | ProcessamentoCreateWithoutUserInput[] | ProcessamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutUserInput | ProcessamentoCreateOrConnectWithoutUserInput[]
    upsert?: ProcessamentoUpsertWithWhereUniqueWithoutUserInput | ProcessamentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessamentoCreateManyUserInputEnvelope
    set?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    disconnect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    delete?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    update?: ProcessamentoUpdateWithWhereUniqueWithoutUserInput | ProcessamentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessamentoUpdateManyWithWhereWithoutUserInput | ProcessamentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ProcessamentoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput> | ProcessamentoCreateWithoutUserInput[] | ProcessamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutUserInput | ProcessamentoCreateOrConnectWithoutUserInput[]
    upsert?: ProcessamentoUpsertWithWhereUniqueWithoutUserInput | ProcessamentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessamentoCreateManyUserInputEnvelope
    set?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    disconnect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    delete?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    update?: ProcessamentoUpdateWithWhereUniqueWithoutUserInput | ProcessamentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessamentoUpdateManyWithWhereWithoutUserInput | ProcessamentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type DocumentCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput> | DocumentCreateWithoutEmpresaInput[] | DocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmpresaInput | DocumentCreateOrConnectWithoutEmpresaInput[]
    createMany?: DocumentCreateManyEmpresaInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesItemCreateWithoutEmpresaInput[] | SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput | SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedContribuicoesItemCreateManyEmpresaInputEnvelope
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
  }

  export type SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesApuracaoCreateWithoutEmpresaInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput | SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyEmpresaInputEnvelope
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
  }

  export type SpedFiscalItemCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput> | SpedFiscalItemCreateWithoutEmpresaInput[] | SpedFiscalItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutEmpresaInput | SpedFiscalItemCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedFiscalItemCreateManyEmpresaInputEnvelope
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
  }

  export type SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput> | SpedFiscalApuracaoCreateWithoutEmpresaInput[] | SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput | SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedFiscalApuracaoCreateManyEmpresaInputEnvelope
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
  }

  export type XMLDocumentCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput> | XMLDocumentCreateWithoutEmpresaInput[] | XMLDocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutEmpresaInput | XMLDocumentCreateOrConnectWithoutEmpresaInput[]
    createMany?: XMLDocumentCreateManyEmpresaInputEnvelope
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput> | DocumentCreateWithoutEmpresaInput[] | DocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmpresaInput | DocumentCreateOrConnectWithoutEmpresaInput[]
    createMany?: DocumentCreateManyEmpresaInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesItemCreateWithoutEmpresaInput[] | SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput | SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedContribuicoesItemCreateManyEmpresaInputEnvelope
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
  }

  export type SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesApuracaoCreateWithoutEmpresaInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput | SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyEmpresaInputEnvelope
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
  }

  export type SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput> | SpedFiscalItemCreateWithoutEmpresaInput[] | SpedFiscalItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutEmpresaInput | SpedFiscalItemCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedFiscalItemCreateManyEmpresaInputEnvelope
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
  }

  export type SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput> | SpedFiscalApuracaoCreateWithoutEmpresaInput[] | SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput | SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput[]
    createMany?: SpedFiscalApuracaoCreateManyEmpresaInputEnvelope
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
  }

  export type XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput = {
    create?: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput> | XMLDocumentCreateWithoutEmpresaInput[] | XMLDocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutEmpresaInput | XMLDocumentCreateOrConnectWithoutEmpresaInput[]
    createMany?: XMLDocumentCreateManyEmpresaInputEnvelope
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DocumentUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput> | DocumentCreateWithoutEmpresaInput[] | DocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmpresaInput | DocumentCreateOrConnectWithoutEmpresaInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmpresaInput | DocumentUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: DocumentCreateManyEmpresaInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmpresaInput | DocumentUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmpresaInput | DocumentUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesItemCreateWithoutEmpresaInput[] | SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput | SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedContribuicoesItemUpsertWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesItemUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedContribuicoesItemCreateManyEmpresaInputEnvelope
    set?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    disconnect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    delete?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    update?: SpedContribuicoesItemUpdateWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesItemUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedContribuicoesItemUpdateManyWithWhereWithoutEmpresaInput | SpedContribuicoesItemUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
  }

  export type SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesApuracaoCreateWithoutEmpresaInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput | SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyEmpresaInputEnvelope
    set?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    disconnect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    delete?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    update?: SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedContribuicoesApuracaoUpdateManyWithWhereWithoutEmpresaInput | SpedContribuicoesApuracaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
  }

  export type SpedFiscalItemUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput> | SpedFiscalItemCreateWithoutEmpresaInput[] | SpedFiscalItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutEmpresaInput | SpedFiscalItemCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedFiscalItemUpsertWithWhereUniqueWithoutEmpresaInput | SpedFiscalItemUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedFiscalItemCreateManyEmpresaInputEnvelope
    set?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    disconnect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    delete?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    update?: SpedFiscalItemUpdateWithWhereUniqueWithoutEmpresaInput | SpedFiscalItemUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedFiscalItemUpdateManyWithWhereWithoutEmpresaInput | SpedFiscalItemUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
  }

  export type SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput> | SpedFiscalApuracaoCreateWithoutEmpresaInput[] | SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput | SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedFiscalApuracaoUpsertWithWhereUniqueWithoutEmpresaInput | SpedFiscalApuracaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedFiscalApuracaoCreateManyEmpresaInputEnvelope
    set?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    disconnect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    delete?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    update?: SpedFiscalApuracaoUpdateWithWhereUniqueWithoutEmpresaInput | SpedFiscalApuracaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedFiscalApuracaoUpdateManyWithWhereWithoutEmpresaInput | SpedFiscalApuracaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
  }

  export type XMLDocumentUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput> | XMLDocumentCreateWithoutEmpresaInput[] | XMLDocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutEmpresaInput | XMLDocumentCreateOrConnectWithoutEmpresaInput[]
    upsert?: XMLDocumentUpsertWithWhereUniqueWithoutEmpresaInput | XMLDocumentUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: XMLDocumentCreateManyEmpresaInputEnvelope
    set?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    disconnect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    delete?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    update?: XMLDocumentUpdateWithWhereUniqueWithoutEmpresaInput | XMLDocumentUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: XMLDocumentUpdateManyWithWhereWithoutEmpresaInput | XMLDocumentUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput> | DocumentCreateWithoutEmpresaInput[] | DocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEmpresaInput | DocumentCreateOrConnectWithoutEmpresaInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEmpresaInput | DocumentUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: DocumentCreateManyEmpresaInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEmpresaInput | DocumentUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEmpresaInput | DocumentUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesItemCreateWithoutEmpresaInput[] | SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput | SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedContribuicoesItemUpsertWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesItemUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedContribuicoesItemCreateManyEmpresaInputEnvelope
    set?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    disconnect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    delete?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    update?: SpedContribuicoesItemUpdateWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesItemUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedContribuicoesItemUpdateManyWithWhereWithoutEmpresaInput | SpedContribuicoesItemUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput> | SpedContribuicoesApuracaoCreateWithoutEmpresaInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput | SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyEmpresaInputEnvelope
    set?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    disconnect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    delete?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    update?: SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutEmpresaInput | SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedContribuicoesApuracaoUpdateManyWithWhereWithoutEmpresaInput | SpedContribuicoesApuracaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
  }

  export type SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput> | SpedFiscalItemCreateWithoutEmpresaInput[] | SpedFiscalItemUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutEmpresaInput | SpedFiscalItemCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedFiscalItemUpsertWithWhereUniqueWithoutEmpresaInput | SpedFiscalItemUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedFiscalItemCreateManyEmpresaInputEnvelope
    set?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    disconnect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    delete?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    update?: SpedFiscalItemUpdateWithWhereUniqueWithoutEmpresaInput | SpedFiscalItemUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedFiscalItemUpdateManyWithWhereWithoutEmpresaInput | SpedFiscalItemUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
  }

  export type SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput> | SpedFiscalApuracaoCreateWithoutEmpresaInput[] | SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput | SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput[]
    upsert?: SpedFiscalApuracaoUpsertWithWhereUniqueWithoutEmpresaInput | SpedFiscalApuracaoUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: SpedFiscalApuracaoCreateManyEmpresaInputEnvelope
    set?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    disconnect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    delete?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    update?: SpedFiscalApuracaoUpdateWithWhereUniqueWithoutEmpresaInput | SpedFiscalApuracaoUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: SpedFiscalApuracaoUpdateManyWithWhereWithoutEmpresaInput | SpedFiscalApuracaoUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
  }

  export type XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput = {
    create?: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput> | XMLDocumentCreateWithoutEmpresaInput[] | XMLDocumentUncheckedCreateWithoutEmpresaInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutEmpresaInput | XMLDocumentCreateOrConnectWithoutEmpresaInput[]
    upsert?: XMLDocumentUpsertWithWhereUniqueWithoutEmpresaInput | XMLDocumentUpsertWithWhereUniqueWithoutEmpresaInput[]
    createMany?: XMLDocumentCreateManyEmpresaInputEnvelope
    set?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    disconnect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    delete?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    update?: XMLDocumentUpdateWithWhereUniqueWithoutEmpresaInput | XMLDocumentUpdateWithWhereUniqueWithoutEmpresaInput[]
    updateMany?: XMLDocumentUpdateManyWithWhereWithoutEmpresaInput | XMLDocumentUpdateManyWithWhereWithoutEmpresaInput[]
    deleteMany?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<EmpresaCreateWithoutDocumentosInput, EmpresaUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutDocumentosInput
    connect?: EmpresaWhereUniqueInput
  }

  export type ProcessamentoCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput> | ProcessamentoCreateWithoutDocumentoInput[] | ProcessamentoUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutDocumentoInput | ProcessamentoCreateOrConnectWithoutDocumentoInput[]
    createMany?: ProcessamentoCreateManyDocumentoInputEnvelope
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
  }

  export type AIProcessingResultCreateNestedManyWithoutDocumentInput = {
    create?: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput> | AIProcessingResultCreateWithoutDocumentInput[] | AIProcessingResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AIProcessingResultCreateOrConnectWithoutDocumentInput | AIProcessingResultCreateOrConnectWithoutDocumentInput[]
    createMany?: AIProcessingResultCreateManyDocumentInputEnvelope
    connect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
  }

  export type XMLDocumentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput> | XMLDocumentCreateWithoutDocumentInput[] | XMLDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutDocumentInput | XMLDocumentCreateOrConnectWithoutDocumentInput[]
    createMany?: XMLDocumentCreateManyDocumentInputEnvelope
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
  }

  export type SpedContribuicoesItemCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput> | SpedContribuicoesItemCreateWithoutDocumentInput[] | SpedContribuicoesItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutDocumentInput | SpedContribuicoesItemCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedContribuicoesItemCreateManyDocumentInputEnvelope
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
  }

  export type SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput> | SpedContribuicoesApuracaoCreateWithoutDocumentInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput | SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyDocumentInputEnvelope
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
  }

  export type SpedFiscalItemCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput> | SpedFiscalItemCreateWithoutDocumentInput[] | SpedFiscalItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutDocumentInput | SpedFiscalItemCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedFiscalItemCreateManyDocumentInputEnvelope
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
  }

  export type SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput> | SpedFiscalApuracaoCreateWithoutDocumentInput[] | SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput | SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedFiscalApuracaoCreateManyDocumentInputEnvelope
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
  }

  export type ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput> | ProcessamentoCreateWithoutDocumentoInput[] | ProcessamentoUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutDocumentoInput | ProcessamentoCreateOrConnectWithoutDocumentoInput[]
    createMany?: ProcessamentoCreateManyDocumentoInputEnvelope
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
  }

  export type AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput> | AIProcessingResultCreateWithoutDocumentInput[] | AIProcessingResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AIProcessingResultCreateOrConnectWithoutDocumentInput | AIProcessingResultCreateOrConnectWithoutDocumentInput[]
    createMany?: AIProcessingResultCreateManyDocumentInputEnvelope
    connect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
  }

  export type XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput> | XMLDocumentCreateWithoutDocumentInput[] | XMLDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutDocumentInput | XMLDocumentCreateOrConnectWithoutDocumentInput[]
    createMany?: XMLDocumentCreateManyDocumentInputEnvelope
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
  }

  export type SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput> | SpedContribuicoesItemCreateWithoutDocumentInput[] | SpedContribuicoesItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutDocumentInput | SpedContribuicoesItemCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedContribuicoesItemCreateManyDocumentInputEnvelope
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
  }

  export type SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput> | SpedContribuicoesApuracaoCreateWithoutDocumentInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput | SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyDocumentInputEnvelope
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
  }

  export type SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput> | SpedFiscalItemCreateWithoutDocumentInput[] | SpedFiscalItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutDocumentInput | SpedFiscalItemCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedFiscalItemCreateManyDocumentInputEnvelope
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
  }

  export type SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput> | SpedFiscalApuracaoCreateWithoutDocumentInput[] | SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput | SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput[]
    createMany?: SpedFiscalApuracaoCreateManyDocumentInputEnvelope
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmpresaUpdateOneWithoutDocumentosNestedInput = {
    create?: XOR<EmpresaCreateWithoutDocumentosInput, EmpresaUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutDocumentosInput
    upsert?: EmpresaUpsertWithoutDocumentosInput
    disconnect?: EmpresaWhereInput | boolean
    delete?: EmpresaWhereInput | boolean
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutDocumentosInput, EmpresaUpdateWithoutDocumentosInput>, EmpresaUncheckedUpdateWithoutDocumentosInput>
  }

  export type ProcessamentoUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput> | ProcessamentoCreateWithoutDocumentoInput[] | ProcessamentoUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutDocumentoInput | ProcessamentoCreateOrConnectWithoutDocumentoInput[]
    upsert?: ProcessamentoUpsertWithWhereUniqueWithoutDocumentoInput | ProcessamentoUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: ProcessamentoCreateManyDocumentoInputEnvelope
    set?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    disconnect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    delete?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    update?: ProcessamentoUpdateWithWhereUniqueWithoutDocumentoInput | ProcessamentoUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: ProcessamentoUpdateManyWithWhereWithoutDocumentoInput | ProcessamentoUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
  }

  export type AIProcessingResultUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput> | AIProcessingResultCreateWithoutDocumentInput[] | AIProcessingResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AIProcessingResultCreateOrConnectWithoutDocumentInput | AIProcessingResultCreateOrConnectWithoutDocumentInput[]
    upsert?: AIProcessingResultUpsertWithWhereUniqueWithoutDocumentInput | AIProcessingResultUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: AIProcessingResultCreateManyDocumentInputEnvelope
    set?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    disconnect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    delete?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    connect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    update?: AIProcessingResultUpdateWithWhereUniqueWithoutDocumentInput | AIProcessingResultUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: AIProcessingResultUpdateManyWithWhereWithoutDocumentInput | AIProcessingResultUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: AIProcessingResultScalarWhereInput | AIProcessingResultScalarWhereInput[]
  }

  export type XMLDocumentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput> | XMLDocumentCreateWithoutDocumentInput[] | XMLDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutDocumentInput | XMLDocumentCreateOrConnectWithoutDocumentInput[]
    upsert?: XMLDocumentUpsertWithWhereUniqueWithoutDocumentInput | XMLDocumentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: XMLDocumentCreateManyDocumentInputEnvelope
    set?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    disconnect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    delete?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    update?: XMLDocumentUpdateWithWhereUniqueWithoutDocumentInput | XMLDocumentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: XMLDocumentUpdateManyWithWhereWithoutDocumentInput | XMLDocumentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
  }

  export type SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput> | SpedContribuicoesItemCreateWithoutDocumentInput[] | SpedContribuicoesItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutDocumentInput | SpedContribuicoesItemCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedContribuicoesItemUpsertWithWhereUniqueWithoutDocumentInput | SpedContribuicoesItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedContribuicoesItemCreateManyDocumentInputEnvelope
    set?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    disconnect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    delete?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    update?: SpedContribuicoesItemUpdateWithWhereUniqueWithoutDocumentInput | SpedContribuicoesItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedContribuicoesItemUpdateManyWithWhereWithoutDocumentInput | SpedContribuicoesItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
  }

  export type SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput> | SpedContribuicoesApuracaoCreateWithoutDocumentInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput | SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutDocumentInput | SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyDocumentInputEnvelope
    set?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    disconnect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    delete?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    update?: SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutDocumentInput | SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedContribuicoesApuracaoUpdateManyWithWhereWithoutDocumentInput | SpedContribuicoesApuracaoUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
  }

  export type SpedFiscalItemUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput> | SpedFiscalItemCreateWithoutDocumentInput[] | SpedFiscalItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutDocumentInput | SpedFiscalItemCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedFiscalItemUpsertWithWhereUniqueWithoutDocumentInput | SpedFiscalItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedFiscalItemCreateManyDocumentInputEnvelope
    set?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    disconnect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    delete?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    update?: SpedFiscalItemUpdateWithWhereUniqueWithoutDocumentInput | SpedFiscalItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedFiscalItemUpdateManyWithWhereWithoutDocumentInput | SpedFiscalItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
  }

  export type SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput> | SpedFiscalApuracaoCreateWithoutDocumentInput[] | SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput | SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedFiscalApuracaoUpsertWithWhereUniqueWithoutDocumentInput | SpedFiscalApuracaoUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedFiscalApuracaoCreateManyDocumentInputEnvelope
    set?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    disconnect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    delete?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    update?: SpedFiscalApuracaoUpdateWithWhereUniqueWithoutDocumentInput | SpedFiscalApuracaoUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedFiscalApuracaoUpdateManyWithWhereWithoutDocumentInput | SpedFiscalApuracaoUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
  }

  export type ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput> | ProcessamentoCreateWithoutDocumentoInput[] | ProcessamentoUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: ProcessamentoCreateOrConnectWithoutDocumentoInput | ProcessamentoCreateOrConnectWithoutDocumentoInput[]
    upsert?: ProcessamentoUpsertWithWhereUniqueWithoutDocumentoInput | ProcessamentoUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: ProcessamentoCreateManyDocumentoInputEnvelope
    set?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    disconnect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    delete?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    connect?: ProcessamentoWhereUniqueInput | ProcessamentoWhereUniqueInput[]
    update?: ProcessamentoUpdateWithWhereUniqueWithoutDocumentoInput | ProcessamentoUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: ProcessamentoUpdateManyWithWhereWithoutDocumentoInput | ProcessamentoUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
  }

  export type AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput> | AIProcessingResultCreateWithoutDocumentInput[] | AIProcessingResultUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: AIProcessingResultCreateOrConnectWithoutDocumentInput | AIProcessingResultCreateOrConnectWithoutDocumentInput[]
    upsert?: AIProcessingResultUpsertWithWhereUniqueWithoutDocumentInput | AIProcessingResultUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: AIProcessingResultCreateManyDocumentInputEnvelope
    set?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    disconnect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    delete?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    connect?: AIProcessingResultWhereUniqueInput | AIProcessingResultWhereUniqueInput[]
    update?: AIProcessingResultUpdateWithWhereUniqueWithoutDocumentInput | AIProcessingResultUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: AIProcessingResultUpdateManyWithWhereWithoutDocumentInput | AIProcessingResultUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: AIProcessingResultScalarWhereInput | AIProcessingResultScalarWhereInput[]
  }

  export type XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput> | XMLDocumentCreateWithoutDocumentInput[] | XMLDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutDocumentInput | XMLDocumentCreateOrConnectWithoutDocumentInput[]
    upsert?: XMLDocumentUpsertWithWhereUniqueWithoutDocumentInput | XMLDocumentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: XMLDocumentCreateManyDocumentInputEnvelope
    set?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    disconnect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    delete?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    connect?: XMLDocumentWhereUniqueInput | XMLDocumentWhereUniqueInput[]
    update?: XMLDocumentUpdateWithWhereUniqueWithoutDocumentInput | XMLDocumentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: XMLDocumentUpdateManyWithWhereWithoutDocumentInput | XMLDocumentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
  }

  export type SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput> | SpedContribuicoesItemCreateWithoutDocumentInput[] | SpedContribuicoesItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesItemCreateOrConnectWithoutDocumentInput | SpedContribuicoesItemCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedContribuicoesItemUpsertWithWhereUniqueWithoutDocumentInput | SpedContribuicoesItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedContribuicoesItemCreateManyDocumentInputEnvelope
    set?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    disconnect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    delete?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    connect?: SpedContribuicoesItemWhereUniqueInput | SpedContribuicoesItemWhereUniqueInput[]
    update?: SpedContribuicoesItemUpdateWithWhereUniqueWithoutDocumentInput | SpedContribuicoesItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedContribuicoesItemUpdateManyWithWhereWithoutDocumentInput | SpedContribuicoesItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput> | SpedContribuicoesApuracaoCreateWithoutDocumentInput[] | SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput | SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutDocumentInput | SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedContribuicoesApuracaoCreateManyDocumentInputEnvelope
    set?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    disconnect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    delete?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    connect?: SpedContribuicoesApuracaoWhereUniqueInput | SpedContribuicoesApuracaoWhereUniqueInput[]
    update?: SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutDocumentInput | SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedContribuicoesApuracaoUpdateManyWithWhereWithoutDocumentInput | SpedContribuicoesApuracaoUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
  }

  export type SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput> | SpedFiscalItemCreateWithoutDocumentInput[] | SpedFiscalItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalItemCreateOrConnectWithoutDocumentInput | SpedFiscalItemCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedFiscalItemUpsertWithWhereUniqueWithoutDocumentInput | SpedFiscalItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedFiscalItemCreateManyDocumentInputEnvelope
    set?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    disconnect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    delete?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    connect?: SpedFiscalItemWhereUniqueInput | SpedFiscalItemWhereUniqueInput[]
    update?: SpedFiscalItemUpdateWithWhereUniqueWithoutDocumentInput | SpedFiscalItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedFiscalItemUpdateManyWithWhereWithoutDocumentInput | SpedFiscalItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
  }

  export type SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput> | SpedFiscalApuracaoCreateWithoutDocumentInput[] | SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput | SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput[]
    upsert?: SpedFiscalApuracaoUpsertWithWhereUniqueWithoutDocumentInput | SpedFiscalApuracaoUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SpedFiscalApuracaoCreateManyDocumentInputEnvelope
    set?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    disconnect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    delete?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    connect?: SpedFiscalApuracaoWhereUniqueInput | SpedFiscalApuracaoWhereUniqueInput[]
    update?: SpedFiscalApuracaoUpdateWithWhereUniqueWithoutDocumentInput | SpedFiscalApuracaoUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SpedFiscalApuracaoUpdateManyWithWhereWithoutDocumentInput | SpedFiscalApuracaoUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutAiResultsInput = {
    create?: XOR<DocumentCreateWithoutAiResultsInput, DocumentUncheckedCreateWithoutAiResultsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAiResultsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutAiResultsNestedInput = {
    create?: XOR<DocumentCreateWithoutAiResultsInput, DocumentUncheckedCreateWithoutAiResultsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutAiResultsInput
    upsert?: DocumentUpsertWithoutAiResultsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutAiResultsInput, DocumentUpdateWithoutAiResultsInput>, DocumentUncheckedUpdateWithoutAiResultsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type DocumentCreateNestedOneWithoutSpedContribuicoesItemsInput = {
    create?: XOR<DocumentCreateWithoutSpedContribuicoesItemsInput, DocumentUncheckedCreateWithoutSpedContribuicoesItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedContribuicoesItemsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutSpedContribuicoesItemsInput = {
    create?: XOR<EmpresaCreateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedCreateWithoutSpedContribuicoesItemsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedContribuicoesItemsInput
    connect?: EmpresaWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput = {
    create?: XOR<DocumentCreateWithoutSpedContribuicoesItemsInput, DocumentUncheckedCreateWithoutSpedContribuicoesItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedContribuicoesItemsInput
    upsert?: DocumentUpsertWithoutSpedContribuicoesItemsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSpedContribuicoesItemsInput, DocumentUpdateWithoutSpedContribuicoesItemsInput>, DocumentUncheckedUpdateWithoutSpedContribuicoesItemsInput>
  }

  export type EmpresaUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput = {
    create?: XOR<EmpresaCreateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedCreateWithoutSpedContribuicoesItemsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedContribuicoesItemsInput
    upsert?: EmpresaUpsertWithoutSpedContribuicoesItemsInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutSpedContribuicoesItemsInput, EmpresaUpdateWithoutSpedContribuicoesItemsInput>, EmpresaUncheckedUpdateWithoutSpedContribuicoesItemsInput>
  }

  export type DocumentCreateNestedOneWithoutSpedContribuicoesApuracoesInput = {
    create?: XOR<DocumentCreateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedCreateWithoutSpedContribuicoesApuracoesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedContribuicoesApuracoesInput
    connect?: DocumentWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutSpedContribuicoesApuracaoInput = {
    create?: XOR<EmpresaCreateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedCreateWithoutSpedContribuicoesApuracaoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedContribuicoesApuracaoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateOneRequiredWithoutSpedContribuicoesApuracoesNestedInput = {
    create?: XOR<DocumentCreateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedCreateWithoutSpedContribuicoesApuracoesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedContribuicoesApuracoesInput
    upsert?: DocumentUpsertWithoutSpedContribuicoesApuracoesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSpedContribuicoesApuracoesInput, DocumentUpdateWithoutSpedContribuicoesApuracoesInput>, DocumentUncheckedUpdateWithoutSpedContribuicoesApuracoesInput>
  }

  export type EmpresaUpdateOneRequiredWithoutSpedContribuicoesApuracaoNestedInput = {
    create?: XOR<EmpresaCreateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedCreateWithoutSpedContribuicoesApuracaoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedContribuicoesApuracaoInput
    upsert?: EmpresaUpsertWithoutSpedContribuicoesApuracaoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutSpedContribuicoesApuracaoInput, EmpresaUpdateWithoutSpedContribuicoesApuracaoInput>, EmpresaUncheckedUpdateWithoutSpedContribuicoesApuracaoInput>
  }

  export type DocumentCreateNestedOneWithoutSpedFiscalItemsInput = {
    create?: XOR<DocumentCreateWithoutSpedFiscalItemsInput, DocumentUncheckedCreateWithoutSpedFiscalItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedFiscalItemsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutSpedFiscalItemsInput = {
    create?: XOR<EmpresaCreateWithoutSpedFiscalItemsInput, EmpresaUncheckedCreateWithoutSpedFiscalItemsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedFiscalItemsInput
    connect?: EmpresaWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutSpedFiscalItemsNestedInput = {
    create?: XOR<DocumentCreateWithoutSpedFiscalItemsInput, DocumentUncheckedCreateWithoutSpedFiscalItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedFiscalItemsInput
    upsert?: DocumentUpsertWithoutSpedFiscalItemsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSpedFiscalItemsInput, DocumentUpdateWithoutSpedFiscalItemsInput>, DocumentUncheckedUpdateWithoutSpedFiscalItemsInput>
  }

  export type EmpresaUpdateOneRequiredWithoutSpedFiscalItemsNestedInput = {
    create?: XOR<EmpresaCreateWithoutSpedFiscalItemsInput, EmpresaUncheckedCreateWithoutSpedFiscalItemsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedFiscalItemsInput
    upsert?: EmpresaUpsertWithoutSpedFiscalItemsInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutSpedFiscalItemsInput, EmpresaUpdateWithoutSpedFiscalItemsInput>, EmpresaUncheckedUpdateWithoutSpedFiscalItemsInput>
  }

  export type DocumentCreateNestedOneWithoutSpedFiscalApuracoesInput = {
    create?: XOR<DocumentCreateWithoutSpedFiscalApuracoesInput, DocumentUncheckedCreateWithoutSpedFiscalApuracoesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedFiscalApuracoesInput
    connect?: DocumentWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutSpedFiscalApuracaoInput = {
    create?: XOR<EmpresaCreateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedCreateWithoutSpedFiscalApuracaoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedFiscalApuracaoInput
    connect?: EmpresaWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutSpedFiscalApuracoesNestedInput = {
    create?: XOR<DocumentCreateWithoutSpedFiscalApuracoesInput, DocumentUncheckedCreateWithoutSpedFiscalApuracoesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSpedFiscalApuracoesInput
    upsert?: DocumentUpsertWithoutSpedFiscalApuracoesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSpedFiscalApuracoesInput, DocumentUpdateWithoutSpedFiscalApuracoesInput>, DocumentUncheckedUpdateWithoutSpedFiscalApuracoesInput>
  }

  export type EmpresaUpdateOneRequiredWithoutSpedFiscalApuracaoNestedInput = {
    create?: XOR<EmpresaCreateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedCreateWithoutSpedFiscalApuracaoInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutSpedFiscalApuracaoInput
    upsert?: EmpresaUpsertWithoutSpedFiscalApuracaoInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutSpedFiscalApuracaoInput, EmpresaUpdateWithoutSpedFiscalApuracaoInput>, EmpresaUncheckedUpdateWithoutSpedFiscalApuracaoInput>
  }

  export type DocumentCreateNestedOneWithoutXmlDocumentsInput = {
    create?: XOR<DocumentCreateWithoutXmlDocumentsInput, DocumentUncheckedCreateWithoutXmlDocumentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutXmlDocumentsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EmpresaCreateNestedOneWithoutXmlDocumentsInput = {
    create?: XOR<EmpresaCreateWithoutXmlDocumentsInput, EmpresaUncheckedCreateWithoutXmlDocumentsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutXmlDocumentsInput
    connect?: EmpresaWhereUniqueInput
  }

  export type XMLItemCreateNestedManyWithoutXmlDocumentInput = {
    create?: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput> | XMLItemCreateWithoutXmlDocumentInput[] | XMLItemUncheckedCreateWithoutXmlDocumentInput[]
    connectOrCreate?: XMLItemCreateOrConnectWithoutXmlDocumentInput | XMLItemCreateOrConnectWithoutXmlDocumentInput[]
    createMany?: XMLItemCreateManyXmlDocumentInputEnvelope
    connect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
  }

  export type XMLItemUncheckedCreateNestedManyWithoutXmlDocumentInput = {
    create?: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput> | XMLItemCreateWithoutXmlDocumentInput[] | XMLItemUncheckedCreateWithoutXmlDocumentInput[]
    connectOrCreate?: XMLItemCreateOrConnectWithoutXmlDocumentInput | XMLItemCreateOrConnectWithoutXmlDocumentInput[]
    createMany?: XMLItemCreateManyXmlDocumentInputEnvelope
    connect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
  }

  export type DocumentUpdateOneRequiredWithoutXmlDocumentsNestedInput = {
    create?: XOR<DocumentCreateWithoutXmlDocumentsInput, DocumentUncheckedCreateWithoutXmlDocumentsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutXmlDocumentsInput
    upsert?: DocumentUpsertWithoutXmlDocumentsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutXmlDocumentsInput, DocumentUpdateWithoutXmlDocumentsInput>, DocumentUncheckedUpdateWithoutXmlDocumentsInput>
  }

  export type EmpresaUpdateOneRequiredWithoutXmlDocumentsNestedInput = {
    create?: XOR<EmpresaCreateWithoutXmlDocumentsInput, EmpresaUncheckedCreateWithoutXmlDocumentsInput>
    connectOrCreate?: EmpresaCreateOrConnectWithoutXmlDocumentsInput
    upsert?: EmpresaUpsertWithoutXmlDocumentsInput
    connect?: EmpresaWhereUniqueInput
    update?: XOR<XOR<EmpresaUpdateToOneWithWhereWithoutXmlDocumentsInput, EmpresaUpdateWithoutXmlDocumentsInput>, EmpresaUncheckedUpdateWithoutXmlDocumentsInput>
  }

  export type XMLItemUpdateManyWithoutXmlDocumentNestedInput = {
    create?: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput> | XMLItemCreateWithoutXmlDocumentInput[] | XMLItemUncheckedCreateWithoutXmlDocumentInput[]
    connectOrCreate?: XMLItemCreateOrConnectWithoutXmlDocumentInput | XMLItemCreateOrConnectWithoutXmlDocumentInput[]
    upsert?: XMLItemUpsertWithWhereUniqueWithoutXmlDocumentInput | XMLItemUpsertWithWhereUniqueWithoutXmlDocumentInput[]
    createMany?: XMLItemCreateManyXmlDocumentInputEnvelope
    set?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    disconnect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    delete?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    connect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    update?: XMLItemUpdateWithWhereUniqueWithoutXmlDocumentInput | XMLItemUpdateWithWhereUniqueWithoutXmlDocumentInput[]
    updateMany?: XMLItemUpdateManyWithWhereWithoutXmlDocumentInput | XMLItemUpdateManyWithWhereWithoutXmlDocumentInput[]
    deleteMany?: XMLItemScalarWhereInput | XMLItemScalarWhereInput[]
  }

  export type XMLItemUncheckedUpdateManyWithoutXmlDocumentNestedInput = {
    create?: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput> | XMLItemCreateWithoutXmlDocumentInput[] | XMLItemUncheckedCreateWithoutXmlDocumentInput[]
    connectOrCreate?: XMLItemCreateOrConnectWithoutXmlDocumentInput | XMLItemCreateOrConnectWithoutXmlDocumentInput[]
    upsert?: XMLItemUpsertWithWhereUniqueWithoutXmlDocumentInput | XMLItemUpsertWithWhereUniqueWithoutXmlDocumentInput[]
    createMany?: XMLItemCreateManyXmlDocumentInputEnvelope
    set?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    disconnect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    delete?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    connect?: XMLItemWhereUniqueInput | XMLItemWhereUniqueInput[]
    update?: XMLItemUpdateWithWhereUniqueWithoutXmlDocumentInput | XMLItemUpdateWithWhereUniqueWithoutXmlDocumentInput[]
    updateMany?: XMLItemUpdateManyWithWhereWithoutXmlDocumentInput | XMLItemUpdateManyWithWhereWithoutXmlDocumentInput[]
    deleteMany?: XMLItemScalarWhereInput | XMLItemScalarWhereInput[]
  }

  export type XMLDocumentCreateNestedOneWithoutItensInput = {
    create?: XOR<XMLDocumentCreateWithoutItensInput, XMLDocumentUncheckedCreateWithoutItensInput>
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutItensInput
    connect?: XMLDocumentWhereUniqueInput
  }

  export type XMLDocumentUpdateOneRequiredWithoutItensNestedInput = {
    create?: XOR<XMLDocumentCreateWithoutItensInput, XMLDocumentUncheckedCreateWithoutItensInput>
    connectOrCreate?: XMLDocumentCreateOrConnectWithoutItensInput
    upsert?: XMLDocumentUpsertWithoutItensInput
    connect?: XMLDocumentWhereUniqueInput
    update?: XOR<XOR<XMLDocumentUpdateToOneWithWhereWithoutItensInput, XMLDocumentUpdateWithoutItensInput>, XMLDocumentUncheckedUpdateWithoutItensInput>
  }

  export type UserCreateNestedOneWithoutProcessamentosInput = {
    create?: XOR<UserCreateWithoutProcessamentosInput, UserUncheckedCreateWithoutProcessamentosInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessamentosInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutProcessamentosInput = {
    create?: XOR<DocumentCreateWithoutProcessamentosInput, DocumentUncheckedCreateWithoutProcessamentosInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutProcessamentosInput
    connect?: DocumentWhereUniqueInput
  }

  export type EnumProcessamentoStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessamentoStatus
  }

  export type UserUpdateOneRequiredWithoutProcessamentosNestedInput = {
    create?: XOR<UserCreateWithoutProcessamentosInput, UserUncheckedCreateWithoutProcessamentosInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessamentosInput
    upsert?: UserUpsertWithoutProcessamentosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessamentosInput, UserUpdateWithoutProcessamentosInput>, UserUncheckedUpdateWithoutProcessamentosInput>
  }

  export type DocumentUpdateOneRequiredWithoutProcessamentosNestedInput = {
    create?: XOR<DocumentCreateWithoutProcessamentosInput, DocumentUncheckedCreateWithoutProcessamentosInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutProcessamentosInput
    upsert?: DocumentUpsertWithoutProcessamentosInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutProcessamentosInput, DocumentUpdateWithoutProcessamentosInput>, DocumentUncheckedUpdateWithoutProcessamentosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumProcessamentoStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessamentoStatus | EnumProcessamentoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessamentoStatusFilter<$PrismaModel> | $Enums.ProcessamentoStatus
  }

  export type NestedEnumProcessamentoStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessamentoStatus | EnumProcessamentoStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessamentoStatus[] | ListEnumProcessamentoStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessamentoStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessamentoStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessamentoStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessamentoStatusFilter<$PrismaModel>
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcessamentoCreateWithoutUserInput = {
    id?: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    documento: DocumentCreateNestedOneWithoutProcessamentosInput
  }

  export type ProcessamentoUncheckedCreateWithoutUserInput = {
    id?: string
    documentoId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessamentoCreateOrConnectWithoutUserInput = {
    where: ProcessamentoWhereUniqueInput
    create: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput>
  }

  export type ProcessamentoCreateManyUserInputEnvelope = {
    data: ProcessamentoCreateManyUserInput | ProcessamentoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    mimeType?: StringFilter<"Document"> | string
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    metadata?: JsonNullableFilter<"Document">
    empresaId?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type ProcessamentoUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessamentoWhereUniqueInput
    update: XOR<ProcessamentoUpdateWithoutUserInput, ProcessamentoUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessamentoCreateWithoutUserInput, ProcessamentoUncheckedCreateWithoutUserInput>
  }

  export type ProcessamentoUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessamentoWhereUniqueInput
    data: XOR<ProcessamentoUpdateWithoutUserInput, ProcessamentoUncheckedUpdateWithoutUserInput>
  }

  export type ProcessamentoUpdateManyWithWhereWithoutUserInput = {
    where: ProcessamentoScalarWhereInput
    data: XOR<ProcessamentoUpdateManyMutationInput, ProcessamentoUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessamentoScalarWhereInput = {
    AND?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
    OR?: ProcessamentoScalarWhereInput[]
    NOT?: ProcessamentoScalarWhereInput | ProcessamentoScalarWhereInput[]
    id?: StringFilter<"Processamento"> | string
    userId?: StringFilter<"Processamento"> | string
    documentoId?: StringFilter<"Processamento"> | string
    status?: EnumProcessamentoStatusFilter<"Processamento"> | $Enums.ProcessamentoStatus
    resultado?: JsonNullableFilter<"Processamento">
    createdAt?: DateTimeFilter<"Processamento"> | Date | string
    updatedAt?: DateTimeFilter<"Processamento"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    level?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    message?: StringFilter<"Log"> | string
    metadata?: JsonNullableFilter<"Log">
    userId?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentCreateWithoutEmpresaInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutEmpresaInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutEmpresaInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput>
  }

  export type DocumentCreateManyEmpresaInputEnvelope = {
    data: DocumentCreateManyEmpresaInput | DocumentCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type SpedContribuicoesItemCreateWithoutEmpresaInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedContribuicoesItemsInput
  }

  export type SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput = {
    id?: string
    documentId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesItemCreateOrConnectWithoutEmpresaInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    create: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedContribuicoesItemCreateManyEmpresaInputEnvelope = {
    data: SpedContribuicoesItemCreateManyEmpresaInput | SpedContribuicoesItemCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type SpedContribuicoesApuracaoCreateWithoutEmpresaInput = {
    id?: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedContribuicoesApuracoesInput
  }

  export type SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput = {
    id?: string
    documentId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoCreateOrConnectWithoutEmpresaInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    create: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedContribuicoesApuracaoCreateManyEmpresaInputEnvelope = {
    data: SpedContribuicoesApuracaoCreateManyEmpresaInput | SpedContribuicoesApuracaoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type SpedFiscalItemCreateWithoutEmpresaInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedFiscalItemsInput
  }

  export type SpedFiscalItemUncheckedCreateWithoutEmpresaInput = {
    id?: string
    documentId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemCreateOrConnectWithoutEmpresaInput = {
    where: SpedFiscalItemWhereUniqueInput
    create: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedFiscalItemCreateManyEmpresaInputEnvelope = {
    data: SpedFiscalItemCreateManyEmpresaInput | SpedFiscalItemCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type SpedFiscalApuracaoCreateWithoutEmpresaInput = {
    id?: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSpedFiscalApuracoesInput
  }

  export type SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput = {
    id?: string
    documentId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoCreateOrConnectWithoutEmpresaInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    create: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedFiscalApuracaoCreateManyEmpresaInputEnvelope = {
    data: SpedFiscalApuracaoCreateManyEmpresaInput | SpedFiscalApuracaoCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type XMLDocumentCreateWithoutEmpresaInput = {
    id?: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutXmlDocumentsInput
    itens?: XMLItemCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentUncheckedCreateWithoutEmpresaInput = {
    id?: string
    documentId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itens?: XMLItemUncheckedCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentCreateOrConnectWithoutEmpresaInput = {
    where: XMLDocumentWhereUniqueInput
    create: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput>
  }

  export type XMLDocumentCreateManyEmpresaInputEnvelope = {
    data: XMLDocumentCreateManyEmpresaInput | XMLDocumentCreateManyEmpresaInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutEmpresaInput, DocumentUncheckedUpdateWithoutEmpresaInput>
    create: XOR<DocumentCreateWithoutEmpresaInput, DocumentUncheckedCreateWithoutEmpresaInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutEmpresaInput, DocumentUncheckedUpdateWithoutEmpresaInput>
  }

  export type DocumentUpdateManyWithWhereWithoutEmpresaInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type SpedContribuicoesItemUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    update: XOR<SpedContribuicoesItemUpdateWithoutEmpresaInput, SpedContribuicoesItemUncheckedUpdateWithoutEmpresaInput>
    create: XOR<SpedContribuicoesItemCreateWithoutEmpresaInput, SpedContribuicoesItemUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedContribuicoesItemUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    data: XOR<SpedContribuicoesItemUpdateWithoutEmpresaInput, SpedContribuicoesItemUncheckedUpdateWithoutEmpresaInput>
  }

  export type SpedContribuicoesItemUpdateManyWithWhereWithoutEmpresaInput = {
    where: SpedContribuicoesItemScalarWhereInput
    data: XOR<SpedContribuicoesItemUpdateManyMutationInput, SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type SpedContribuicoesItemScalarWhereInput = {
    AND?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
    OR?: SpedContribuicoesItemScalarWhereInput[]
    NOT?: SpedContribuicoesItemScalarWhereInput | SpedContribuicoesItemScalarWhereInput[]
    id?: StringFilter<"SpedContribuicoesItem"> | string
    documentId?: StringFilter<"SpedContribuicoesItem"> | string
    empresaId?: StringFilter<"SpedContribuicoesItem"> | string
    documento?: StringFilter<"SpedContribuicoesItem"> | string
    data?: StringFilter<"SpedContribuicoesItem"> | string
    cnpj?: StringFilter<"SpedContribuicoesItem"> | string
    produto?: StringFilter<"SpedContribuicoesItem"> | string
    cfop?: StringFilter<"SpedContribuicoesItem"> | string
    cst?: StringFilter<"SpedContribuicoesItem"> | string
    valor?: FloatFilter<"SpedContribuicoesItem"> | number
    basePis?: FloatFilter<"SpedContribuicoesItem"> | number
    valorPis?: FloatFilter<"SpedContribuicoesItem"> | number
    baseCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    valorCofins?: FloatFilter<"SpedContribuicoesItem"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesItem"> | Date | string
  }

  export type SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    update: XOR<SpedContribuicoesApuracaoUpdateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<SpedContribuicoesApuracaoCreateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    data: XOR<SpedContribuicoesApuracaoUpdateWithoutEmpresaInput, SpedContribuicoesApuracaoUncheckedUpdateWithoutEmpresaInput>
  }

  export type SpedContribuicoesApuracaoUpdateManyWithWhereWithoutEmpresaInput = {
    where: SpedContribuicoesApuracaoScalarWhereInput
    data: XOR<SpedContribuicoesApuracaoUpdateManyMutationInput, SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type SpedContribuicoesApuracaoScalarWhereInput = {
    AND?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
    OR?: SpedContribuicoesApuracaoScalarWhereInput[]
    NOT?: SpedContribuicoesApuracaoScalarWhereInput | SpedContribuicoesApuracaoScalarWhereInput[]
    id?: StringFilter<"SpedContribuicoesApuracao"> | string
    documentId?: StringFilter<"SpedContribuicoesApuracao"> | string
    empresaId?: StringFilter<"SpedContribuicoesApuracao"> | string
    tipo?: StringFilter<"SpedContribuicoesApuracao"> | string
    periodo?: StringFilter<"SpedContribuicoesApuracao"> | string
    base?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    aliquota?: FloatNullableFilter<"SpedContribuicoesApuracao"> | number | null
    valor?: FloatFilter<"SpedContribuicoesApuracao"> | number
    createdAt?: DateTimeFilter<"SpedContribuicoesApuracao"> | Date | string
  }

  export type SpedFiscalItemUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: SpedFiscalItemWhereUniqueInput
    update: XOR<SpedFiscalItemUpdateWithoutEmpresaInput, SpedFiscalItemUncheckedUpdateWithoutEmpresaInput>
    create: XOR<SpedFiscalItemCreateWithoutEmpresaInput, SpedFiscalItemUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedFiscalItemUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: SpedFiscalItemWhereUniqueInput
    data: XOR<SpedFiscalItemUpdateWithoutEmpresaInput, SpedFiscalItemUncheckedUpdateWithoutEmpresaInput>
  }

  export type SpedFiscalItemUpdateManyWithWhereWithoutEmpresaInput = {
    where: SpedFiscalItemScalarWhereInput
    data: XOR<SpedFiscalItemUpdateManyMutationInput, SpedFiscalItemUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type SpedFiscalItemScalarWhereInput = {
    AND?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
    OR?: SpedFiscalItemScalarWhereInput[]
    NOT?: SpedFiscalItemScalarWhereInput | SpedFiscalItemScalarWhereInput[]
    id?: StringFilter<"SpedFiscalItem"> | string
    documentId?: StringFilter<"SpedFiscalItem"> | string
    empresaId?: StringFilter<"SpedFiscalItem"> | string
    documento?: StringFilter<"SpedFiscalItem"> | string
    data?: StringFilter<"SpedFiscalItem"> | string
    cnpj?: StringFilter<"SpedFiscalItem"> | string
    produto?: StringFilter<"SpedFiscalItem"> | string
    cfop?: StringFilter<"SpedFiscalItem"> | string
    cst?: StringFilter<"SpedFiscalItem"> | string
    ncm?: StringFilter<"SpedFiscalItem"> | string
    valor?: FloatFilter<"SpedFiscalItem"> | number
    baseIcms?: FloatFilter<"SpedFiscalItem"> | number
    valorIcms?: FloatFilter<"SpedFiscalItem"> | number
    baseIpi?: FloatFilter<"SpedFiscalItem"> | number
    valorIpi?: FloatFilter<"SpedFiscalItem"> | number
    createdAt?: DateTimeFilter<"SpedFiscalItem"> | Date | string
  }

  export type SpedFiscalApuracaoUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    update: XOR<SpedFiscalApuracaoUpdateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedUpdateWithoutEmpresaInput>
    create: XOR<SpedFiscalApuracaoCreateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedCreateWithoutEmpresaInput>
  }

  export type SpedFiscalApuracaoUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    data: XOR<SpedFiscalApuracaoUpdateWithoutEmpresaInput, SpedFiscalApuracaoUncheckedUpdateWithoutEmpresaInput>
  }

  export type SpedFiscalApuracaoUpdateManyWithWhereWithoutEmpresaInput = {
    where: SpedFiscalApuracaoScalarWhereInput
    data: XOR<SpedFiscalApuracaoUpdateManyMutationInput, SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type SpedFiscalApuracaoScalarWhereInput = {
    AND?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
    OR?: SpedFiscalApuracaoScalarWhereInput[]
    NOT?: SpedFiscalApuracaoScalarWhereInput | SpedFiscalApuracaoScalarWhereInput[]
    id?: StringFilter<"SpedFiscalApuracao"> | string
    documentId?: StringFilter<"SpedFiscalApuracao"> | string
    empresaId?: StringFilter<"SpedFiscalApuracao"> | string
    cst?: StringFilter<"SpedFiscalApuracao"> | string
    cfop?: StringFilter<"SpedFiscalApuracao"> | string
    aliquota?: FloatFilter<"SpedFiscalApuracao"> | number
    valorOperacao?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcms?: FloatFilter<"SpedFiscalApuracao"> | number
    baseIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIcmsSt?: FloatFilter<"SpedFiscalApuracao"> | number
    valorRedBc?: FloatFilter<"SpedFiscalApuracao"> | number
    valorIpi?: FloatFilter<"SpedFiscalApuracao"> | number
    createdAt?: DateTimeFilter<"SpedFiscalApuracao"> | Date | string
  }

  export type XMLDocumentUpsertWithWhereUniqueWithoutEmpresaInput = {
    where: XMLDocumentWhereUniqueInput
    update: XOR<XMLDocumentUpdateWithoutEmpresaInput, XMLDocumentUncheckedUpdateWithoutEmpresaInput>
    create: XOR<XMLDocumentCreateWithoutEmpresaInput, XMLDocumentUncheckedCreateWithoutEmpresaInput>
  }

  export type XMLDocumentUpdateWithWhereUniqueWithoutEmpresaInput = {
    where: XMLDocumentWhereUniqueInput
    data: XOR<XMLDocumentUpdateWithoutEmpresaInput, XMLDocumentUncheckedUpdateWithoutEmpresaInput>
  }

  export type XMLDocumentUpdateManyWithWhereWithoutEmpresaInput = {
    where: XMLDocumentScalarWhereInput
    data: XOR<XMLDocumentUpdateManyMutationInput, XMLDocumentUncheckedUpdateManyWithoutEmpresaInput>
  }

  export type XMLDocumentScalarWhereInput = {
    AND?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
    OR?: XMLDocumentScalarWhereInput[]
    NOT?: XMLDocumentScalarWhereInput | XMLDocumentScalarWhereInput[]
    id?: StringFilter<"XMLDocument"> | string
    documentId?: StringFilter<"XMLDocument"> | string
    empresaId?: StringFilter<"XMLDocument"> | string
    tipoDocumento?: StringFilter<"XMLDocument"> | string
    numeroDocumento?: StringFilter<"XMLDocument"> | string
    serie?: StringFilter<"XMLDocument"> | string
    dataEmissao?: DateTimeFilter<"XMLDocument"> | Date | string
    valorTotal?: FloatFilter<"XMLDocument"> | number
    cnpjEmitente?: StringFilter<"XMLDocument"> | string
    cnpjDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    cpfDestinatario?: StringNullableFilter<"XMLDocument"> | string | null
    chaveAcesso?: StringNullableFilter<"XMLDocument"> | string | null
    protocolo?: StringNullableFilter<"XMLDocument"> | string | null
    status?: StringFilter<"XMLDocument"> | string
    observacoes?: StringNullableFilter<"XMLDocument"> | string | null
    valorTotalIcms?: FloatFilter<"XMLDocument"> | number
    valorTotalIpi?: FloatNullableFilter<"XMLDocument"> | number | null
    valorTotalPis?: FloatFilter<"XMLDocument"> | number
    valorTotalCofins?: FloatFilter<"XMLDocument"> | number
    valorTotalIss?: FloatNullableFilter<"XMLDocument"> | number | null
    baseCalculoIcms?: FloatFilter<"XMLDocument"> | number
    baseCalculoPis?: FloatFilter<"XMLDocument"> | number
    baseCalculoCofins?: FloatFilter<"XMLDocument"> | number
    createdAt?: DateTimeFilter<"XMLDocument"> | Date | string
    updatedAt?: DateTimeFilter<"XMLDocument"> | Date | string
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type EmpresaCreateWithoutDocumentosInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutDocumentosInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutDocumentosInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutDocumentosInput, EmpresaUncheckedCreateWithoutDocumentosInput>
  }

  export type ProcessamentoCreateWithoutDocumentoInput = {
    id?: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessamentosInput
  }

  export type ProcessamentoUncheckedCreateWithoutDocumentoInput = {
    id?: string
    userId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessamentoCreateOrConnectWithoutDocumentoInput = {
    where: ProcessamentoWhereUniqueInput
    create: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput>
  }

  export type ProcessamentoCreateManyDocumentoInputEnvelope = {
    data: ProcessamentoCreateManyDocumentoInput | ProcessamentoCreateManyDocumentoInput[]
    skipDuplicates?: boolean
  }

  export type AIProcessingResultCreateWithoutDocumentInput = {
    id?: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
  }

  export type AIProcessingResultUncheckedCreateWithoutDocumentInput = {
    id?: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
  }

  export type AIProcessingResultCreateOrConnectWithoutDocumentInput = {
    where: AIProcessingResultWhereUniqueInput
    create: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput>
  }

  export type AIProcessingResultCreateManyDocumentInputEnvelope = {
    data: AIProcessingResultCreateManyDocumentInput | AIProcessingResultCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type XMLDocumentCreateWithoutDocumentInput = {
    id?: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutXmlDocumentsInput
    itens?: XMLItemCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentUncheckedCreateWithoutDocumentInput = {
    id?: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itens?: XMLItemUncheckedCreateNestedManyWithoutXmlDocumentInput
  }

  export type XMLDocumentCreateOrConnectWithoutDocumentInput = {
    where: XMLDocumentWhereUniqueInput
    create: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type XMLDocumentCreateManyDocumentInputEnvelope = {
    data: XMLDocumentCreateManyDocumentInput | XMLDocumentCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SpedContribuicoesItemCreateWithoutDocumentInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutSpedContribuicoesItemsInput
  }

  export type SpedContribuicoesItemUncheckedCreateWithoutDocumentInput = {
    id?: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesItemCreateOrConnectWithoutDocumentInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    create: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput>
  }

  export type SpedContribuicoesItemCreateManyDocumentInputEnvelope = {
    data: SpedContribuicoesItemCreateManyDocumentInput | SpedContribuicoesItemCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SpedContribuicoesApuracaoCreateWithoutDocumentInput = {
    id?: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutSpedContribuicoesApuracaoInput
  }

  export type SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput = {
    id?: string
    empresaId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoCreateOrConnectWithoutDocumentInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    create: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput>
  }

  export type SpedContribuicoesApuracaoCreateManyDocumentInputEnvelope = {
    data: SpedContribuicoesApuracaoCreateManyDocumentInput | SpedContribuicoesApuracaoCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SpedFiscalItemCreateWithoutDocumentInput = {
    id?: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutSpedFiscalItemsInput
  }

  export type SpedFiscalItemUncheckedCreateWithoutDocumentInput = {
    id?: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemCreateOrConnectWithoutDocumentInput = {
    where: SpedFiscalItemWhereUniqueInput
    create: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput>
  }

  export type SpedFiscalItemCreateManyDocumentInputEnvelope = {
    data: SpedFiscalItemCreateManyDocumentInput | SpedFiscalItemCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SpedFiscalApuracaoCreateWithoutDocumentInput = {
    id?: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
    empresa: EmpresaCreateNestedOneWithoutSpedFiscalApuracaoInput
  }

  export type SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput = {
    id?: string
    empresaId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoCreateOrConnectWithoutDocumentInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    create: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput>
  }

  export type SpedFiscalApuracaoCreateManyDocumentInputEnvelope = {
    data: SpedFiscalApuracaoCreateManyDocumentInput | SpedFiscalApuracaoCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmpresaUpsertWithoutDocumentosInput = {
    update: XOR<EmpresaUpdateWithoutDocumentosInput, EmpresaUncheckedUpdateWithoutDocumentosInput>
    create: XOR<EmpresaCreateWithoutDocumentosInput, EmpresaUncheckedCreateWithoutDocumentosInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutDocumentosInput, EmpresaUncheckedUpdateWithoutDocumentosInput>
  }

  export type EmpresaUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type ProcessamentoUpsertWithWhereUniqueWithoutDocumentoInput = {
    where: ProcessamentoWhereUniqueInput
    update: XOR<ProcessamentoUpdateWithoutDocumentoInput, ProcessamentoUncheckedUpdateWithoutDocumentoInput>
    create: XOR<ProcessamentoCreateWithoutDocumentoInput, ProcessamentoUncheckedCreateWithoutDocumentoInput>
  }

  export type ProcessamentoUpdateWithWhereUniqueWithoutDocumentoInput = {
    where: ProcessamentoWhereUniqueInput
    data: XOR<ProcessamentoUpdateWithoutDocumentoInput, ProcessamentoUncheckedUpdateWithoutDocumentoInput>
  }

  export type ProcessamentoUpdateManyWithWhereWithoutDocumentoInput = {
    where: ProcessamentoScalarWhereInput
    data: XOR<ProcessamentoUpdateManyMutationInput, ProcessamentoUncheckedUpdateManyWithoutDocumentoInput>
  }

  export type AIProcessingResultUpsertWithWhereUniqueWithoutDocumentInput = {
    where: AIProcessingResultWhereUniqueInput
    update: XOR<AIProcessingResultUpdateWithoutDocumentInput, AIProcessingResultUncheckedUpdateWithoutDocumentInput>
    create: XOR<AIProcessingResultCreateWithoutDocumentInput, AIProcessingResultUncheckedCreateWithoutDocumentInput>
  }

  export type AIProcessingResultUpdateWithWhereUniqueWithoutDocumentInput = {
    where: AIProcessingResultWhereUniqueInput
    data: XOR<AIProcessingResultUpdateWithoutDocumentInput, AIProcessingResultUncheckedUpdateWithoutDocumentInput>
  }

  export type AIProcessingResultUpdateManyWithWhereWithoutDocumentInput = {
    where: AIProcessingResultScalarWhereInput
    data: XOR<AIProcessingResultUpdateManyMutationInput, AIProcessingResultUncheckedUpdateManyWithoutDocumentInput>
  }

  export type AIProcessingResultScalarWhereInput = {
    AND?: AIProcessingResultScalarWhereInput | AIProcessingResultScalarWhereInput[]
    OR?: AIProcessingResultScalarWhereInput[]
    NOT?: AIProcessingResultScalarWhereInput | AIProcessingResultScalarWhereInput[]
    id?: StringFilter<"AIProcessingResult"> | string
    documentId?: StringFilter<"AIProcessingResult"> | string
    model?: StringFilter<"AIProcessingResult"> | string
    tokens?: IntFilter<"AIProcessingResult"> | number
    processingTime?: IntFilter<"AIProcessingResult"> | number
    result?: JsonFilter<"AIProcessingResult">
    error?: StringNullableFilter<"AIProcessingResult"> | string | null
    createdAt?: DateTimeFilter<"AIProcessingResult"> | Date | string
  }

  export type XMLDocumentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: XMLDocumentWhereUniqueInput
    update: XOR<XMLDocumentUpdateWithoutDocumentInput, XMLDocumentUncheckedUpdateWithoutDocumentInput>
    create: XOR<XMLDocumentCreateWithoutDocumentInput, XMLDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type XMLDocumentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: XMLDocumentWhereUniqueInput
    data: XOR<XMLDocumentUpdateWithoutDocumentInput, XMLDocumentUncheckedUpdateWithoutDocumentInput>
  }

  export type XMLDocumentUpdateManyWithWhereWithoutDocumentInput = {
    where: XMLDocumentScalarWhereInput
    data: XOR<XMLDocumentUpdateManyMutationInput, XMLDocumentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type SpedContribuicoesItemUpsertWithWhereUniqueWithoutDocumentInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    update: XOR<SpedContribuicoesItemUpdateWithoutDocumentInput, SpedContribuicoesItemUncheckedUpdateWithoutDocumentInput>
    create: XOR<SpedContribuicoesItemCreateWithoutDocumentInput, SpedContribuicoesItemUncheckedCreateWithoutDocumentInput>
  }

  export type SpedContribuicoesItemUpdateWithWhereUniqueWithoutDocumentInput = {
    where: SpedContribuicoesItemWhereUniqueInput
    data: XOR<SpedContribuicoesItemUpdateWithoutDocumentInput, SpedContribuicoesItemUncheckedUpdateWithoutDocumentInput>
  }

  export type SpedContribuicoesItemUpdateManyWithWhereWithoutDocumentInput = {
    where: SpedContribuicoesItemScalarWhereInput
    data: XOR<SpedContribuicoesItemUpdateManyMutationInput, SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentInput>
  }

  export type SpedContribuicoesApuracaoUpsertWithWhereUniqueWithoutDocumentInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    update: XOR<SpedContribuicoesApuracaoUpdateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedUpdateWithoutDocumentInput>
    create: XOR<SpedContribuicoesApuracaoCreateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedCreateWithoutDocumentInput>
  }

  export type SpedContribuicoesApuracaoUpdateWithWhereUniqueWithoutDocumentInput = {
    where: SpedContribuicoesApuracaoWhereUniqueInput
    data: XOR<SpedContribuicoesApuracaoUpdateWithoutDocumentInput, SpedContribuicoesApuracaoUncheckedUpdateWithoutDocumentInput>
  }

  export type SpedContribuicoesApuracaoUpdateManyWithWhereWithoutDocumentInput = {
    where: SpedContribuicoesApuracaoScalarWhereInput
    data: XOR<SpedContribuicoesApuracaoUpdateManyMutationInput, SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentInput>
  }

  export type SpedFiscalItemUpsertWithWhereUniqueWithoutDocumentInput = {
    where: SpedFiscalItemWhereUniqueInput
    update: XOR<SpedFiscalItemUpdateWithoutDocumentInput, SpedFiscalItemUncheckedUpdateWithoutDocumentInput>
    create: XOR<SpedFiscalItemCreateWithoutDocumentInput, SpedFiscalItemUncheckedCreateWithoutDocumentInput>
  }

  export type SpedFiscalItemUpdateWithWhereUniqueWithoutDocumentInput = {
    where: SpedFiscalItemWhereUniqueInput
    data: XOR<SpedFiscalItemUpdateWithoutDocumentInput, SpedFiscalItemUncheckedUpdateWithoutDocumentInput>
  }

  export type SpedFiscalItemUpdateManyWithWhereWithoutDocumentInput = {
    where: SpedFiscalItemScalarWhereInput
    data: XOR<SpedFiscalItemUpdateManyMutationInput, SpedFiscalItemUncheckedUpdateManyWithoutDocumentInput>
  }

  export type SpedFiscalApuracaoUpsertWithWhereUniqueWithoutDocumentInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    update: XOR<SpedFiscalApuracaoUpdateWithoutDocumentInput, SpedFiscalApuracaoUncheckedUpdateWithoutDocumentInput>
    create: XOR<SpedFiscalApuracaoCreateWithoutDocumentInput, SpedFiscalApuracaoUncheckedCreateWithoutDocumentInput>
  }

  export type SpedFiscalApuracaoUpdateWithWhereUniqueWithoutDocumentInput = {
    where: SpedFiscalApuracaoWhereUniqueInput
    data: XOR<SpedFiscalApuracaoUpdateWithoutDocumentInput, SpedFiscalApuracaoUncheckedUpdateWithoutDocumentInput>
  }

  export type SpedFiscalApuracaoUpdateManyWithWhereWithoutDocumentInput = {
    where: SpedFiscalApuracaoScalarWhereInput
    data: XOR<SpedFiscalApuracaoUpdateManyMutationInput, SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentCreateWithoutAiResultsInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutAiResultsInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutAiResultsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAiResultsInput, DocumentUncheckedCreateWithoutAiResultsInput>
  }

  export type DocumentUpsertWithoutAiResultsInput = {
    update: XOR<DocumentUpdateWithoutAiResultsInput, DocumentUncheckedUpdateWithoutAiResultsInput>
    create: XOR<DocumentCreateWithoutAiResultsInput, DocumentUncheckedCreateWithoutAiResultsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutAiResultsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutAiResultsInput, DocumentUncheckedUpdateWithoutAiResultsInput>
  }

  export type DocumentUpdateWithoutAiResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAiResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentCreateWithoutSpedContribuicoesItemsInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSpedContribuicoesItemsInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSpedContribuicoesItemsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSpedContribuicoesItemsInput, DocumentUncheckedCreateWithoutSpedContribuicoesItemsInput>
  }

  export type EmpresaCreateWithoutSpedContribuicoesItemsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutSpedContribuicoesItemsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutSpedContribuicoesItemsInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedCreateWithoutSpedContribuicoesItemsInput>
  }

  export type DocumentUpsertWithoutSpedContribuicoesItemsInput = {
    update: XOR<DocumentUpdateWithoutSpedContribuicoesItemsInput, DocumentUncheckedUpdateWithoutSpedContribuicoesItemsInput>
    create: XOR<DocumentCreateWithoutSpedContribuicoesItemsInput, DocumentUncheckedCreateWithoutSpedContribuicoesItemsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSpedContribuicoesItemsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSpedContribuicoesItemsInput, DocumentUncheckedUpdateWithoutSpedContribuicoesItemsInput>
  }

  export type DocumentUpdateWithoutSpedContribuicoesItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSpedContribuicoesItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EmpresaUpsertWithoutSpedContribuicoesItemsInput = {
    update: XOR<EmpresaUpdateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedUpdateWithoutSpedContribuicoesItemsInput>
    create: XOR<EmpresaCreateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedCreateWithoutSpedContribuicoesItemsInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutSpedContribuicoesItemsInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutSpedContribuicoesItemsInput, EmpresaUncheckedUpdateWithoutSpedContribuicoesItemsInput>
  }

  export type EmpresaUpdateWithoutSpedContribuicoesItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutSpedContribuicoesItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type DocumentCreateWithoutSpedContribuicoesApuracoesInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSpedContribuicoesApuracoesInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSpedContribuicoesApuracoesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedCreateWithoutSpedContribuicoesApuracoesInput>
  }

  export type EmpresaCreateWithoutSpedContribuicoesApuracaoInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutSpedContribuicoesApuracaoInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutSpedContribuicoesApuracaoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedCreateWithoutSpedContribuicoesApuracaoInput>
  }

  export type DocumentUpsertWithoutSpedContribuicoesApuracoesInput = {
    update: XOR<DocumentUpdateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedUpdateWithoutSpedContribuicoesApuracoesInput>
    create: XOR<DocumentCreateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedCreateWithoutSpedContribuicoesApuracoesInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSpedContribuicoesApuracoesInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSpedContribuicoesApuracoesInput, DocumentUncheckedUpdateWithoutSpedContribuicoesApuracoesInput>
  }

  export type DocumentUpdateWithoutSpedContribuicoesApuracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSpedContribuicoesApuracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EmpresaUpsertWithoutSpedContribuicoesApuracaoInput = {
    update: XOR<EmpresaUpdateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedUpdateWithoutSpedContribuicoesApuracaoInput>
    create: XOR<EmpresaCreateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedCreateWithoutSpedContribuicoesApuracaoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutSpedContribuicoesApuracaoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutSpedContribuicoesApuracaoInput, EmpresaUncheckedUpdateWithoutSpedContribuicoesApuracaoInput>
  }

  export type EmpresaUpdateWithoutSpedContribuicoesApuracaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutSpedContribuicoesApuracaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type DocumentCreateWithoutSpedFiscalItemsInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSpedFiscalItemsInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSpedFiscalItemsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSpedFiscalItemsInput, DocumentUncheckedCreateWithoutSpedFiscalItemsInput>
  }

  export type EmpresaCreateWithoutSpedFiscalItemsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutSpedFiscalItemsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutSpedFiscalItemsInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutSpedFiscalItemsInput, EmpresaUncheckedCreateWithoutSpedFiscalItemsInput>
  }

  export type DocumentUpsertWithoutSpedFiscalItemsInput = {
    update: XOR<DocumentUpdateWithoutSpedFiscalItemsInput, DocumentUncheckedUpdateWithoutSpedFiscalItemsInput>
    create: XOR<DocumentCreateWithoutSpedFiscalItemsInput, DocumentUncheckedCreateWithoutSpedFiscalItemsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSpedFiscalItemsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSpedFiscalItemsInput, DocumentUncheckedUpdateWithoutSpedFiscalItemsInput>
  }

  export type DocumentUpdateWithoutSpedFiscalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSpedFiscalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EmpresaUpsertWithoutSpedFiscalItemsInput = {
    update: XOR<EmpresaUpdateWithoutSpedFiscalItemsInput, EmpresaUncheckedUpdateWithoutSpedFiscalItemsInput>
    create: XOR<EmpresaCreateWithoutSpedFiscalItemsInput, EmpresaUncheckedCreateWithoutSpedFiscalItemsInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutSpedFiscalItemsInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutSpedFiscalItemsInput, EmpresaUncheckedUpdateWithoutSpedFiscalItemsInput>
  }

  export type EmpresaUpdateWithoutSpedFiscalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutSpedFiscalItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type DocumentCreateWithoutSpedFiscalApuracoesInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutSpedFiscalApuracoesInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutSpedFiscalApuracoesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSpedFiscalApuracoesInput, DocumentUncheckedCreateWithoutSpedFiscalApuracoesInput>
  }

  export type EmpresaCreateWithoutSpedFiscalApuracaoInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutSpedFiscalApuracaoInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutSpedFiscalApuracaoInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedCreateWithoutSpedFiscalApuracaoInput>
  }

  export type DocumentUpsertWithoutSpedFiscalApuracoesInput = {
    update: XOR<DocumentUpdateWithoutSpedFiscalApuracoesInput, DocumentUncheckedUpdateWithoutSpedFiscalApuracoesInput>
    create: XOR<DocumentCreateWithoutSpedFiscalApuracoesInput, DocumentUncheckedCreateWithoutSpedFiscalApuracoesInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSpedFiscalApuracoesInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSpedFiscalApuracoesInput, DocumentUncheckedUpdateWithoutSpedFiscalApuracoesInput>
  }

  export type DocumentUpdateWithoutSpedFiscalApuracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutSpedFiscalApuracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EmpresaUpsertWithoutSpedFiscalApuracaoInput = {
    update: XOR<EmpresaUpdateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedUpdateWithoutSpedFiscalApuracaoInput>
    create: XOR<EmpresaCreateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedCreateWithoutSpedFiscalApuracaoInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutSpedFiscalApuracaoInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutSpedFiscalApuracaoInput, EmpresaUncheckedUpdateWithoutSpedFiscalApuracaoInput>
  }

  export type EmpresaUpdateWithoutSpedFiscalApuracaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutSpedFiscalApuracaoInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type DocumentCreateWithoutXmlDocumentsInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    processamentos?: ProcessamentoCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutXmlDocumentsInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processamentos?: ProcessamentoUncheckedCreateNestedManyWithoutDocumentoInput
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutXmlDocumentsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutXmlDocumentsInput, DocumentUncheckedCreateWithoutXmlDocumentsInput>
  }

  export type EmpresaCreateWithoutXmlDocumentsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaUncheckedCreateWithoutXmlDocumentsInput = {
    id?: string
    cnpj: string
    razaoSocial: string
    nomeFantasia?: string | null
    ie?: string | null
    im?: string | null
    cnae?: string | null
    endereco?: string | null
    regimeTributario?: string | null
    dataCadastro?: Date | string
    updatedAt?: Date | string
    documentos?: DocumentUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutEmpresaInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutEmpresaInput
  }

  export type EmpresaCreateOrConnectWithoutXmlDocumentsInput = {
    where: EmpresaWhereUniqueInput
    create: XOR<EmpresaCreateWithoutXmlDocumentsInput, EmpresaUncheckedCreateWithoutXmlDocumentsInput>
  }

  export type XMLItemCreateWithoutXmlDocumentInput = {
    id?: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
  }

  export type XMLItemUncheckedCreateWithoutXmlDocumentInput = {
    id?: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
  }

  export type XMLItemCreateOrConnectWithoutXmlDocumentInput = {
    where: XMLItemWhereUniqueInput
    create: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput>
  }

  export type XMLItemCreateManyXmlDocumentInputEnvelope = {
    data: XMLItemCreateManyXmlDocumentInput | XMLItemCreateManyXmlDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithoutXmlDocumentsInput = {
    update: XOR<DocumentUpdateWithoutXmlDocumentsInput, DocumentUncheckedUpdateWithoutXmlDocumentsInput>
    create: XOR<DocumentCreateWithoutXmlDocumentsInput, DocumentUncheckedCreateWithoutXmlDocumentsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutXmlDocumentsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutXmlDocumentsInput, DocumentUncheckedUpdateWithoutXmlDocumentsInput>
  }

  export type DocumentUpdateWithoutXmlDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutXmlDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EmpresaUpsertWithoutXmlDocumentsInput = {
    update: XOR<EmpresaUpdateWithoutXmlDocumentsInput, EmpresaUncheckedUpdateWithoutXmlDocumentsInput>
    create: XOR<EmpresaCreateWithoutXmlDocumentsInput, EmpresaUncheckedCreateWithoutXmlDocumentsInput>
    where?: EmpresaWhereInput
  }

  export type EmpresaUpdateToOneWithWhereWithoutXmlDocumentsInput = {
    where?: EmpresaWhereInput
    data: XOR<EmpresaUpdateWithoutXmlDocumentsInput, EmpresaUncheckedUpdateWithoutXmlDocumentsInput>
  }

  export type EmpresaUpdateWithoutXmlDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUpdateManyWithoutEmpresaNestedInput
  }

  export type EmpresaUncheckedUpdateWithoutXmlDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    ie?: NullableStringFieldUpdateOperationsInput | string | null
    im?: NullableStringFieldUpdateOperationsInput | string | null
    cnae?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    regimeTributario?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedContribuicoesApuracao?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutEmpresaNestedInput
    spedFiscalApuracao?: SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaNestedInput
  }

  export type XMLItemUpsertWithWhereUniqueWithoutXmlDocumentInput = {
    where: XMLItemWhereUniqueInput
    update: XOR<XMLItemUpdateWithoutXmlDocumentInput, XMLItemUncheckedUpdateWithoutXmlDocumentInput>
    create: XOR<XMLItemCreateWithoutXmlDocumentInput, XMLItemUncheckedCreateWithoutXmlDocumentInput>
  }

  export type XMLItemUpdateWithWhereUniqueWithoutXmlDocumentInput = {
    where: XMLItemWhereUniqueInput
    data: XOR<XMLItemUpdateWithoutXmlDocumentInput, XMLItemUncheckedUpdateWithoutXmlDocumentInput>
  }

  export type XMLItemUpdateManyWithWhereWithoutXmlDocumentInput = {
    where: XMLItemScalarWhereInput
    data: XOR<XMLItemUpdateManyMutationInput, XMLItemUncheckedUpdateManyWithoutXmlDocumentInput>
  }

  export type XMLItemScalarWhereInput = {
    AND?: XMLItemScalarWhereInput | XMLItemScalarWhereInput[]
    OR?: XMLItemScalarWhereInput[]
    NOT?: XMLItemScalarWhereInput | XMLItemScalarWhereInput[]
    id?: StringFilter<"XMLItem"> | string
    xmlDocumentId?: StringFilter<"XMLItem"> | string
    codigo?: StringFilter<"XMLItem"> | string
    descricao?: StringFilter<"XMLItem"> | string
    ncm?: StringFilter<"XMLItem"> | string
    cfop?: StringFilter<"XMLItem"> | string
    quantidade?: FloatFilter<"XMLItem"> | number
    valorUnitario?: FloatFilter<"XMLItem"> | number
    valorTotal?: FloatFilter<"XMLItem"> | number
    cst?: StringFilter<"XMLItem"> | string
    aliquotaIcms?: FloatFilter<"XMLItem"> | number
    valorIcms?: FloatFilter<"XMLItem"> | number
    aliquotaIpi?: FloatNullableFilter<"XMLItem"> | number | null
    valorIpi?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaPis?: FloatNullableFilter<"XMLItem"> | number | null
    valorPis?: FloatNullableFilter<"XMLItem"> | number | null
    aliquotaCofins?: FloatNullableFilter<"XMLItem"> | number | null
    valorCofins?: FloatNullableFilter<"XMLItem"> | number | null
    createdAt?: DateTimeFilter<"XMLItem"> | Date | string
  }

  export type XMLDocumentCreateWithoutItensInput = {
    id?: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutXmlDocumentsInput
    empresa: EmpresaCreateNestedOneWithoutXmlDocumentsInput
  }

  export type XMLDocumentUncheckedCreateWithoutItensInput = {
    id?: string
    documentId: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XMLDocumentCreateOrConnectWithoutItensInput = {
    where: XMLDocumentWhereUniqueInput
    create: XOR<XMLDocumentCreateWithoutItensInput, XMLDocumentUncheckedCreateWithoutItensInput>
  }

  export type XMLDocumentUpsertWithoutItensInput = {
    update: XOR<XMLDocumentUpdateWithoutItensInput, XMLDocumentUncheckedUpdateWithoutItensInput>
    create: XOR<XMLDocumentCreateWithoutItensInput, XMLDocumentUncheckedCreateWithoutItensInput>
    where?: XMLDocumentWhereInput
  }

  export type XMLDocumentUpdateToOneWithWhereWithoutItensInput = {
    where?: XMLDocumentWhereInput
    data: XOR<XMLDocumentUpdateWithoutItensInput, XMLDocumentUncheckedUpdateWithoutItensInput>
  }

  export type XMLDocumentUpdateWithoutItensInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutXmlDocumentsNestedInput
    empresa?: EmpresaUpdateOneRequiredWithoutXmlDocumentsNestedInput
  }

  export type XMLDocumentUncheckedUpdateWithoutItensInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutProcessamentosInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessamentosInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessamentosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessamentosInput, UserUncheckedCreateWithoutProcessamentosInput>
  }

  export type DocumentCreateWithoutProcessamentosInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    empresa?: EmpresaCreateNestedOneWithoutDocumentosInput
    aiResults?: AIProcessingResultCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutProcessamentosInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiResults?: AIProcessingResultUncheckedCreateNestedManyWithoutDocumentInput
    xmlDocuments?: XMLDocumentUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedCreateNestedManyWithoutDocumentInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalItems?: SpedFiscalItemUncheckedCreateNestedManyWithoutDocumentInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutProcessamentosInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutProcessamentosInput, DocumentUncheckedCreateWithoutProcessamentosInput>
  }

  export type UserUpsertWithoutProcessamentosInput = {
    update: XOR<UserUpdateWithoutProcessamentosInput, UserUncheckedUpdateWithoutProcessamentosInput>
    create: XOR<UserCreateWithoutProcessamentosInput, UserUncheckedCreateWithoutProcessamentosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessamentosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessamentosInput, UserUncheckedUpdateWithoutProcessamentosInput>
  }

  export type UserUpdateWithoutProcessamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentUpsertWithoutProcessamentosInput = {
    update: XOR<DocumentUpdateWithoutProcessamentosInput, DocumentUncheckedUpdateWithoutProcessamentosInput>
    create: XOR<DocumentCreateWithoutProcessamentosInput, DocumentUncheckedCreateWithoutProcessamentosInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutProcessamentosInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutProcessamentosInput, DocumentUncheckedUpdateWithoutProcessamentosInput>
  }

  export type DocumentUpdateWithoutProcessamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutProcessamentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessamentoCreateManyUserInput = {
    id?: string
    documentoId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type LogCreateManyUserInput = {
    id?: string
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneWithoutDocumentosNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    empresaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documento?: DocumentUpdateOneRequiredWithoutProcessamentosNestedInput
  }

  export type ProcessamentoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyEmpresaInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    path: string
    size: number
    mimeType: string
    status: $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpedContribuicoesItemCreateManyEmpresaInput = {
    id?: string
    documentId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoCreateManyEmpresaInput = {
    id?: string
    documentId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemCreateManyEmpresaInput = {
    id?: string
    documentId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoCreateManyEmpresaInput = {
    id?: string
    documentId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type XMLDocumentCreateManyEmpresaInput = {
    id?: string
    documentId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    processamentos?: ProcessamentoUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processamentos?: ProcessamentoUncheckedUpdateManyWithoutDocumentoNestedInput
    aiResults?: AIProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput
    xmlDocuments?: XMLDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesItems?: SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedContribuicoesApuracoes?: SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalItems?: SpedFiscalItemUncheckedUpdateManyWithoutDocumentNestedInput
    spedFiscalApuracoes?: SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput
  }

  export type SpedContribuicoesItemUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedContribuicoesApuracoesNestedInput
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedFiscalItemsNestedInput
  }

  export type SpedFiscalItemUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSpedFiscalApuracoesNestedInput
  }

  export type SpedFiscalApuracaoUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLDocumentUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutXmlDocumentsNestedInput
    itens?: XMLItemUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentUncheckedUpdateWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: XMLItemUncheckedUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentUncheckedUpdateManyWithoutEmpresaInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoCreateManyDocumentoInput = {
    id?: string
    userId: string
    status: $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProcessingResultCreateManyDocumentInput = {
    id?: string
    model: string
    tokens: number
    processingTime: number
    result: JsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
  }

  export type XMLDocumentCreateManyDocumentInput = {
    id?: string
    empresaId: string
    tipoDocumento: string
    numeroDocumento: string
    serie: string
    dataEmissao: Date | string
    valorTotal: number
    cnpjEmitente: string
    cnpjDestinatario?: string | null
    cpfDestinatario?: string | null
    chaveAcesso?: string | null
    protocolo?: string | null
    status: string
    observacoes?: string | null
    valorTotalIcms: number
    valorTotalIpi?: number | null
    valorTotalPis: number
    valorTotalCofins: number
    valorTotalIss?: number | null
    baseCalculoIcms: number
    baseCalculoPis: number
    baseCalculoCofins: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpedContribuicoesItemCreateManyDocumentInput = {
    id?: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    valor: number
    basePis: number
    valorPis: number
    baseCofins: number
    valorCofins: number
    createdAt?: Date | string
  }

  export type SpedContribuicoesApuracaoCreateManyDocumentInput = {
    id?: string
    empresaId: string
    tipo: string
    periodo: string
    base?: number | null
    aliquota?: number | null
    valor: number
    createdAt?: Date | string
  }

  export type SpedFiscalItemCreateManyDocumentInput = {
    id?: string
    empresaId: string
    documento: string
    data: string
    cnpj: string
    produto: string
    cfop: string
    cst: string
    ncm: string
    valor: number
    baseIcms: number
    valorIcms: number
    baseIpi: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type SpedFiscalApuracaoCreateManyDocumentInput = {
    id?: string
    empresaId: string
    cst: string
    cfop: string
    aliquota: number
    valorOperacao: number
    baseIcms: number
    valorIcms: number
    baseIcmsSt: number
    valorIcmsSt: number
    valorRedBc: number
    valorIpi: number
    createdAt?: Date | string
  }

  export type ProcessamentoUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessamentosNestedInput
  }

  export type ProcessamentoUncheckedUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessamentoUncheckedUpdateManyWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessamentoStatusFieldUpdateOperationsInput | $Enums.ProcessamentoStatus
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProcessingResultUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    tokens?: IntFieldUpdateOperationsInput | number
    processingTime?: IntFieldUpdateOperationsInput | number
    result?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLDocumentUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutXmlDocumentsNestedInput
    itens?: XMLItemUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itens?: XMLItemUncheckedUpdateManyWithoutXmlDocumentNestedInput
  }

  export type XMLDocumentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipoDocumento?: StringFieldUpdateOperationsInput | string
    numeroDocumento?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cnpjEmitente?: StringFieldUpdateOperationsInput | string
    cnpjDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    cpfDestinatario?: NullableStringFieldUpdateOperationsInput | string | null
    chaveAcesso?: NullableStringFieldUpdateOperationsInput | string | null
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalIcms?: FloatFieldUpdateOperationsInput | number
    valorTotalIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorTotalPis?: FloatFieldUpdateOperationsInput | number
    valorTotalCofins?: FloatFieldUpdateOperationsInput | number
    valorTotalIss?: NullableFloatFieldUpdateOperationsInput | number | null
    baseCalculoIcms?: FloatFieldUpdateOperationsInput | number
    baseCalculoPis?: FloatFieldUpdateOperationsInput | number
    baseCalculoCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutSpedContribuicoesItemsNestedInput
  }

  export type SpedContribuicoesItemUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesItemUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    basePis?: FloatFieldUpdateOperationsInput | number
    valorPis?: FloatFieldUpdateOperationsInput | number
    baseCofins?: FloatFieldUpdateOperationsInput | number
    valorCofins?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutSpedContribuicoesApuracaoNestedInput
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedContribuicoesApuracaoUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    base?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquota?: NullableFloatFieldUpdateOperationsInput | number | null
    valor?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutSpedFiscalItemsNestedInput
  }

  export type SpedFiscalItemUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalItemUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    produto?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    valor?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIpi?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empresa?: EmpresaUpdateOneRequiredWithoutSpedFiscalApuracaoNestedInput
  }

  export type SpedFiscalApuracaoUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpedFiscalApuracaoUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empresaId?: StringFieldUpdateOperationsInput | string
    cst?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    aliquota?: FloatFieldUpdateOperationsInput | number
    valorOperacao?: FloatFieldUpdateOperationsInput | number
    baseIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    baseIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorIcmsSt?: FloatFieldUpdateOperationsInput | number
    valorRedBc?: FloatFieldUpdateOperationsInput | number
    valorIpi?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemCreateManyXmlDocumentInput = {
    id?: string
    codigo: string
    descricao: string
    ncm: string
    cfop: string
    quantidade: number
    valorUnitario: number
    valorTotal: number
    cst: string
    aliquotaIcms: number
    valorIcms: number
    aliquotaIpi?: number | null
    valorIpi?: number | null
    aliquotaPis?: number | null
    valorPis?: number | null
    aliquotaCofins?: number | null
    valorCofins?: number | null
    createdAt?: Date | string
  }

  export type XMLItemUpdateWithoutXmlDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemUncheckedUpdateWithoutXmlDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XMLItemUncheckedUpdateManyWithoutXmlDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    ncm?: StringFieldUpdateOperationsInput | string
    cfop?: StringFieldUpdateOperationsInput | string
    quantidade?: FloatFieldUpdateOperationsInput | number
    valorUnitario?: FloatFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    cst?: StringFieldUpdateOperationsInput | string
    aliquotaIcms?: FloatFieldUpdateOperationsInput | number
    valorIcms?: FloatFieldUpdateOperationsInput | number
    aliquotaIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    valorIpi?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaPis?: NullableFloatFieldUpdateOperationsInput | number | null
    valorPis?: NullableFloatFieldUpdateOperationsInput | number | null
    aliquotaCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    valorCofins?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaCountOutputTypeDefaultArgs instead
     */
    export type EmpresaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCountOutputTypeDefaultArgs instead
     */
    export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XMLDocumentCountOutputTypeDefaultArgs instead
     */
    export type XMLDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XMLDocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIProcessingResultDefaultArgs instead
     */
    export type AIProcessingResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIProcessingResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CacheEntryDefaultArgs instead
     */
    export type CacheEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CacheEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpedContribuicoesItemDefaultArgs instead
     */
    export type SpedContribuicoesItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpedContribuicoesItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpedContribuicoesApuracaoDefaultArgs instead
     */
    export type SpedContribuicoesApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpedContribuicoesApuracaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpedFiscalItemDefaultArgs instead
     */
    export type SpedFiscalItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpedFiscalItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpedFiscalApuracaoDefaultArgs instead
     */
    export type SpedFiscalApuracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpedFiscalApuracaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XMLDocumentDefaultArgs instead
     */
    export type XMLDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XMLDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use XMLItemDefaultArgs instead
     */
    export type XMLItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = XMLItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcessamentoDefaultArgs instead
     */
    export type ProcessamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcessamentoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}